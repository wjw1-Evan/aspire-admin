---
description: .NET Aspire 微服务架构和编排规范
globs: *.cs,*.json
---

# .NET Aspire 微服务架构和编排规范

## 🎯 核心原则

**使用 .NET Aspire 实现现代化的微服务架构，通过服务编排实现松耦合、高可用的系统**

## 🏗️ Aspire 应用主机架构

### AppHost 配置规范
```csharp
// ✅ 正确：AppHost.cs 标准配置
var builder = DistributedApplication.CreateBuilder(args);

// 1. 基础设施服务
var mongo = builder.AddMongoDB("mongo")
    .WithMongoExpress()
    .WithLifetime(ContainerLifetime.Persistent);
var mongodb = mongo.AddDatabase("mongodb");

// 2. 微服务定义
var datainitializer = builder.AddProject<Projects.Platform_DataInitializer>("datainitializer")
    .WithReference(mongodb)
    .WithHttpEndpoint()
    .WithHttpHealthCheck("/health");

var apiservice = builder.AddProject<Projects.Platform_ApiService>("apiservice")
    .WithReference(mongodb)
    .WithReference(datainitializer)
    .WithHttpHealthCheck("/health");

// 3. API 网关配置
var yarp = builder.AddYarp("apigateway")
    .WithHostPort(15000)
    .WithConfiguration(config => {
        config.AddRoute("/{service}/{**catch-all}", config.AddCluster(apiservice))
            .WithTransformPathRouteValues("/api/{**catch-all}");
    });

// 4. 前端应用
builder.AddNpmApp("admin", "../Platform.Admin")
    .WithReference(yarp)
    .WaitFor(yarp)
    .WithHttpEndpoint(env: "PORT", port: 15001);

builder.AddNpmApp("app", "../Platform.App")
    .WithReference(yarp)
    .WaitFor(yarp)
    .WithHttpEndpoint(env: "PORT", port: 15002);

var app = builder.Build();
await app.RunAsync();
```

### 服务依赖管理
```csharp
// ✅ 正确：服务依赖顺序
// MongoDB → DataInitializer → ApiService → Frontend Apps

// ✅ 正确：健康检查配置
.WithHttpHealthCheck("/health", healthCheck =>
{
    healthCheck.UsePath("/health");
    healthCheck.UseMethod(HttpMethod.Get);
})

// ✅ 正确：服务发现配置
.WithReference(service, reference =>
{
    reference.WithHttpEndpoint();
    reference.WithEnvironment("SERVICE_URL", service.GetEndpoint("http"));
})
```

## 🔧 微服务设计模式

### 任务型微服务模式
```csharp
// ✅ 正确：数据初始化微服务实现
public class DataInitializerService : IDataInitializerService
{
    private readonly IMongoDatabase _database;
    private readonly ILogger<DataInitializerService> _logger;

    public async Task InitializeAsync()
    {
        try
        {
            _logger.LogInformation("开始数据初始化...");
            
            // 1. 创建数据库索引
            await CreateIndexesAsync();
            
            // 2. 创建系统菜单
            await CreateSystemMenusAsync();
            
            _logger.LogInformation("数据初始化完成");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "数据初始化失败");
            throw;
        }
    }

    public async Task<bool> IsInitializedAsync()
    {
        var menus = _database.GetCollection<Menu>("menus");
        var count = await menus.CountDocumentsAsync(FilterDefinition<Menu>.Empty);
        return count > 0;
    }
}
```

### 服务间通信
```csharp
// ✅ 正确：服务间 HTTP 调用
public class ApiServiceHealthCheck : IHealthCheck
{
    private readonly HttpClient _httpClient;

    public async Task<HealthCheckResult> CheckHealthAsync(
        HealthCheckContext context, 
        CancellationToken cancellationToken = default)
    {
        try
        {
            var response = await _httpClient.GetAsync("/health", cancellationToken);
            return response.IsSuccessStatusCode 
                ? HealthCheckResult.Healthy("API service is healthy")
                : HealthCheckResult.Unhealthy("API service is unhealthy");
        }
        catch (Exception ex)
        {
            return HealthCheckResult.Unhealthy("API service check failed", ex);
        }
    }
}

// ✅ 正确：服务发现和配置
public class ServiceConfiguration
{
    public static void ConfigureServices(IServiceCollection services, IConfiguration configuration)
    {
        // 服务发现
        services.AddHttpClient<IDataInitializerClient, DataInitializerClient>(client =>
        {
            var serviceUrl = configuration["Services:DataInitializer:Url"];
            client.BaseAddress = new Uri(serviceUrl);
        });

        // 健康检查
        services.AddHealthChecks()
            .AddCheck<ApiServiceHealthCheck>("api-service")
            .AddMongoDb(configuration.GetConnectionString("mongodb"));
    }
}
```

## 📊 监控和可观测性

### 分布式追踪
```csharp
// ✅ 正确：OpenTelemetry 配置
public static class TelemetryConfiguration
{
    public static void ConfigureTelemetry(IServiceCollection services)
    {
        services.AddOpenTelemetry()
            .WithTracing(tracing =>
            {
                tracing
                    .AddAspNetCoreInstrumentation()
                    .AddHttpClientInstrumentation()
                    .AddMongoDBInstrumentation()
                    .AddJaegerExporter();
            })
            .WithMetrics(metrics =>
            {
                metrics
                    .AddAspNetCoreInstrumentation()
                    .AddHttpClientInstrumentation()
                    .AddPrometheusExporter();
            });
    }
}

// ✅ 正确：自定义活动追踪
public class UserService
{
    private static readonly ActivitySource ActivitySource = new("Platform.UserService");

    public async Task<User> CreateUserAsync(CreateUserRequest request)
    {
        using var activity = ActivitySource.StartActivity("CreateUser");
        activity?.SetTag("user.email", request.Email);
        activity?.SetTag("user.company", request.CompanyId);

        try
        {
            var user = await ProcessUserCreationAsync(request);
            activity?.SetStatus(ActivityStatusCode.Ok);
            return user;
        }
        catch (Exception ex)
        {
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            throw;
        }
    }
}
```

### 日志聚合
```csharp
// ✅ 正确：结构化日志配置
public static class LoggingConfiguration
{
    public static void ConfigureLogging(IServiceCollection services, IConfiguration configuration)
    {
        services.AddLogging(builder =>
        {
            builder.AddConsole(options =>
            {
                options.FormatterName = "json";
            });
            
            builder.AddSeq(configuration.GetConnectionString("seq"));
            
            builder.AddFilter("Microsoft.AspNetCore", LogLevel.Warning);
            builder.AddFilter("System.Net.Http.HttpClient", LogLevel.Warning);
        });
    }
}

// ✅ 正确：结构化日志使用
public class OrderService
{
    private readonly ILogger<OrderService> _logger;

    public async Task<Order> ProcessOrderAsync(OrderRequest request)
    {
        using var scope = _logger.BeginScope(new Dictionary<string, object>
        {
            ["OrderId"] = request.OrderId,
            ["UserId"] = request.UserId,
            ["CompanyId"] = request.CompanyId
        });

        _logger.LogInformation("开始处理订单 {OrderId}", request.OrderId);

        try
        {
            var order = await CreateOrderAsync(request);
            _logger.LogInformation("订单处理成功 {OrderId}", order.Id);
            return order;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "订单处理失败 {OrderId}", request.OrderId);
            throw;
        }
    }
}
```

## 🔄 服务编排和生命周期

### 服务启动顺序
```csharp
// ✅ 正确：服务依赖和启动顺序
public class ServiceOrchestration
{
    public static void ConfigureServiceDependencies(IServiceCollection services)
    {
        // 1. 基础设施服务（MongoDB）
        services.AddSingleton<IMongoDatabase>(provider =>
        {
            var connectionString = provider.GetRequiredService<IConfiguration>()
                .GetConnectionString("mongodb");
            var client = new MongoClient(connectionString);
            return client.GetDatabase("aspire-admin");
        });

        // 2. 数据初始化服务
        services.AddScoped<IDataInitializerService, DataInitializerService>();

        // 3. 业务服务（依赖数据初始化）
        services.AddScoped<IUserService, UserService>();
        services.AddScoped<IMenuService, MenuService>();
        services.AddScoped<IRoleService, RoleService>();
    }
}
```

### 优雅关闭
```csharp
// ✅ 正确：优雅关闭处理
public class GracefulShutdownService : IHostedService
{
    private readonly ILogger<GracefulShutdownService> _logger;
    private readonly IHostApplicationLifetime _lifetime;

    public async Task StartAsync(CancellationToken cancellationToken)
    {
        _lifetime.ApplicationStopping.Register(OnStopping);
        _lifetime.ApplicationStopped.Register(OnStopped);
    }

    private void OnStopping()
    {
        _logger.LogInformation("服务正在停止...");
        
        // 停止接收新请求
        // 等待现有请求完成
        // 清理资源
    }

    private void OnStopped()
    {
        _logger.LogInformation("服务已停止");
    }

    public Task StopAsync(CancellationToken cancellationToken)
    {
        return Task.CompletedTask;
    }
}
```

## 🌐 配置管理

### 环境配置
```json
// ✅ 正确：appsettings.json 配置
{
  "ConnectionStrings": {
    "mongodb": "mongodb://localhost:27017"
  },
  "Services": {
    "DataInitializer": {
      "Url": "http://localhost:15000/datainitializer",
      "Timeout": "00:01:00"
    },
    "ApiService": {
      "Url": "http://localhost:15000/apiservice",
      "Timeout": "00:00:30"
    }
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Platform": "Debug"
    }
  },
  "HealthChecks": {
    "Enabled": true,
    "Interval": "00:00:30"
  }
}
```

### 配置注入
```csharp
// ✅ 正确：配置选项模式
public class ServiceOptions
{
    public const string SectionName = "Services";
    
    public string DataInitializerUrl { get; set; } = string.Empty;
    public TimeSpan Timeout { get; set; } = TimeSpan.FromSeconds(30);
    public int RetryCount { get; set; } = 3;
}

public static class ServiceConfiguration
{
    public static void ConfigureServices(IServiceCollection services, IConfiguration configuration)
    {
        services.Configure<ServiceOptions>(
            configuration.GetSection(ServiceOptions.SectionName));
            
        services.AddHttpClient<IDataInitializerClient, DataInitializerClient>((serviceProvider, client) =>
        {
            var options = serviceProvider.GetRequiredService<IOptions<ServiceOptions>>().Value;
            client.BaseAddress = new Uri(options.DataInitializerUrl);
            client.Timeout = options.Timeout;
        });
    }
}
```

## 🚀 部署和扩展

### Docker 配置
```dockerfile
# ✅ 正确：多阶段构建
FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS base
WORKDIR /app
EXPOSE 8080

FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
WORKDIR /src
COPY ["Platform.ApiService/Platform.ApiService.csproj", "Platform.ApiService/"]
RUN dotnet restore "Platform.ApiService/Platform.ApiService.csproj"
COPY . .
WORKDIR "/src/Platform.ApiService"
RUN dotnet build "Platform.ApiService.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "Platform.ApiService.csproj" -c Release -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "Platform.ApiService.dll"]
```

### Kubernetes 部署
```yaml
# ✅ 正确：Kubernetes 部署配置
apiVersion: apps/v1
kind: Deployment
metadata:
  name: platform-apiservice
spec:
  replicas: 3
  selector:
    matchLabels:
      app: platform-apiservice
  template:
    metadata:
      labels:
        app: platform-apiservice
    spec:
      containers:
      - name: apiservice
        image: platform/apiservice:latest
        ports:
        - containerPort: 8080
        env:
        - name: ConnectionStrings__mongodb
          valueFrom:
            secretKeyRef:
              name: mongodb-secret
              key: connection-string
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
```

## 📋 微服务开发检查清单

### 服务设计
- [ ] 单一职责原则
- [ ] 松耦合设计
- [ ] 无状态服务
- [ ] 幂等性操作
- [ ] 优雅降级

### 通信协议
- [ ] HTTP/REST API
- [ ] 异步消息传递
- [ ] 服务发现
- [ ] 负载均衡
- [ ] 熔断器模式

### 数据管理
- [ ] 数据库分离
- [ ] 事务边界
- [ ] 数据一致性
- [ ] 缓存策略
- [ ] 数据迁移

### 监控运维
- [ ] 健康检查
- [ ] 指标收集
- [ ] 日志聚合
- [ ] 分布式追踪
- [ ] 告警机制

## 📚 相关资源

- [.NET Aspire 官方文档](https://learn.microsoft.com/aspnet/core/aspire/)
- [微服务架构模式](https://microservices.io/)
- [OpenTelemetry 文档](https://opentelemetry.io/docs/)
- [Kubernetes 最佳实践](https://kubernetes.io/docs/concepts/)

## 🎯 记住

**微服务架构的核心是服务编排和可观测性**

- 使用 Aspire 简化微服务开发
- 重视服务间的依赖关系
- 实现完整的监控和日志
- 设计可扩展的服务架构
- 保持服务的独立性和可测试性