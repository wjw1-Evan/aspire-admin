---
globs: **/auth*.ts,**/auth*.tsx,**/Auth*.tsx,**/contexts/AuthContext.tsx,**/services/auth.ts,**/hooks/use-auth.ts
description: è®¤è¯ç³»ç»Ÿå¼€å‘è§„èŒƒå’Œæœ€ä½³å®è·µ
---

# è®¤è¯ç³»ç»Ÿå¼€å‘è§„èŒƒ

## ğŸ¯ ç³»ç»Ÿæ¶æ„

### ç»Ÿä¸€è®¤è¯æ¶æ„

é¡¹ç›®é‡‡ç”¨å‰åç«¯å®Œå…¨ç»Ÿä¸€çš„è®¤è¯ç³»ç»Ÿï¼š

- **JWT Token è®¤è¯** - åŸºäº JWT çš„ç®€å• token æœºåˆ¶
- **ç»Ÿä¸€ API æ¥å£** - å‰åç«¯ä½¿ç”¨ç›¸åŒçš„è®¤è¯ç«¯ç‚¹
- **åŸºäº access å­—æ®µçš„æƒé™ç³»ç»Ÿ** - ç®€åŒ–çš„æƒé™æ§åˆ¶
- **è‡ªåŠ¨ token éªŒè¯** - æ™ºèƒ½çš„ç½‘ç»œé‡è¯•æœºåˆ¶

### æ ¸å¿ƒç»„ä»¶

- **AuthContext** - å…¨å±€è®¤è¯çŠ¶æ€ç®¡ç†
- **AuthService** - è®¤è¯ API æœåŠ¡
- **AuthGuard** - æƒé™å®ˆå«ç»„ä»¶
- **RouteGuard** - è·¯ç”±å®ˆå«ç»„ä»¶
- **useAuth** - è®¤è¯çŠ¶æ€ Hook
- **usePermissions** - æƒé™æ£€æŸ¥ Hook

## ğŸ”§ è®¤è¯æœåŠ¡

### API æ¥å£è§„èŒƒ

```typescript
// âœ… æ¨èï¼šç»Ÿä¸€çš„è®¤è¯æ¥å£
interface AuthEndpoints {
  login: 'POST /login/account';           // ç”¨æˆ·ç™»å½•
  logout: 'POST /login/outLogin';         // ç”¨æˆ·ç™»å‡º
  currentUser: 'GET /currentUser';        // è·å–å½“å‰ç”¨æˆ·
  register: 'POST /register';             // ç”¨æˆ·æ³¨å†Œ
  changePassword: 'POST /change-password'; // ä¿®æ”¹å¯†ç 
  captcha: 'GET /login/captcha';          // è·å–éªŒè¯ç 
}
```

### è®¤è¯æœåŠ¡å®ç°

```typescript
// âœ… æ¨èï¼šè®¤è¯æœåŠ¡ç±»
export class AuthService {
  private static readonly BASE_URL = '/apiservice/api';
  
  static async login(credentials: LoginRequest): Promise<LoginResult> {
    try {
      const response = await apiClient.post(`${this.BASE_URL}/login/account`, credentials);
      const { token, currentAuthority } = response.data;
      
      // å­˜å‚¨ token
      await AsyncStorage.setItem('auth_token', token);
      
      return response.data;
    } catch (error) {
      console.error('Login failed:', error);
      throw error;
    }
  }
  
  static async logout(): Promise<void> {
    try {
      // è°ƒç”¨åç«¯ç™»å‡ºæ¥å£
      await apiClient.post(`${this.BASE_URL}/login/outLogin`);
      
      // æ¸…é™¤æœ¬åœ°å­˜å‚¨
      await AsyncStorage.removeItem('auth_token');
      await AsyncStorage.removeItem('user_info');
    } catch (error) {
      console.error('Logout failed:', error);
    }
  }
  
  static async getCurrentUser(): Promise<CurrentUser> {
    try {
      const response = await apiClient.get(`${this.BASE_URL}/currentUser`);
      return response.data;
    } catch (error) {
      console.error('Failed to get current user:', error);
      throw error;
    }
  }
}
```

## ğŸ£ è®¤è¯ Hooks

### useAuth Hook

```typescript
// âœ… æ¨èï¼šè®¤è¯çŠ¶æ€ç®¡ç† Hook
export function useAuth() {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [user, setUser] = useState<CurrentUser | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    checkAuthStatus();
  }, []);
  
  const checkAuthStatus = async () => {
    try {
      const token = await AuthService.getStoredToken();
      
      if (token) {
        // éªŒè¯ token æœ‰æ•ˆæ€§
        const currentUser = await AuthService.getCurrentUser();
        setUser(currentUser);
        setIsAuthenticated(true);
      }
    } catch (error) {
      console.error('Auth check failed:', error);
      setError('è®¤è¯éªŒè¯å¤±è´¥');
      setIsAuthenticated(false);
    } finally {
      setLoading(false);
    }
  };
  
  const login = async (credentials: LoginRequest) => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await AuthService.login(credentials);
      
      // è·å–ç”¨æˆ·ä¿¡æ¯
      const currentUser = await AuthService.getCurrentUser();
      setUser(currentUser);
      setIsAuthenticated(true);
      
      return response;
    } catch (error) {
      setError(error instanceof Error ? error.message : 'ç™»å½•å¤±è´¥');
      throw error;
    } finally {
      setLoading(false);
    }
  };
  
  const logout = async () => {
    try {
      await AuthService.logout();
      setUser(null);
      setIsAuthenticated(false);
      setError(null);
    } catch (error) {
      console.error('Logout error:', error);
    }
  };
  
  return { isAuthenticated, user, loading, error, login, logout, checkAuthStatus };
}
```

### usePermissions Hook

```typescript
// âœ… æ¨èï¼šæƒé™æ£€æŸ¥ Hook
export function usePermissions() {
  const { user, isAuthenticated } = useAuth();
  
  const checkPermission = useCallback((check: PermissionCheck): boolean => {
    if (!isAuthenticated || !user) {
      return false;
    }
    
    const { access, role } = check;
    
    // æ£€æŸ¥è§’è‰²ï¼ˆå…¼å®¹æ€§ï¼‰
    if (role && user.access === role) {
      return true;
    }
    
    // æ£€æŸ¥æƒé™ï¼ˆåŸºäº access å­—æ®µï¼‰
    if (access && user.access === access) {
      return true;
    }
    
    return false;
  }, [user, isAuthenticated]);
  
  const checkRole = useCallback((role: string): boolean => {
    return checkPermission({ role });
  }, [checkPermission]);
  
  const checkAllRoles = useCallback((roles: string[]): boolean => {
    return roles.every(role => checkRole(role));
  }, [checkRole]);
  
  return {
    checkPermission,
    checkRole,
    checkAllRoles,
    user,
    isAuthenticated,
  };
}
```

## ğŸ›¡ï¸ æƒé™å®ˆå«

### AuthGuard ç»„ä»¶

```typescript
// âœ… æ¨èï¼šæƒé™å®ˆå«ç»„ä»¶
interface AuthGuardProps {
  readonly permission?: PermissionCheck;
  readonly fallback?: React.ReactNode;
  readonly children: React.ReactNode;
}

export function AuthGuard({ permission, fallback, children }: AuthGuardProps) {
  const { isAuthenticated, loading } = useAuth();
  const { checkPermission } = usePermissions();
  
  if (loading) {
    return <LoadingSpinner />;
  }
  
  if (!isAuthenticated) {
    return <Navigate to="/auth/login" replace />;
  }
  
  if (permission && !checkPermission(permission)) {
    return fallback || <AccessDenied />;
  }
  
  return <>{children}</>;
}
```

### RouteGuard ç»„ä»¶

```typescript
// âœ… æ¨èï¼šè·¯ç”±å®ˆå«ç»„ä»¶
export function RouteGuard({ children }: { children: React.ReactNode }) {
  const { isAuthenticated, loading } = useAuth();
  
  if (loading) {
    return <LoadingScreen />;
  }
  
  if (!isAuthenticated) {
    return <Navigate to="/auth/login" replace />;
  }
  
  return <>{children}</>;
}
```

## ğŸ“± ç§»åŠ¨ç«¯è®¤è¯

### è®¤è¯ä¸Šä¸‹æ–‡é›†æˆ

```typescript
// âœ… æ¨èï¼šç§»åŠ¨ç«¯è®¤è¯ä¸Šä¸‹æ–‡
export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = useReducer(authReducer, initialState);
  
  const value = useMemo(() => ({
    ...state,
    login: (credentials: LoginRequest) => dispatch({ type: 'LOGIN_START', payload: credentials }),
    logout: () => dispatch({ type: 'LOGOUT' }),
    checkAuth: () => dispatch({ type: 'CHECK_AUTH' }),
  }), [state]);
  
  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}
```

### è®¤è¯é”™è¯¯å¤„ç†

```typescript
// âœ… æ¨èï¼šè®¤è¯é”™è¯¯å¤„ç†ç»„ä»¶
export function AuthErrorHandler({ children }: { children: React.ReactNode }) {
  const { error, clearError } = useAuth();
  
  useEffect(() => {
    if (error) {
      Alert.alert('è®¤è¯é”™è¯¯', error, [
        { text: 'ç¡®å®š', onPress: clearError }
      ]);
    }
  }, [error, clearError]);
  
  return <>{children}</>;
}
```

## ğŸ”„ è®¤è¯æµç¨‹

### ç™»å½•æµç¨‹

```
ç”¨æˆ·è¾“å…¥ â†’ LoginRequest â†’ POST /login/account â†’ 
LoginResult â†’ ä¿å­˜token â†’ è·å–ç”¨æˆ·ä¿¡æ¯ â†’ æ›´æ–°çŠ¶æ€
```

### æƒé™æ£€æŸ¥æµç¨‹

```
ç»„ä»¶ â†’ usePermissions â†’ æ£€æŸ¥user.access â†’ 
è¿”å›æƒé™ç»“æœ â†’ æ¸²æŸ“å†³ç­–
```

### TokenéªŒè¯æµç¨‹

```
å®šæœŸæ£€æŸ¥ â†’ validateToken() â†’ GET /currentUser â†’ 
éªŒè¯å“åº” â†’ æ›´æ–°ç”¨æˆ·çŠ¶æ€
```

## ğŸ”„ ä½¿ç”¨tokenåˆ·æ–°åŠŸèƒ½

### åˆ·æ–°Tokenæœºåˆ¶

é¡¹ç›®å·²å®ç°å®Œæ•´çš„tokenåˆ·æ–°åŠŸèƒ½ï¼Œæå‡ç”¨æˆ·ä½“éªŒå’Œå®‰å…¨æ€§ï¼š

#### åç«¯å®ç°

```csharp
// âœ… æ¨èï¼šJWTæœåŠ¡ä¸­çš„åˆ·æ–°tokenæ–¹æ³•
public string GenerateRefreshToken(AppUser user)
{
    var claims = new[]
    {
        new Claim(ClaimTypes.NameIdentifier, user.Id),
        new Claim(ClaimTypes.Name, user.Username),
        new Claim(ClaimTypes.Role, user.Access),
        new Claim("token_type", "refresh")
    };

    var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_refreshTokenSecret));
    var credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

    var token = new JwtSecurityToken(
        issuer: _issuer,
        audience: _audience,
        claims: claims,
        expires: DateTime.UtcNow.AddDays(_refreshTokenExpirationDays),
        signingCredentials: credentials
    );

    return new JwtSecurityTokenHandler().WriteToken(token);
}

// âœ… æ¨èï¼šè®¤è¯æœåŠ¡ä¸­çš„åˆ·æ–°tokenæ–¹æ³•
public async Task<RefreshTokenResult> RefreshTokenAsync(RefreshTokenRequest request)
{
    // éªŒè¯åˆ·æ–°token
    var principal = _jwtService.ValidateRefreshToken(request.RefreshToken);
    if (principal == null)
    {
        return new RefreshTokenResult
        {
            Status = "error",
            ErrorMessage = "æ— æ•ˆçš„åˆ·æ–°token"
        };
    }

    // è·å–ç”¨æˆ·ä¿¡æ¯å¹¶ç”Ÿæˆæ–°token
    var userId = _jwtService.GetUserIdFromRefreshToken(request.RefreshToken);
    var user = await _users.Find(u => u.Id == userId && u.IsActive).FirstOrDefaultAsync();
    
    if (user == null)
    {
        return new RefreshTokenResult
        {
            Status = "error",
            ErrorMessage = "ç”¨æˆ·ä¸å­˜åœ¨æˆ–å·²è¢«ç¦ç”¨"
        };
    }

    // ç”Ÿæˆæ–°çš„è®¿é—®tokenå’Œåˆ·æ–°token
    var newToken = _jwtService.GenerateToken(user);
    var newRefreshToken = _jwtService.GenerateRefreshToken(user);

    return new RefreshTokenResult
    {
        Status = "ok",
        Token = newToken,
        RefreshToken = newRefreshToken,
        ExpiresAt = DateTime.UtcNow.AddMinutes(60)
    };
}
```

#### ç§»åŠ¨ç«¯å®ç°
```typescript
// âœ… æ¨èï¼šè®¤è¯æœåŠ¡ä¸­çš„åˆ·æ–°tokenæ–¹æ³•
async refreshToken(refreshToken: string): Promise<ApiResponse<RefreshTokenResult>> {
  try {
    const request: RefreshTokenRequest = { refreshToken };
    const response = await apiService.post<RefreshTokenResult>('/refresh-token', request);
    
    if (response.status === 'ok' && response.token && response.refreshToken) {
      // ä¿å­˜æ–°çš„tokenå’Œåˆ·æ–°token
      const expiresAt = response.expiresAt ? new Date(response.expiresAt).getTime() : undefined;
      await apiService.setTokens(response.token, response.refreshToken, expiresAt);
      
      return {
        success: true,
        data: response
      };
    } else {
      return {
        success: false,
        errorMessage: response.errorMessage || 'åˆ·æ–°tokenå¤±è´¥'
      };
    }
  } catch (error) {
    console.error('Refresh token error:', error);
    return {
      success: false,
      errorMessage: 'åˆ·æ–°tokenå¤±è´¥'
    };
  }
}

// âœ… æ¨èï¼šè®¤è¯ä¸Šä¸‹æ–‡ä¸­çš„è‡ªåŠ¨åˆ·æ–°é€»è¾‘
const refreshAuth = useCallback(async () => {
  try {
    // æ£€æŸ¥ token æ˜¯å¦å­˜åœ¨ä¸”æœªè¿‡æœŸ
    if (state.token && !isTokenExpired()) {
      // å°è¯•è·å–æœ€æ–°ç”¨æˆ·ä¿¡æ¯
      const userResponse = await authService.getCurrentUser();
      if (userResponse.success && userResponse.data) {
        dispatch({ type: 'AUTH_UPDATE_USER', payload: userResponse.data });
        return;
      }
    }
    
    // å¦‚æœ token æ— æ•ˆæˆ–è¿‡æœŸï¼Œå°è¯•åˆ·æ–° token
    if (state.refreshToken) {
      const refreshResult = await authService.refreshToken(state.refreshToken);
      if (refreshResult.success && refreshResult.data) {
        const { token, refreshToken, expiresAt } = refreshResult.data;
        const tokenExpiresAt = expiresAt ? new Date(expiresAt).getTime() : undefined;
        dispatch({
          type: 'AUTH_REFRESH_TOKEN',
          payload: { token, refreshToken, expiresAt: tokenExpiresAt },
        });
        
        // è·å–ç”¨æˆ·ä¿¡æ¯
        const userResponse = await authService.getCurrentUser();
        if (userResponse.success && userResponse.data) {
          dispatch({ type: 'AUTH_UPDATE_USER', payload: userResponse.data });
        }
        return;
      }
    }
    
    // å¦‚æœåˆ·æ–°å¤±è´¥ï¼Œæ‰§è¡Œç™»å‡º
    await logout();
  } catch (error) {
    console.error('AuthContext: Refresh auth failed:', error);
    await logout();
  }
}, [state.token, state.refreshToken, state.tokenExpiresAt, logout]);
```

#### ç®¡ç†åå°å®ç°
```typescript
// âœ… æ¨èï¼šè‡ªåŠ¨tokenåˆ·æ–°æ‹¦æˆªå™¨
const responseInterceptors = [
  {
    onFulfilled: (response: any) => response,
    onRejected: async (error: any) => {
      const { response } = error;
      
      if (response?.status === 401) {
        console.log('401 Unauthorized - attempting to refresh token');
        
        const refreshToken = tokenUtils.getRefreshToken();
        if (refreshToken) {
          try {
            const { refreshToken: refreshTokenAPI } = await import('@/services/ant-design-pro/api');
            const refreshResult = await refreshTokenAPI({ refreshToken });
            
            if (refreshResult.status === 'ok' && refreshResult.token && refreshResult.refreshToken) {
              const expiresAt = refreshResult.expiresAt ? new Date(refreshResult.expiresAt).getTime() : undefined;
              tokenUtils.setTokens(refreshResult.token, refreshResult.refreshToken, expiresAt);
              
              // é‡è¯•åŸå§‹è¯·æ±‚
              const originalRequest = error.config;
              originalRequest.headers.Authorization = `Bearer ${refreshResult.token}`;
              return request(originalRequest);
            }
          } catch (refreshError) {
            console.error('Token refresh failed:', refreshError);
          }
        }
        
        // åˆ·æ–°å¤±è´¥ï¼Œè·³è½¬åˆ°ç™»å½•é¡µ
        window.location.href = '/user/login';
      }
      
      return Promise.reject(error);
    },
  },
];
```

### åˆ·æ–°Tokené…ç½®
```json
// âœ… æ¨èï¼šåç«¯é…ç½®
{
  "JwtSettings": {
    "SecretKey": "your-secret-key",
    "Issuer": "Platform.ApiService",
    "Audience": "Platform.Users",
    "ExpirationMinutes": 60,
    "RefreshTokenSecret": "your-refresh-secret-key",
    "RefreshTokenExpirationDays": 7
  }
}
```

### åˆ·æ–°Tokenæœ€ä½³å®è·µ

1. **è‡ªåŠ¨åˆ·æ–°æœºåˆ¶** - åœ¨tokenå³å°†è¿‡æœŸæ—¶è‡ªåŠ¨åˆ·æ–°
2. **å¤±è´¥å¤„ç†** - åˆ·æ–°å¤±è´¥æ—¶è‡ªåŠ¨ç™»å‡ºç”¨æˆ·
3. **å®‰å…¨å­˜å‚¨** - åˆ†åˆ«å­˜å‚¨è®¿é—®tokenå’Œåˆ·æ–°token
4. **æ´»åŠ¨æ—¥å¿—** - è®°å½•tokenåˆ·æ–°æ´»åŠ¨
5. **é”™è¯¯é‡è¯•** - ç½‘ç»œè¯·æ±‚å¤±è´¥æ—¶è‡ªåŠ¨é‡è¯•
6. **ç”¨æˆ·ä½“éªŒ** - æ— æ„ŸçŸ¥çš„tokenåˆ·æ–°

## ğŸš« é¿å…çš„åšæ³•

- ä¸è¦å¿½ç•¥tokenè¿‡æœŸå¤„ç†ï¼Œå®ç°è‡ªåŠ¨åˆ·æ–°æœºåˆ¶
- ä¸è¦ç¡¬ç¼–ç æƒé™é€»è¾‘ï¼Œä½¿ç”¨ç»Ÿä¸€çš„æƒé™ç³»ç»Ÿ
- ä¸è¦å¿˜è®°å¤„ç†è®¤è¯é”™è¯¯ï¼Œæä¾›ç”¨æˆ·å‹å¥½çš„é”™è¯¯æç¤º
- ä¸è¦åœ¨ç”Ÿäº§ç¯å¢ƒä¸­æš´éœ²æ•æ„Ÿä¿¡æ¯
- ä¸è¦ä½¿ç”¨ä¸å®‰å…¨çš„tokenå­˜å‚¨æ–¹å¼
- ä¸è¦åœ¨åˆ·æ–°tokenå¤±è´¥æ—¶ä¸è¿›è¡Œç™»å‡ºå¤„ç†

## ğŸ”§ æœ€ä½³å®è·µ

1. **ç»Ÿä¸€è®¤è¯æ¥å£** - å‰åç«¯ä½¿ç”¨ç›¸åŒçš„ API ç«¯ç‚¹
2. **ç®€åŒ–æƒé™ç³»ç»Ÿ** - åŸºäº access å­—æ®µçš„ç®€å•æƒé™æ§åˆ¶
3. **è‡ªåŠ¨ token éªŒè¯** - å®šæœŸéªŒè¯ token æœ‰æ•ˆæ€§
4. **Tokenåˆ·æ–°æœºåˆ¶** - å®ç°æ— æ„ŸçŸ¥çš„tokenè‡ªåŠ¨åˆ·æ–°
5. **é”™è¯¯å¤„ç†** - æä¾›ç»Ÿä¸€çš„é”™è¯¯å¤„ç†å’Œç”¨æˆ·åé¦ˆ
6. **å®‰å…¨å­˜å‚¨** - ä½¿ç”¨å®‰å…¨çš„ token å­˜å‚¨æ–¹å¼
7. **æ€§èƒ½ä¼˜åŒ–** - ä½¿ç”¨ useMemo å’Œ useCallback ä¼˜åŒ–æ€§èƒ½
8. **æ´»åŠ¨æ—¥å¿—** - è®°å½•ç”¨æˆ·è®¤è¯å’Œtokenåˆ·æ–°æ´»åŠ¨
9. **ç½‘ç»œé‡è¯•** - å®ç°æ™ºèƒ½çš„ç½‘ç»œè¯·æ±‚é‡è¯•æœºåˆ¶
10. **ç”¨æˆ·ä½“éªŒ** - æä¾›æµç•…çš„è®¤è¯ä½“éªŒï¼Œå‡å°‘ç”¨æˆ·æ“ä½œ

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [è®¤è¯ç³»ç»Ÿæ¶æ„è¯´æ˜](mdc:Platform.App/AUTH-ARCHITECTURE.md)
- [è®¤è¯ç³»ç»Ÿç»Ÿä¸€æ€»ç»“](mdc:Platform.App/AUTH-SYNC-SUMMARY.md)
- [è®¤è¯ç³»ç»Ÿä½¿ç”¨æŒ‡å—](mdc:Platform.App/README-AUTH.md)
