---
globs: **/auth*.ts,**/auth*.tsx,**/Auth*.tsx,**/contexts/AuthContext.tsx,**/services/auth.ts,**/hooks/use-auth.ts
description: è®¤è¯ç³»ç»Ÿå¼€å‘è§„èŒƒå’Œæœ€ä½³å®è·µ
---

# è®¤è¯ç³»ç»Ÿå¼€å‘è§„èŒƒ

## ğŸ¯ ç³»ç»Ÿæ¶æ„

### ç»Ÿä¸€è®¤è¯æ¶æ„

é¡¹ç›®é‡‡ç”¨å‰åç«¯å®Œå…¨ç»Ÿä¸€çš„è®¤è¯ç³»ç»Ÿï¼š

- **JWT Token è®¤è¯** - åŸºäº JWT çš„ç®€å• token æœºåˆ¶
- **ç»Ÿä¸€ API æ¥å£** - å‰åç«¯ä½¿ç”¨ç›¸åŒçš„è®¤è¯ç«¯ç‚¹
- **åŸºäº access å­—æ®µçš„æƒé™ç³»ç»Ÿ** - ç®€åŒ–çš„æƒé™æ§åˆ¶
- **è‡ªåŠ¨ token éªŒè¯** - æ™ºèƒ½çš„ç½‘ç»œé‡è¯•æœºåˆ¶

### æ ¸å¿ƒç»„ä»¶

- **AuthContext** - å…¨å±€è®¤è¯çŠ¶æ€ç®¡ç†
- **AuthService** - è®¤è¯ API æœåŠ¡
- **AuthGuard** - æƒé™å®ˆå«ç»„ä»¶
- **RouteGuard** - è·¯ç”±å®ˆå«ç»„ä»¶
- **useAuth** - è®¤è¯çŠ¶æ€ Hook
- **usePermissions** - æƒé™æ£€æŸ¥ Hook

## ğŸ”§ è®¤è¯æœåŠ¡

### API æ¥å£è§„èŒƒ

```typescript
// âœ… æ¨èï¼šç»Ÿä¸€çš„è®¤è¯æ¥å£
interface AuthEndpoints {
  login: 'POST /api/auth/login';           // ç”¨æˆ·ç™»å½•
  logout: 'POST /api/auth/logout';         // ç”¨æˆ·ç™»å‡º
  currentUser: 'GET /api/auth/current-user'; // è·å–å½“å‰ç”¨æˆ·
  register: 'POST /api/auth/register';     // ç”¨æˆ·æ³¨å†Œ
  changePassword: 'POST /api/auth/change-password'; // ä¿®æ”¹å¯†ç 
  captcha: 'GET /api/auth/captcha';        // è·å–éªŒè¯ç 
  refreshToken: 'POST /api/auth/refresh-token'; // åˆ·æ–°ä»¤ç‰Œ
}
```

### è®¤è¯æœåŠ¡å®ç°

```typescript
// âœ… æ¨èï¼šè®¤è¯æœåŠ¡ç±»
export class AuthService {
  private static readonly BASE_URL = '/api/auth';
  
  static async login(credentials: LoginRequest): Promise<LoginResult> {
    try {
      const response = await apiClient.post(`${this.BASE_URL}/login`, credentials);
      const { token, refreshToken, expiresAt } = response.data;
      
      // å­˜å‚¨ token å’Œ refreshToken
      await AsyncStorage.setItem('auth_token', token);
      if (refreshToken) {
        await AsyncStorage.setItem('auth_refresh_token', refreshToken);
      }
      if (expiresAt) {
        await AsyncStorage.setItem('auth_token_expires', expiresAt.toString());
      }
      
      return response.data;
    } catch (error) {
      console.error('Login failed:', error);
      throw error;
    }
  }
  
  static async logout(): Promise<void> {
    try {
      // è°ƒç”¨åç«¯ç™»å‡ºæ¥å£
      await apiClient.post(`${this.BASE_URL}/logout`);
      
      // æ¸…é™¤æœ¬åœ°å­˜å‚¨
      await AsyncStorage.removeItem('auth_token');
      await AsyncStorage.removeItem('auth_refresh_token');
      await AsyncStorage.removeItem('auth_token_expires');
      await AsyncStorage.removeItem('user_info');
    } catch (error) {
      console.error('Logout failed:', error);
    }
  }
  
  static async getCurrentUser(): Promise<CurrentUser> {
    try {
      const response = await apiClient.get(`${this.BASE_URL}/current-user`);
      return response.data;
    } catch (error) {
      console.error('Failed to get current user:', error);
      throw error;
    }
  }
}
```

## ğŸ£ è®¤è¯ Hooks

### useAuth Hook

```typescript
// âœ… æ¨èï¼šè®¤è¯çŠ¶æ€ç®¡ç† Hook
export function useAuth() {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [user, setUser] = useState<CurrentUser | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    checkAuthStatus();
  }, []);
  
  const checkAuthStatus = async () => {
    try {
      const token = await AuthService.getStoredToken();
      
      if (token) {
        // éªŒè¯ token æœ‰æ•ˆæ€§
        const currentUser = await AuthService.getCurrentUser();
        setUser(currentUser);
        setIsAuthenticated(true);
      }
    } catch (error) {
      console.error('Auth check failed:', error);
      setError('è®¤è¯éªŒè¯å¤±è´¥');
      setIsAuthenticated(false);
    } finally {
      setLoading(false);
    }
  };
  
  const login = async (credentials: LoginRequest) => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await AuthService.login(credentials);
      
      // è·å–ç”¨æˆ·ä¿¡æ¯
      const currentUser = await AuthService.getCurrentUser();
      setUser(currentUser);
      setIsAuthenticated(true);
      
      return response;
    } catch (error) {
      setError(error instanceof Error ? error.message : 'ç™»å½•å¤±è´¥');
      throw error;
    } finally {
      setLoading(false);
    }
  };
  
  const logout = async () => {
    try {
      await AuthService.logout();
      setUser(null);
      setIsAuthenticated(false);
      setError(null);
    } catch (error) {
      console.error('Logout error:', error);
    }
  };
  
  return { isAuthenticated, user, loading, error, login, logout, checkAuthStatus };
}
```

### usePermissions Hook

```typescript
// âœ… æ¨èï¼šæƒé™æ£€æŸ¥ Hook
export function usePermissions() {
  const { user, isAuthenticated } = useAuth();
  
  const checkPermission = useCallback((check: PermissionCheck): boolean => {
    if (!isAuthenticated || !user) {
      return false;
    }
    
    const { access, role } = check;
    
    // æ£€æŸ¥è§’è‰²ï¼ˆå…¼å®¹æ€§ï¼‰
    if (role && user.access === role) {
      return true;
    }
    
    // æ£€æŸ¥æƒé™ï¼ˆåŸºäº access å­—æ®µï¼‰
    if (access && user.access === access) {
      return true;
    }
    
    return false;
  }, [user, isAuthenticated]);
  
  const checkRole = useCallback((role: string): boolean => {
    return checkPermission({ role });
  }, [checkPermission]);
  
  const checkAllRoles = useCallback((roles: string[]): boolean => {
    return roles.every(role => checkRole(role));
  }, [checkRole]);
  
  return {
    checkPermission,
    checkRole,
    checkAllRoles,
    user,
    isAuthenticated,
  };
}
```

## ğŸ›¡ï¸ æƒé™å®ˆå«

### AuthGuard ç»„ä»¶

```typescript
// âœ… æ¨èï¼šæƒé™å®ˆå«ç»„ä»¶
interface AuthGuardProps {
  readonly permission?: PermissionCheck;
  readonly fallback?: React.ReactNode;
  readonly children: React.ReactNode;
}

export function AuthGuard({ permission, fallback, children }: AuthGuardProps) {
  const { isAuthenticated, loading } = useAuth();
  const { checkPermission } = usePermissions();
  
  if (loading) {
    return <LoadingSpinner />;
  }
  
  if (!isAuthenticated) {
    return <Navigate to="/auth/login" replace />;
  }
  
  if (permission && !checkPermission(permission)) {
    return fallback || <AccessDenied />;
  }
  
  return <>{children}</>;
}
```

### RouteGuard ç»„ä»¶

```typescript
// âœ… æ¨èï¼šè·¯ç”±å®ˆå«ç»„ä»¶
export function RouteGuard({ children }: { children: React.ReactNode }) {
  const { isAuthenticated, loading } = useAuth();
  
  if (loading) {
    return <LoadingScreen />;
  }
  
  if (!isAuthenticated) {
    return <Navigate to="/auth/login" replace />;
  }
  
  return <>{children}</>;
}
```

## ğŸ“± ç§»åŠ¨ç«¯è®¤è¯

### è®¤è¯ä¸Šä¸‹æ–‡é›†æˆ

```typescript
// âœ… æ¨èï¼šç§»åŠ¨ç«¯è®¤è¯ä¸Šä¸‹æ–‡
export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = useReducer(authReducer, initialState);
  
  const value = useMemo(() => ({
    ...state,
    login: (credentials: LoginRequest) => dispatch({ type: 'LOGIN_START', payload: credentials }),
    logout: () => dispatch({ type: 'LOGOUT' }),
    checkAuth: () => dispatch({ type: 'CHECK_AUTH' }),
  }), [state]);
  
  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}
```

### è®¤è¯é”™è¯¯å¤„ç†

```typescript
// âœ… æ¨èï¼šè®¤è¯é”™è¯¯å¤„ç†ç»„ä»¶
export function AuthErrorHandler({ children }: { children: React.ReactNode }) {
  const { error, clearError } = useAuth();
  
  useEffect(() => {
    if (error) {
      Alert.alert('è®¤è¯é”™è¯¯', error, [
        { text: 'ç¡®å®š', onPress: clearError }
      ]);
    }
  }, [error, clearError]);
  
  return <>{children}</>;
}
```

## ğŸ”„ è®¤è¯æµç¨‹

### ç™»å½•æµç¨‹

```
ç”¨æˆ·è¾“å…¥ â†’ LoginRequest â†’ POST /api/auth/login â†’ 
LoginResult â†’ ä¿å­˜token â†’ è·å–ç”¨æˆ·ä¿¡æ¯ â†’ æ›´æ–°çŠ¶æ€
```

### æƒé™æ£€æŸ¥æµç¨‹

```
ç»„ä»¶ â†’ usePermissions â†’ æ£€æŸ¥user.access â†’ 
è¿”å›æƒé™ç»“æœ â†’ æ¸²æŸ“å†³ç­–
```

### TokenéªŒè¯æµç¨‹

```
å®šæœŸæ£€æŸ¥ â†’ validateToken() â†’ GET /api/auth/current-user â†’ 
éªŒè¯å“åº” â†’ æ›´æ–°ç”¨æˆ·çŠ¶æ€
```

## ğŸ”„ Token åˆ·æ–°æœºåˆ¶

### åˆ·æ–° Token æœºåˆ¶

é¡¹ç›®å·²å®ç°å®Œæ•´çš„ token åˆ·æ–°åŠŸèƒ½ï¼Œæå‡ç”¨æˆ·ä½“éªŒå’Œå®‰å…¨æ€§ã€‚å‰åç«¯ä½¿ç”¨ç»Ÿä¸€çš„åˆ·æ–°æµç¨‹ï¼š

#### åç«¯å®ç°

**é‡è¦ï¼šRefresh Token ç«¯ç‚¹å®‰å…¨è®¾è®¡**

Refresh Token ç«¯ç‚¹**å¿…é¡»**ä½¿ç”¨ `[AllowAnonymous]` ç‰¹æ€§ï¼Œè¿™æ˜¯ OAuth 2.0 å’Œ JWT refresh token çš„æ ‡å‡†åšæ³•ï¼š

```csharp
// âœ… æ­£ç¡®ï¼šRefresh Token ç«¯ç‚¹å…è®¸åŒ¿åè®¿é—®
// Platform.ApiService/Controllers/AuthController.cs

/// <summary>
/// åˆ·æ–°è®¿é—®ä»¤ç‰Œ
/// </summary>
/// <param name="request">åˆ·æ–°ä»¤ç‰Œè¯·æ±‚</param>
[HttpPost("refresh-token")]
[AllowAnonymous]  // âœ… å¿…é¡»ï¼šå…è®¸åŒ¿åè®¿é—®ï¼Œå› ä¸º access token å·²è¿‡æœŸ
public async Task<IActionResult> RefreshToken([FromBody] RefreshTokenRequest request)
{
    var result = await _authService.RefreshTokenAsync(request);
    return Ok(result);
}
```

**ä¸ºä»€ä¹ˆéœ€è¦ `[AllowAnonymous]`ï¼Ÿ**

1. **ç¬¦åˆ OAuth 2.0 æ ‡å‡†** - Refresh token ç«¯ç‚¹è®¾è®¡å°±æ˜¯å…è®¸åŒ¿åè®¿é—®
2. **å®é™…ä½¿ç”¨åœºæ™¯** - å½“ access token è¿‡æœŸæ—¶ï¼Œç”¨æˆ·æ— æ³•æä¾›æœ‰æ•ˆçš„ access token
3. **å®‰å…¨ä¸ä¾èµ–ç«¯ç‚¹æƒé™** - å®‰å…¨ä¾èµ–äº refresh token çš„éªŒè¯æœºåˆ¶ï¼Œè€Œéç«¯ç‚¹æƒé™

**åç«¯å®‰å…¨éªŒè¯æœºåˆ¶ï¼ˆå¤šå±‚é˜²æŠ¤ï¼‰**

è™½ç„¶ç«¯ç‚¹å…è®¸åŒ¿åè®¿é—®ï¼Œä½†åç«¯ä¼šè¿›è¡Œä¸¥æ ¼çš„å¤šå±‚éªŒè¯ï¼š

```csharp
// âœ… åç«¯è®¤è¯æœåŠ¡å®ç°
// Platform.ApiService/Services/AuthService.cs

public async Task<ApiResponse<RefreshTokenResult>> RefreshTokenAsync(RefreshTokenRequest request)
{
    // 1. âœ… JWT ç­¾åéªŒè¯ï¼ˆä½¿ç”¨ç‹¬ç«‹çš„ refresh token å¯†é’¥ï¼‰
    var principal = _jwtService.ValidateRefreshToken(request.RefreshToken);
    if (principal == null)
    {
        return ApiResponse<RefreshTokenResult>.ErrorResult(
            "REFRESH_TOKEN_INVALID",
            "æ— æ•ˆçš„åˆ·æ–°token"
        );
    }

    // 2. âœ… Token ç±»å‹éªŒè¯ï¼ˆå¿…é¡»æ˜¯ "refresh"ï¼‰
    // åœ¨ ValidateRefreshToken ä¸­å·²éªŒè¯

    // 3. âœ… ä»åˆ·æ–° token ä¸­è·å–ç”¨æˆ·ID
    var userId = _jwtService.GetUserIdFromRefreshToken(request.RefreshToken);
    if (string.IsNullOrEmpty(userId))
    {
        return ApiResponse<RefreshTokenResult>.ErrorResult(
            "REFRESH_TOKEN_USER_NOT_FOUND",
            "æ— æ³•ä»åˆ·æ–°tokenä¸­è·å–ç”¨æˆ·ä¿¡æ¯"
        );
    }

    // 4. âœ… æ•°æ®åº“éªŒè¯ï¼ˆæ£€æŸ¥ token æ˜¯å¦å­˜åœ¨ã€æ˜¯å¦è¢«æ’¤é”€ï¼‰
    var refreshTokenFilter = _refreshTokenFactory.CreateFilterBuilder()
        .Equal(rt => rt.Token, request.RefreshToken)
        .Equal(rt => rt.UserId, userId)
        .Equal(rt => rt.IsRevoked, false)
        .Build();

    var existingToken = await _refreshTokenFactory.FindWithoutTenantFilterAsync(refreshTokenFilter)
        .FirstOrDefaultAsync();

    if (existingToken == null)
    {
        // âœ… æ£€æµ‹æ—§ token é‡ç”¨æ”»å‡»ï¼ˆå®‰å…¨æªæ–½ï¼‰
        var userTokens = await _refreshTokenFactory.FindWithoutTenantFilterAsync(
            _refreshTokenFactory.CreateFilterBuilder()
                .Equal(rt => rt.UserId, userId)
                .Equal(rt => rt.IsRevoked, false)
                .Build()
        );

        if (userTokens.Any())
        {
            // æ£€æµ‹åˆ°æ—§ token é‡ç”¨ï¼Œæ’¤é”€è¯¥ç”¨æˆ·æ‰€æœ‰ token
            await _refreshTokenFactory.UpdateManyAsync(
                _refreshTokenFactory.CreateFilterBuilder().Equal(rt => rt.UserId, userId).Build(),
                _refreshTokenFactory.CreateUpdateBuilder()
                    .Set(rt => rt.IsRevoked, true)
                    .Set(rt => rt.RevokedAt, DateTime.UtcNow)
                    .Set(rt => rt.RevokedReason, "æ£€æµ‹åˆ°æ—§tokené‡ç”¨æ”»å‡»")
                    .Build()
            );
        }

        return ApiResponse<RefreshTokenResult>.ErrorResult(
            "REFRESH_TOKEN_REVOKED",
            "åˆ·æ–°tokenæ— æ•ˆæˆ–å·²è¢«æ’¤é”€"
        );
    }

    // 5. âœ… è¿‡æœŸæ—¶é—´éªŒè¯
    if (existingToken.ExpiresAt < DateTime.UtcNow)
    {
        return ApiResponse<RefreshTokenResult>.ErrorResult(
            "REFRESH_TOKEN_EXPIRED",
            "åˆ·æ–°tokenå·²è¿‡æœŸ"
        );
    }

    // 6. âœ… ç”¨æˆ·çŠ¶æ€éªŒè¯ï¼ˆæ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨ã€æ˜¯å¦æ¿€æ´»ï¼‰
    var user = await _userFactory.GetByIdAsync(userId);
    if (user == null || !user.IsActive)
    {
        return ApiResponse<RefreshTokenResult>.ErrorResult(
            "USER_NOT_FOUND",
            "ç”¨æˆ·ä¸å­˜åœ¨æˆ–å·²è¢«ç¦ç”¨"
        );
    }

    // 7. âœ… ç”Ÿæˆæ–°çš„è®¿é—® token å’Œåˆ·æ–° token
    var newToken = _jwtService.GenerateToken(user);
    var newRefreshToken = _jwtService.GenerateRefreshToken(user);

    // 8. âœ… Token è½®æ¢ï¼ˆæ’¤é”€æ—§ tokenï¼Œä¿å­˜æ–° tokenï¼‰
    await _refreshTokenFactory.FindOneAndUpdateAsync(
        refreshTokenFilter,
        _refreshTokenFactory.CreateUpdateBuilder()
            .Set(rt => rt.IsRevoked, true)
            .Set(rt => rt.RevokedAt, DateTime.UtcNow)
            .Set(rt => rt.RevokedReason, "Tokenè½®æ¢")
            .Build()
    );

    // ä¿å­˜æ–° token åˆ°æ•°æ®åº“
    await _refreshTokenFactory.CreateAsync(new RefreshToken
    {
        UserId = userId,
        Token = newRefreshToken,
        PreviousToken = existingToken.Token,
        ExpiresAt = DateTime.UtcNow.AddDays(refreshTokenExpirationDays),
        IsRevoked = false
    });

    // 9. âœ… è¿”å›æ–°çš„ token ä¿¡æ¯ï¼ˆä½¿ç”¨ ApiResponse åŒ…è£…ï¼‰
    return ApiResponse<RefreshTokenResult>.SuccessResult(new RefreshTokenResult
    {
        Status = "ok",
        Token = newToken,
        RefreshToken = newRefreshToken,
        ExpiresAt = DateTime.UtcNow.AddMinutes(expirationMinutes)
    });
}
```

**åç«¯ JWT æœåŠ¡å®ç°**

```csharp
// âœ… åç«¯ JWT æœåŠ¡å®ç°
// Platform.ApiService/Services/JwtService.cs

public class JwtService : IJwtService
{
    private readonly string _secretKey;
    private readonly string _refreshTokenSecret;  // âœ… ç‹¬ç«‹çš„ refresh token å¯†é’¥
    private readonly string _issuer;
    private readonly string _audience;
    private readonly int _expirationMinutes;
    private readonly int _refreshTokenExpirationDays;

    public JwtService(IConfiguration configuration)
    {
        _secretKey = configuration["Jwt:SecretKey"] 
            ?? throw new InvalidOperationException("JWT SecretKey must be configured");
        
        // âœ… ä½¿ç”¨ç‹¬ç«‹çš„ Refresh Token å¯†é’¥ï¼ˆå®‰å…¨æœ€ä½³å®è·µï¼‰
        _refreshTokenSecret = configuration["Jwt:RefreshTokenSecret"] ?? _secretKey;
        
        _issuer = configuration["Jwt:Issuer"] ?? "Platform.ApiService";
        _audience = configuration["Jwt:Audience"] ?? "Platform.Web";
        _expirationMinutes = int.Parse(configuration["Jwt:ExpirationMinutes"] ?? "1440");
        _refreshTokenExpirationDays = int.Parse(configuration["Jwt:RefreshTokenExpirationDays"] ?? "7");
    }

    // ç”Ÿæˆè®¿é—® Token
    public string GenerateToken(AppUser user)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.ASCII.GetBytes(_secretKey);

        var claims = new List<Claim>
        {
            new("userId", user.Id ?? string.Empty),
            new("username", user.Username),
            // âš ï¸ ä¸å†åœ¨ JWT token ä¸­åŒ…å« CurrentCompanyId
            // æ‰€æœ‰ä¼ä¸šIDç›¸å…³çš„é€»è¾‘åº”ä»æ•°æ®åº“çš„ user.CurrentCompanyId è·å–
        };

        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(claims),
            Expires = DateTime.UtcNow.AddMinutes(_expirationMinutes),
            Issuer = _issuer,
            Audience = _audience,
            SigningCredentials = new SigningCredentials(
                new SymmetricSecurityKey(key), 
                SecurityAlgorithms.HmacSha256Signature)
        };

        return tokenHandler.CreateToken(tokenDescriptor).WriteToken(tokenHandler);
    }

    // ç”Ÿæˆåˆ·æ–° Tokenï¼ˆä½¿ç”¨ç‹¬ç«‹çš„å¯†é’¥ï¼‰
    public string GenerateRefreshToken(AppUser user)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.ASCII.GetBytes(_refreshTokenSecret);  // âœ… ä½¿ç”¨ç‹¬ç«‹å¯†é’¥

        var claims = new List<Claim>
        {
            new("type", "refresh"),  // âœ… æ ‡è®°ä¸ºåˆ·æ–° token
            new("userId", user.Id ?? string.Empty),
            new("username", user.Username),
            // âš ï¸ ä¸å†åœ¨ RefreshToken ä¸­åŒ…å« companyId
            new("iat", DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString(), ClaimValueTypes.Integer64)
        };

        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(claims),
            Expires = DateTime.UtcNow.AddDays(_refreshTokenExpirationDays),
            Issuer = _issuer,
            Audience = _audience,
            SigningCredentials = new SigningCredentials(
                new SymmetricSecurityKey(key), 
                SecurityAlgorithms.HmacSha256Signature)
        };

        return tokenHandler.CreateToken(tokenDescriptor).WriteToken(tokenHandler);
    }

    // éªŒè¯åˆ·æ–° Tokenï¼ˆä½¿ç”¨ç‹¬ç«‹çš„å¯†é’¥ï¼‰
    public ClaimsPrincipal? ValidateRefreshToken(string refreshToken)
    {
        try
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var key = Encoding.ASCII.GetBytes(_refreshTokenSecret);  // âœ… ä½¿ç”¨ç‹¬ç«‹å¯†é’¥
            
            var validationParameters = new TokenValidationParameters
            {
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = new SymmetricSecurityKey(key),
                ValidateIssuer = true,
                ValidIssuer = _issuer,
                ValidateAudience = true,
                ValidAudience = _audience,
                ValidateLifetime = true,
                ClockSkew = TimeSpan.Zero
            };

            var principal = tokenHandler.ValidateToken(refreshToken, validationParameters, out _);
            
            // âœ… éªŒè¯ token ç±»å‹ä¸º "refresh"
            var tokenType = principal.FindFirst("type")?.Value;
            if (tokenType != "refresh")
            {
                return null;
            }
            
            return principal;
        }
        catch
        {
            return null;
        }
    }
}
```

#### å‰ç«¯ Token åˆ·æ–°ç®¡ç†å™¨ï¼ˆé˜²æ­¢å¹¶å‘åˆ·æ–°ï¼‰

```typescript
// âœ… ç®¡ç†åå° Token åˆ·æ–°ç®¡ç†å™¨å®ç°
// Platform.Admin/src/utils/tokenRefreshManager.ts

interface TokenRefreshResult {
  success: boolean;
  token?: string;
  refreshToken?: string;
  expiresAt?: number;
}

class TokenRefreshManager {
  private static refreshPromise: Promise<TokenRefreshResult | null> | null = null;

  /**
   * åˆ·æ–° token
   * å¦‚æœå·²ç»æœ‰åˆ·æ–°è¯·æ±‚åœ¨è¿›è¡Œï¼Œç­‰å¾…å…¶å®Œæˆå¹¶è¿”å›ç›¸åŒçš„ç»“æœ
   */
  static async refresh(refreshToken: string): Promise<TokenRefreshResult | null> {
    // å¦‚æœå·²ç»æœ‰åˆ·æ–°è¯·æ±‚åœ¨è¿›è¡Œï¼Œç­‰å¾…å…¶å®Œæˆ
    if (this.refreshPromise) {
      return this.refreshPromise;
    }

    // åˆ›å»ºæ–°çš„åˆ·æ–°è¯·æ±‚
    this.refreshPromise = this.doRefresh(refreshToken);

    try {
      const result = await this.refreshPromise;
      return result;
    } finally {
      // æ¸…é™¤åˆ·æ–° Promiseï¼Œå…è®¸ä¸‹æ¬¡åˆ·æ–°
      this.refreshPromise = null;
    }
  }

  /**
   * æ‰§è¡Œå®é™…çš„ token åˆ·æ–°é€»è¾‘
   */
  private static async doRefresh(refreshToken: string): Promise<TokenRefreshResult | null> {
    try {
      const { refreshToken: refreshTokenAPI } = await import('@/services/ant-design-pro/api');
      const refreshResponse = await refreshTokenAPI({ refreshToken });

      // æ£€æŸ¥ API å“åº”æ˜¯å¦æˆåŠŸ
      if (!refreshResponse.success || !refreshResponse.data) {
        return { success: false };
      }

      const refreshResult = refreshResponse.data;
      
      // âœ… æ­£ç¡®ï¼šæ£€æŸ¥åç«¯è¿”å›çš„ Status å±æ€§ï¼ˆä¸æ˜¯ successï¼‰
      const hasValidTokens =
        refreshResult.status === 'ok' &&
        refreshResult.token &&
        refreshResult.refreshToken;

      if (hasValidTokens) {
        const expiresAt = refreshResult.expiresAt
          ? new Date(refreshResult.expiresAt).getTime()
          : undefined;

        // ä¿å­˜æ–°çš„ token
        tokenUtils.setTokens(
          refreshResult.token,
          refreshResult.refreshToken,
          expiresAt
        );

        return {
          success: true,
          token: refreshResult.token,
          refreshToken: refreshResult.refreshToken,
          expiresAt,
        };
      }

      return { success: false };
    } catch (error) {
      console.error('Token refresh failed:', error);
      return { success: false };
    }
  }

  /**
   * ä½¿ç”¨æ–°çš„ token é‡è¯•åŸå§‹è¯·æ±‚
   */
  static retryRequest(originalRequest: any, newToken: string): Promise<any> {
    originalRequest._retry = true;
    originalRequest.headers = {
      ...originalRequest.headers,
      Authorization: `Bearer ${newToken}`,
    };
    return requestClient(originalRequest);
  }
}
```

#### å‰ç«¯è‡ªåŠ¨åˆ·æ–°æµç¨‹

```typescript
// âœ… ç®¡ç†åå°å“åº”æ‹¦æˆªå™¨ä¸­çš„ token åˆ·æ–°
// Platform.Admin/src/app.tsx

async function handle401Error(error: any): Promise<any> {
  const is401Error = error.response?.status === 401;
  if (!is401Error) return null;

  const isRefreshTokenRequest = error.config?.url?.includes('/refresh-token');
  const isRetryRequest = error.config?._retry;

  // é¿å…åˆ·æ–° token é€’å½’å’Œé‡è¯•å¾ªç¯
  if (isRefreshTokenRequest || isRetryRequest) {
    return null;
  }

  // å°è¯•åˆ·æ–° token
  const refreshToken = tokenUtils.getRefreshToken();
  if (!refreshToken) {
    return null;
  }

  // ä½¿ç”¨ TokenRefreshManager åˆ·æ–° tokenï¼ˆé˜²æ­¢å¹¶å‘åˆ·æ–°ï¼‰
  const refreshResult = await TokenRefreshManager.refresh(refreshToken);

  if (refreshResult?.success && refreshResult.token) {
    // token åˆ·æ–°æˆåŠŸï¼Œé‡è¯•åŸå§‹è¯·æ±‚
    return TokenRefreshManager.retryRequest(error.config, refreshResult.token);
  }

  // token åˆ·æ–°å¤±è´¥ï¼Œäº¤ç»™ errorHandler ç»Ÿä¸€å¤„ç†
  return null;
}
```

#### ç§»åŠ¨ç«¯ Token åˆ·æ–°

```typescript
// âœ… ç§»åŠ¨ç«¯ Token åˆ·æ–°å®ç°
// Platform.App/services/authService.ts

async refreshToken(): Promise<ApiResponse<LoginResponse>> {
  const refreshToken = await storage.get<string>(STORAGE_KEYS.REFRESH_TOKEN);
  
  if (!refreshToken) {
    throw new Error('No refresh token available');
  }

  const response = await apiClient.post<any, ApiResponse<LoginResponse>>(
    '/api/auth/refresh-token',
    { refreshToken } as RefreshTokenRequest
  );

  // æ›´æ–°å­˜å‚¨çš„ token
  if (response.success && response.data) {
    await setToken(response.data.token);
    await storage.set(STORAGE_KEYS.REFRESH_TOKEN, response.data.refreshToken);
  }

  return response;
}
```

#### åç«¯å®ç°

```csharp
// âœ… æ¨èï¼šJWTæœåŠ¡ä¸­çš„åˆ·æ–°tokenæ–¹æ³•
public string GenerateRefreshToken(AppUser user)
{
    var claims = new[]
    {
        new Claim(ClaimTypes.NameIdentifier, user.Id),
        new Claim(ClaimTypes.Name, user.Username),
        new Claim(ClaimTypes.Role, user.Access),
        new Claim("token_type", "refresh")
    };

    var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_refreshTokenSecret));
    var credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

    var token = new JwtSecurityToken(
        issuer: _issuer,
        audience: _audience,
        claims: claims,
        expires: DateTime.UtcNow.AddDays(_refreshTokenExpirationDays),
        signingCredentials: credentials
    );

    return new JwtSecurityTokenHandler().WriteToken(token);
}

// âœ… æ¨èï¼šè®¤è¯æœåŠ¡ä¸­çš„åˆ·æ–°tokenæ–¹æ³•
public async Task<RefreshTokenResult> RefreshTokenAsync(RefreshTokenRequest request)
{
    // éªŒè¯åˆ·æ–°token
    var principal = _jwtService.ValidateRefreshToken(request.RefreshToken);
    if (principal == null)
    {
        return new RefreshTokenResult
        {
            Status = "error",
            ErrorMessage = "æ— æ•ˆçš„åˆ·æ–°token"
        };
    }

    // è·å–ç”¨æˆ·ä¿¡æ¯å¹¶ç”Ÿæˆæ–°token
    var userId = _jwtService.GetUserIdFromRefreshToken(request.RefreshToken);
    var user = await _users.Find(u => u.Id == userId && u.IsActive).FirstOrDefaultAsync();
    
    if (user == null)
    {
        return new RefreshTokenResult
        {
            Status = "error",
            ErrorMessage = "ç”¨æˆ·ä¸å­˜åœ¨æˆ–å·²è¢«ç¦ç”¨"
        };
    }

    // ç”Ÿæˆæ–°çš„è®¿é—®tokenå’Œåˆ·æ–°token
    var newToken = _jwtService.GenerateToken(user);
    var newRefreshToken = _jwtService.GenerateRefreshToken(user);

    return new RefreshTokenResult
    {
        Status = "ok",
        Token = newToken,
        RefreshToken = newRefreshToken,
        ExpiresAt = DateTime.UtcNow.AddMinutes(60)
    };
}
```

### Token å­˜å‚¨å’Œç®¡ç†

#### ç®¡ç†åå° Token å·¥å…·

```typescript
// âœ… ç®¡ç†åå° Token å·¥å…·å®ç°
// Platform.Admin/src/utils/token.ts

export const tokenUtils = {
  // ä¿å­˜ token
  setToken: (token: string) => {
    localStorage.setItem(TOKEN_KEY, token);
  },

  // è·å– token
  getToken: (): string | null => {
    return localStorage.getItem(TOKEN_KEY);
  },

  // è®¾ç½®æ‰€æœ‰ token ä¿¡æ¯
  setTokens: (token: string, refreshToken: string, expiresAt?: number) => {
    localStorage.setItem(TOKEN_KEY, token);
    localStorage.setItem(REFRESH_TOKEN_KEY, refreshToken);
    if (expiresAt) {
      localStorage.setItem(TOKEN_EXPIRES_KEY, expiresAt.toString());
    }
  },

  // æ¸…é™¤æ‰€æœ‰ token
  clearAllTokens: () => {
    localStorage.removeItem(TOKEN_KEY);
    localStorage.removeItem(REFRESH_TOKEN_KEY);
    localStorage.removeItem(TOKEN_EXPIRES_KEY);
  },

  // æ£€æŸ¥ token æ˜¯å¦è¿‡æœŸï¼ˆå¸¦ç¼“å†²æ—¶é—´ï¼‰
  isTokenExpired: (): boolean => {
    const expiresAt = tokenUtils.getTokenExpiresAt();
    if (!expiresAt) {
      return false;
    }
    // æå‰ 5 åˆ†é’Ÿè®¤ä¸º token è¿‡æœŸï¼Œä»¥ä¾¿æœ‰æ—¶é—´åˆ·æ–°
    return Date.now() >= expiresAt - TOKEN_EXPIRY_BUFFER;
  },
};
```

#### ç§»åŠ¨ç«¯ Token ç¼“å­˜æœºåˆ¶

```typescript
// âœ… ç§»åŠ¨ç«¯ Token ç¼“å­˜å®ç°ï¼ˆé¿å… AsyncStorage æ—¶åºé—®é¢˜ï¼‰
// Platform.App/services/api.ts

let tokenCache: string | null = null;

export const setToken = async (token: string): Promise<void> => {
  tokenCache = token;  // å…ˆæ›´æ–°å†…å­˜ç¼“å­˜
  await storage.set(STORAGE_KEYS.ACCESS_TOKEN, token);  // å†æ›´æ–°æŒä¹…åŒ–å­˜å‚¨
};

export const getToken = async (): Promise<string | null> => {
  if (tokenCache) {
    return tokenCache;  // ä¼˜å…ˆä»å†…å­˜ç¼“å­˜è¯»å–
  }
  const token = await storage.get<string>(STORAGE_KEYS.ACCESS_TOKEN);
  if (token) {
    tokenCache = token;  // ä»å­˜å‚¨è¯»å–åæ›´æ–°ç¼“å­˜
  }
  return token;
};
```

### åˆ·æ–°Tokené…ç½®
```json
// âœ… æ¨èï¼šåç«¯é…ç½®
{
  "JwtSettings": {
    "SecretKey": "your-secret-key",
    "Issuer": "Platform.ApiService",
    "Audience": "Platform.Users",
    "ExpirationMinutes": 60,
    "RefreshTokenSecret": "your-refresh-secret-key",
    "RefreshTokenExpirationDays": 7
  }
}
```

### åˆ·æ–°Tokenæœ€ä½³å®è·µ

1. **ç«¯ç‚¹æƒé™** - Refresh Token ç«¯ç‚¹**å¿…é¡»**ä½¿ç”¨ `[AllowAnonymous]` ç‰¹æ€§
2. **å¤šå±‚å®‰å…¨éªŒè¯** - åç«¯å¿…é¡»è¿›è¡Œ JWT ç­¾åã€æ•°æ®åº“ã€ç”¨æˆ·çŠ¶æ€ç­‰å¤šå±‚éªŒè¯
3. **ç‹¬ç«‹å¯†é’¥** - Refresh Token ä½¿ç”¨ç‹¬ç«‹çš„å¯†é’¥ï¼ˆ`Jwt:RefreshTokenSecret`ï¼‰
4. **Token è½®æ¢** - æ¯æ¬¡åˆ·æ–°æ—¶æ’¤é”€æ—§ tokenï¼Œç”Ÿæˆæ–° tokenï¼ˆé˜²æ­¢ token é‡ç”¨æ”»å‡»ï¼‰
5. **è‡ªåŠ¨åˆ·æ–°æœºåˆ¶** - åœ¨ token å³å°†è¿‡æœŸæ—¶è‡ªåŠ¨åˆ·æ–°
6. **å¤±è´¥å¤„ç†** - åˆ·æ–°å¤±è´¥æ—¶è‡ªåŠ¨ç™»å‡ºç”¨æˆ·
7. **å®‰å…¨å­˜å‚¨** - åˆ†åˆ«å­˜å‚¨è®¿é—® token å’Œåˆ·æ–° token
8. **æ´»åŠ¨æ—¥å¿—** - è®°å½• token åˆ·æ–°æ´»åŠ¨
9. **é”™è¯¯é‡è¯•** - ç½‘ç»œè¯·æ±‚å¤±è´¥æ—¶è‡ªåŠ¨é‡è¯•
10. **ç”¨æˆ·ä½“éªŒ** - æ— æ„ŸçŸ¥çš„ token åˆ·æ–°
11. **å“åº”æ ¼å¼** - ä½¿ç”¨ `ApiResponse<RefreshTokenResult>` ç»Ÿä¸€å“åº”æ ¼å¼

## ğŸš« é¿å…çš„åšæ³•

- âŒ **ä¸è¦**åœ¨ Refresh Token ç«¯ç‚¹ä½¿ç”¨ `[Authorize]` - å¿…é¡»ä½¿ç”¨ `[AllowAnonymous]`
- âŒ **ä¸è¦**å¿½ç•¥ token è¿‡æœŸå¤„ç†ï¼Œå®ç°è‡ªåŠ¨åˆ·æ–°æœºåˆ¶
- âŒ **ä¸è¦**ç¡¬ç¼–ç æƒé™é€»è¾‘ï¼Œä½¿ç”¨ç»Ÿä¸€çš„æƒé™ç³»ç»Ÿ
- âŒ **ä¸è¦**å¿˜è®°å¤„ç†è®¤è¯é”™è¯¯ï¼Œæä¾›ç”¨æˆ·å‹å¥½çš„é”™è¯¯æç¤º
- âŒ **ä¸è¦**åœ¨ç”Ÿäº§ç¯å¢ƒä¸­æš´éœ²æ•æ„Ÿä¿¡æ¯
- âŒ **ä¸è¦**ä½¿ç”¨ä¸å®‰å…¨çš„ token å­˜å‚¨æ–¹å¼
- âŒ **ä¸è¦**åœ¨åˆ·æ–° token å¤±è´¥æ—¶ä¸è¿›è¡Œç™»å‡ºå¤„ç†
- âŒ **ä¸è¦**ç›´æ¥è¿”å› `RefreshTokenResult` - å¿…é¡»ä½¿ç”¨ `ApiResponse<RefreshTokenResult>` åŒ…è£…
- âŒ **ä¸è¦**ä½¿ç”¨ç›¸åŒçš„å¯†é’¥ç”Ÿæˆ access token å’Œ refresh token - ä½¿ç”¨ç‹¬ç«‹å¯†é’¥
- âŒ **ä¸è¦**å…è®¸æ—§ token é‡ç”¨ - å¿…é¡»å®ç° token è½®æ¢æœºåˆ¶

## ğŸ”§ æœ€ä½³å®è·µ

1. **ç»Ÿä¸€è®¤è¯æ¥å£** - å‰åç«¯ä½¿ç”¨ç›¸åŒçš„ API ç«¯ç‚¹
2. **ç®€åŒ–æƒé™ç³»ç»Ÿ** - åŸºäº access å­—æ®µçš„ç®€å•æƒé™æ§åˆ¶
3. **è‡ªåŠ¨ token éªŒè¯** - å®šæœŸéªŒè¯ token æœ‰æ•ˆæ€§
4. **Tokenåˆ·æ–°æœºåˆ¶** - å®ç°æ— æ„ŸçŸ¥çš„tokenè‡ªåŠ¨åˆ·æ–°
5. **é”™è¯¯å¤„ç†** - æä¾›ç»Ÿä¸€çš„é”™è¯¯å¤„ç†å’Œç”¨æˆ·åé¦ˆ
6. **å®‰å…¨å­˜å‚¨** - ä½¿ç”¨å®‰å…¨çš„ token å­˜å‚¨æ–¹å¼
7. **æ€§èƒ½ä¼˜åŒ–** - ä½¿ç”¨ useMemo å’Œ useCallback ä¼˜åŒ–æ€§èƒ½
8. **æ´»åŠ¨æ—¥å¿—** - è®°å½•ç”¨æˆ·è®¤è¯å’Œtokenåˆ·æ–°æ´»åŠ¨
9. **ç½‘ç»œé‡è¯•** - å®ç°æ™ºèƒ½çš„ç½‘ç»œè¯·æ±‚é‡è¯•æœºåˆ¶
10. **ç”¨æˆ·ä½“éªŒ** - æä¾›æµç•…çš„è®¤è¯ä½“éªŒï¼Œå‡å°‘ç”¨æˆ·æ“ä½œ

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [è®¤è¯ç³»ç»Ÿæ¶æ„è¯´æ˜](mdc:Platform.App/AUTH-ARCHITECTURE.md)
- [è®¤è¯ç³»ç»Ÿç»Ÿä¸€æ€»ç»“](mdc:Platform.App/AUTH-SYNC-SUMMARY.md)
- [è®¤è¯ç³»ç»Ÿä½¿ç”¨æŒ‡å—](mdc:Platform.App/README-AUTH.md)

