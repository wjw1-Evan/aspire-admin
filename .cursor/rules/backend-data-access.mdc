---
alwaysApply: true
description: 后端数据访问层规范 - 数据库操作工厂使用规范
globs: Platform.ApiService/Services/*.cs,Platform.ApiService/Models/*.cs,Platform.ServiceDefaults/**/*.cs
---

# 后端数据访问层规范

## 🎯 核心原则

**所有服务必须使用 `IDatabaseOperationFactory<T>` 进行数据访问，禁止直接使用 `IMongoCollection<T>` 或 `BaseRepository<T>`**

## 📋 概述

基于 MongoDB 和数据库操作工厂模式，提供统一的数据访问层规范和最佳实践。所有数据库操作必须使用 `IDatabaseOperationFactory<T>`，禁止直接使用 `IMongoCollection<T>` 或已移除的 `BaseRepository<T>`。

## 🏗️ 数据访问架构

### 数据库操作工厂模式

```csharp
// ✅ 数据库操作工厂接口
public interface IDatabaseOperationFactory<T> where T : class, IEntity, ISoftDeletable, ITimestamped
{
    // CRUD 操作
    Task<T> CreateAsync(T entity, OperationContext? context = null);
    Task<List<T>> CreateManyAsync(List<T> entities, OperationContext? context = null);
    Task<bool> UpdateAsync(T entity, OperationContext? context = null);
    Task<long> UpdateManyAsync(FilterDefinition<T> filter, UpdateDefinition<T> update, OperationContext? context = null);
    Task<bool> SoftDeleteAsync(string id, OperationContext? context = null);
    Task<long> SoftDeleteManyAsync(List<string> ids, OperationContext? context = null);
    Task<bool> HardDeleteAsync(string id, OperationContext? context = null);
    
    // 查询操作
    Task<List<T>> FindAsync(FilterDefinition<T>? filter = null, SortDefinition<T>? sort = null, int? limit = null);
    Task<(List<T> items, long total)> FindPagedAsync(FilterDefinition<T>? filter = null, SortDefinition<T>? sort = null, int page = 1, int pageSize = 20);
    Task<T?> GetByIdAsync(string id);
    Task<long> CountAsync(FilterDefinition<T>? filter = null);
    Task<bool> ExistsAsync(string id);
    
    // 跨租户查询
    Task<List<T>> FindWithoutTenantFilterAsync(FilterDefinition<T>? filter = null, SortDefinition<T>? sort = null, int? limit = null);
    Task<T?> GetByIdWithoutTenantFilterAsync(string id);
    
    // 构建器
    FilterBuilder<T> CreateFilterBuilder();
    SortBuilder<T> CreateSortBuilder();
    UpdateBuilder<T> CreateUpdateBuilder();
    OperationContextBuilder CreateOperationContext();
}
```

### 服务层实现

```csharp
// ✅ 服务层实现
public interface IUserService
{
    Task<User?> GetUserByIdAsync(string id);
    Task<List<User>> GetUsersAsync(UserListRequest request);
    Task<User> CreateUserAsync(CreateUserRequest request);
    Task<bool> UpdateUserAsync(string id, UpdateUserRequest request);
    Task<bool> DeleteUserAsync(string id);
    Task<bool> ExistsAsync(string id);
}

public class UserService : BaseService, IUserService
{
    private readonly IDatabaseOperationFactory<User> _userFactory;
    private readonly IPasswordHasher _passwordHasher;

    public UserService(
        IMongoDatabase database,
        IDatabaseOperationFactory<User> userFactory,
        IPasswordHasher passwordHasher,
        IHttpContextAccessor httpContextAccessor,
        ITenantContext tenantContext,
        ILogger<UserService> logger) 
        : base(database, httpContextAccessor, tenantContext, logger)
    {
        _userFactory = userFactory;
        _passwordHasher = passwordHasher;
    }

    public async Task<User?> GetUserByIdAsync(string id)
    {
        id.EnsureNotEmpty(nameof(id));
        
        _logger.LogInformation("Getting user {UserId}", id);
        
        try
        {
            var user = await _userFactory.GetByIdAsync(id);
            if (user == null)
            {
                _logger.LogWarning("User {UserId} not found", id);
            }
            
            return user;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get user {UserId}", id);
            throw;
        }
    }

    public async Task<User> CreateUserAsync(CreateUserRequest request)
    {
        request.EnsureNotNull(nameof(request));
        request.Username.EnsureValidUsername();
        request.Email.EnsureValidEmail();
        request.Password.EnsureValidPassword();

        _logger.LogInformation("Creating user with email {Email}", request.Email);

        // 检查用户是否已存在
        var existingUser = await _userFactory.FindAsync(
            _userFactory.CreateFilterBuilder()
                .Equal(u => u.Email, request.Email)
                .Build()
        );
        
        if (existingUser.Any())
        {
            throw new InvalidOperationException(ErrorMessages.UserAlreadyExists);
        }

        var user = new User
        {
            Username = request.Username,
            Email = request.Email,
            PasswordHash = _passwordHasher.HashPassword(request.Password),
            CompanyId = GetRequiredCompanyId(),
            IsActive = true
        };

        var createdUser = await _userFactory.CreateAsync(user);
        
        _logger.LogInformation("Successfully created user {UserId}", createdUser.Id);
        return createdUser;
    }
}
```

### 2. 查询优化

```csharp
// ✅ 查询优化
public async Task<List<User>> GetUsersAsync(UserListRequest request)
{
    var filterBuilder = _userFactory.CreateFilterBuilder();

    // 添加搜索条件
    if (!string.IsNullOrEmpty(request.Keyword))
    {
        filterBuilder.Regex(u => u.Username, request.Keyword)
                    .Regex(u => u.Email, request.Keyword);
    }

    // 添加角色过滤
    if (request.RoleIds?.Any() == true)
    {
        filterBuilder.In(u => u.RoleIds, request.RoleIds);
    }

    // 添加状态过滤
    if (request.IsActive.HasValue)
    {
        filterBuilder.Equal(u => u.IsActive, request.IsActive.Value);
    }

    var filter = filterBuilder.Build();
    var sort = _userFactory.CreateSortBuilder()
        .Descending(u => u.CreatedAt)
        .Build();
    
    return await _userFactory.FindAsync(filter, sort);
}

public async Task<(List<User> users, long total)> GetUsersPagedAsync(UserListRequest request)
{
    var filterBuilder = _userFactory.CreateFilterBuilder();

    // 应用相同的过滤条件
    if (!string.IsNullOrEmpty(request.Keyword))
    {
        filterBuilder.Regex(u => u.Username, request.Keyword)
                    .Regex(u => u.Email, request.Keyword);
    }

    var filter = filterBuilder.Build();
    var sort = _userFactory.CreateSortBuilder()
        .Descending(u => u.CreatedAt)
        .Build();
    
    return await _userFactory.FindPagedAsync(filter, sort, request.Page, request.PageSize);
}
```

### 3. 批量操作

```csharp
// ✅ 批量操作
public async Task<List<User>> CreateUsersAsync(List<CreateUserRequest> requests)
{
    var users = requests.Select(request => new User
    {
        Username = request.Username,
        Email = request.Email,
        PasswordHash = _passwordHasher.HashPassword(request.Password),
        CompanyId = GetRequiredCompanyId(),
        IsActive = true
    }).ToList();

    return await _userFactory.CreateManyAsync(users);
}

public async Task<long> DeactivateUsersAsync(List<string> userIds)
{
    var filter = _userFactory.CreateFilterBuilder()
        .In(u => u.Id, userIds)
        .Build();
    
    var update = _userFactory.CreateUpdateBuilder()
        .Set(u => u.IsActive, false)
        .SetCurrentTimestamp()
        .Build();
    
    return await _userFactory.UpdateManyAsync(filter, update);
}
```

### 4. 跨租户查询

```csharp
// ✅ 跨租户查询（个人中心等场景）
public async Task<User?> GetUserByIdWithoutTenantFilterAsync(string id)
{
    return await _userFactory.GetByIdWithoutTenantFilterAsync(id);
}

public async Task<List<User>> FindUsersWithoutTenantFilterAsync(string keyword)
{
    var filter = _userFactory.CreateFilterBuilder()
        .Regex(u => u.Username, keyword)
        .Build();
    
    return await _userFactory.FindWithoutTenantFilterAsync(filter);
}
```

## ❌ 避免的做法

### 1. 不要直接使用 MongoDB 驱动

```csharp
// ❌ 错误：直接使用 MongoDB 驱动
public class UserController : ControllerBase
{
    private readonly IMongoCollection<User> _users;

    public async Task<IActionResult> GetUser(string id)
    {
        var user = await _users.Find(x => x.Id == id).FirstOrDefaultAsync();
        return Ok(user);
    }
}

// ✅ 正确：使用数据库操作工厂
public class UserController : BaseApiController
{
    private readonly IUserService _userService;

    public async Task<IActionResult> GetUser(string id)
    {
        var user = await _userService.GetUserByIdAsync(id);
        return Success(user);
    }
}
```

### 2. 不要使用 BaseRepository

```csharp
// ❌ 错误：使用已移除的 BaseRepository
public class UserService : BaseService
{
    private readonly BaseRepository<User> _userRepository;
    
    public UserService(BaseRepository<User> userRepository)
    {
        _userRepository = userRepository;
    }
}

// ✅ 正确：使用数据库操作工厂
public class UserService : BaseService
{
    private readonly IDatabaseOperationFactory<User> _userFactory;
    
    public UserService(IDatabaseOperationFactory<User> userFactory)
    {
        _userFactory = userFactory;
    }
}
```

### 3. 不要忽略多租户隔离

```csharp
// ❌ 错误：忽略多租户隔离
public async Task<List<User>> GetUsersAsync()
{
    return await _collection.Find(_ => true).ToListAsync();
}

// ✅ 正确：使用工厂自动处理多租户隔离
public async Task<List<User>> GetUsersAsync()
{
    return await _userFactory.FindAsync();
}
```

### 4. 不要忽略操作审计

```csharp
// ❌ 错误：忽略操作审计
public async Task<User> CreateUserAsync(CreateUserRequest request)
{
    var user = new User { /* ... */ };
    await _collection.InsertOneAsync(user);
    return user;
}

// ✅ 正确：使用工厂自动记录审计
public async Task<User> CreateUserAsync(CreateUserRequest request)
{
    var user = new User { /* ... */ };
    return await _userFactory.CreateAsync(user);
}
```

## 🔧 最佳实践

### 1. 服务注册

```csharp
// ✅ 在 Program.cs 中注册数据库操作工厂
builder.Services.AddDatabaseFactory();

// 或者为特定实体注册
builder.Services.AddDatabaseOperationFactory<User>();
builder.Services.AddDatabaseOperationFactory<Role>();
```

### 2. 索引管理

```csharp
// ✅ 索引管理（在数据初始化服务中）
public async Task CreateUserIndexesAsync()
{
    // 创建复合索引
    var indexKeys = Builders<User>.IndexKeys
        .Ascending(x => x.CompanyId)
        .Ascending(x => x.Email);
    
    var indexOptions = new CreateIndexOptions
    {
        Unique = true,
        Name = "company_email_unique"
    };

    await _collection.Indexes.CreateOneAsync(
        new CreateIndexModel<User>(indexKeys, indexOptions));

    // 创建搜索索引
    var searchIndexKeys = Builders<User>.IndexKeys
        .Ascending(x => x.CompanyId)
        .Text(x => x.Username)
        .Text(x => x.Email);

    await _collection.Indexes.CreateOneAsync(
        new CreateIndexModel<User>(searchIndexKeys));
}
```

### 3. 软删除

```csharp
// ✅ 软删除实现
public async Task<bool> DeleteUserAsync(string id)
{
    return await _userFactory.SoftDeleteAsync(id);
}

// ✅ 批量软删除
public async Task<long> DeleteUsersAsync(List<string> userIds)
{
    return await _userFactory.SoftDeleteManyAsync(userIds);
}
```

### 4. 操作审计

```csharp
// ✅ 操作审计自动记录
public async Task<User> CreateUserAsync(CreateUserRequest request)
{
    var user = new User { /* ... */ };
    
    // 工厂自动记录审计信息
    return await _userFactory.CreateAsync(user);
}

// ✅ 查询操作历史
public async Task<List<OperationAudit>> GetUserAuditHistoryAsync(string userId)
{
    return await _auditService.GetEntityAuditHistoryAsync("User", userId);
}
```

## 📋 数据访问层检查清单

实现数据访问层时检查：

- [ ] 使用 `IDatabaseOperationFactory<T>` 进行所有数据库操作
- [ ] 禁止直接使用 `IMongoCollection<T>` 进行 CRUD 操作
- [ ] 禁止使用 `BaseRepository<T>`（已移除）
- [ ] 实现多租户隔离（工厂自动处理）
- [ ] 添加适当的异常处理
- [ ] 实现查询优化（使用 FilterBuilder）
- [ ] 添加索引支持
- [ ] 实现批量操作
- [ ] 实现软删除
- [ ] 添加操作审计（工厂自动处理）
- [ ] 添加日志记录
- [ ] 编写单元测试

## 🧪 数据访问层测试

```csharp
// ✅ 数据访问层测试
[Test]
public async Task CreateUser_ShouldRecordAudit()
{
    // Arrange
    var user = new User { Username = "test", Email = "test@example.com" };
    var context = _userFactory.CreateOperationContext()
        .WithUser("user123", "testuser")
        .WithCompany("company123")
        .Build();

    // Act
    var createdUser = await _userFactory.CreateAsync(user, context);

    // Assert
    Assert.That(createdUser.Id, Is.Not.Null);
    Assert.That(createdUser.CreatedBy, Is.EqualTo("user123"));
    Assert.That(createdUser.CreatedByUsername, Is.EqualTo("testuser"));

    // 验证审计记录
    var auditHistory = await _auditService.GetEntityAuditHistoryAsync("User", createdUser.Id);
    Assert.That(auditHistory, Has.Count.EqualTo(1));
    Assert.That(auditHistory[0].OperationType, Is.EqualTo(OperationType.Create));
}

[Test]
public async Task MultiTenantFilter_ShouldWorkCorrectly()
{
    // Arrange
    var company1Users = new List<User> { /* 企业1的用户 */ };
    var company2Users = new List<User> { /* 企业2的用户 */ };

    // Act
    await _userFactory.CreateManyAsync(company1Users, 
        _userFactory.CreateOperationContext().WithCompany("company1").Build());
    
    await _userFactory.CreateManyAsync(company2Users, 
        _userFactory.CreateOperationContext().WithCompany("company2").Build());

    // 切换到企业1上下文
    _tenantContext.SetCurrentCompanyId("company1");
    var company1Result = await _userFactory.FindAsync();

    // 切换到企业2上下文
    _tenantContext.SetCurrentCompanyId("company2");
    var company2Result = await _userFactory.FindAsync();

    // Assert
    Assert.That(company1Result, Has.Count.EqualTo(company1Users.Count));
    Assert.That(company2Result, Has.Count.EqualTo(company2Users.Count));
}
```

## 📚 相关资源

- [数据库操作工厂使用指南](mdc:docs/features/DATABASE-OPERATION-FACTORY-GUIDE.md)
- [数据库操作工厂迁移指南](mdc:docs/features/DATABASE-FACTORY-MIGRATION.md)
- [多租户系统开发规范](mdc:.cursor/rules/MULTI-TENANT-DEVELOPMENT.md)
- [操作审计系统](mdc:Platform.ServiceDefaults/Services/AuditService.cs)
- [MongoDB C# 驱动文档](https://mongodb.github.io/mongo-csharp-driver/)

## 🎯 核心原则

1. **强制使用工厂** - 所有数据库操作必须使用 `IDatabaseOperationFactory<T>`
2. **多租户隔离** - 工厂自动处理多租户数据隔离
3. **操作审计** - 工厂自动记录所有操作审计
4. **类型安全** - 使用强类型构建器确保编译时检查
5. **性能优化** - 使用批量操作和索引优化
6. **软删除** - 优先使用软删除保护数据
7. **异常处理** - 适当的错误处理和日志记录
8. **单元测试** - 确保多租户过滤和审计功能正常工作
