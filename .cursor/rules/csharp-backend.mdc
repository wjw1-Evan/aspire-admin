---
globs: *.cs
description: C# 后端开发规范和最佳实践
---

# C# 后端开发规范

## 🎯 核心原则

**遵循 .NET 9 和 C# 12 最佳实践，确保代码质量、性能和可维护性**

## 📁 项目结构规范

### 服务层架构

```
Platform.ApiService/
├── Controllers/          # API 控制器
├── Services/            # 业务逻辑服务
├── Models/              # 数据模型和 DTO
├── Validators/          # 参数验证器
├── Extensions/          # 扩展方法
├── Constants/           # 常量定义
├── Scripts/             # 数据脚本
└── Program.cs           # 应用入口
```

### 命名规范

```csharp
// ✅ 接口命名
public interface IUserService { }

// ✅ 服务实现命名
public class UserService : IUserService { }

// ✅ 控制器命名
public class UserController : BaseApiController { }

// ✅ 模型命名
public class User : BaseEntity { }
public class CreateUserRequest { }
public class UserResponse { }

// ✅ 常量命名
public static class UserConstants
{
    public const string ACTIVE_STATUS = "active";
    public const string PENDING_STATUS = "pending";
}
```

## 🔧 代码规范

### 1. 控制器规范

```csharp
/// <summary>
/// 用户管理控制器
/// </summary>
[ApiController]
[Route("api/[controller]")]
[Authorize]
public class UserController : BaseApiController
{
    private readonly IUserService _userService;

    public UserController(IUserService userService)
    {
        _userService = userService;
    }

    /// <summary>
    /// 获取用户列表
    /// </summary>
    /// <param name="request">查询参数</param>
    /// <returns>用户列表</returns>
    [HttpGet]
    public async Task<IActionResult> GetUsers([FromQuery] UserListRequest request)
    {
        var users = await _userService.GetUsersAsync(request);
        return Success(users);
    }
}
```

### 2. 服务层规范

```csharp
/// <summary>
/// 用户服务接口
/// </summary>
public interface IUserService
{
    Task<List<User>> GetUsersAsync(UserListRequest request);
    Task<User?> GetUserByIdAsync(string id);
    Task<User> CreateUserAsync(CreateUserRequest request);
    Task<bool> UpdateUserAsync(string id, UpdateUserRequest request);
    Task<bool> DeleteUserAsync(string id);
}

/// <summary>
/// 用户服务实现
/// </summary>
public class UserService : IUserService
{
    private readonly IDatabaseOperationFactory<User> _userFactory;
    private readonly ILogger<UserService> _logger;

    public UserService(
        IDatabaseOperationFactory<User> userFactory,
        ILogger<UserService> logger)
    {
        _userFactory = userFactory;
        _logger = logger;
    }

    public async Task<List<User>> GetUsersAsync(UserListRequest request)
    {
        try
        {
            var filter = _userFactory.CreateFilterBuilder()
                .Equal(u => u.IsActive, true)
                .Build();
            
            var users = await _userFactory.FindAsync(filter);
            return users.ToList();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "获取用户列表失败");
            throw;
        }
    }
}
```

### 3. 模型定义规范

```csharp
/// <summary>
/// 用户实体
/// </summary>
public class User : BaseEntity, 
    Platform.ServiceDefaults.Models.IEntity,
    Platform.ServiceDefaults.Models.ISoftDeletable,
    Platform.ServiceDefaults.Models.ITimestamped
{
    [BsonId]
    [BsonRepresentation(BsonType.ObjectId)]
    public string Id { get; set; } = string.Empty;

    [BsonElement("username")]
    [Required]
    [StringLength(50, MinimumLength = 3)]
    public string Username { get; set; } = string.Empty;

    [BsonElement("email")]
    [Required]
    [EmailAddress]
    public string Email { get; set; } = string.Empty;

    [BsonElement("isActive")]
    public bool IsActive { get; set; } = true;

    [BsonElement("createdAt")]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    [BsonElement("updatedAt")]
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    [BsonElement("isDeleted")]
    public bool IsDeleted { get; set; } = false;
}

/// <summary>
/// 创建用户请求
/// </summary>
public class CreateUserRequest
{
    [Required]
    [StringLength(50, MinimumLength = 3)]
    public string Username { get; set; } = string.Empty;

    [Required]
    [EmailAddress]
    public string Email { get; set; } = string.Empty;

    [Required]
    [MinLength(6)]
    public string Password { get; set; } = string.Empty;
}
```

## 🚫 禁止的做法

### 1. 不要直接使用 IMongoCollection

```csharp
// ❌ 禁止：直接使用 IMongoCollection
private readonly IMongoCollection<User> _users;

// ✅ 正确：使用 IDatabaseOperationFactory
private readonly IDatabaseOperationFactory<User> _userFactory;
```

### 2. 不要手动处理异常

```csharp
// ❌ 禁止：手动 try-catch
try
{
    var result = await _service.DoSomething();
    return Ok(new { success = true, data = result });
}
catch (Exception ex)
{
    return StatusCode(500, new { success = false, error = ex.Message });
}

// ✅ 正确：抛出异常，由 GlobalExceptionMiddleware 处理
var result = await _service.DoSomething();
return Success(result);
```

### 3. 不要手动构建响应格式

```csharp
// ❌ 禁止：手动构建响应
return Ok(new { success = true, data = result });

// ✅ 正确：使用基类方法
return Success(result);
```

### 4. 不要手动提取用户信息

```csharp
// ❌ 禁止：手动提取用户信息
var userId = User.FindFirst("userId")?.Value;
if (string.IsNullOrEmpty(userId))
    return Unauthorized();

// ✅ 正确：使用基类方法
var userId = GetRequiredUserId();
```

## 🔍 异常处理规范

### 1. 使用标准异常类型

```csharp
// ✅ 用户不存在
throw new KeyNotFoundException($"用户 {userId} 不存在");

// ✅ 参数错误
throw new ArgumentException("用户名不能为空");

// ✅ 权限不足
throw new UnauthorizedAccessException("需要管理员权限");

// ✅ 业务逻辑错误
throw new InvalidOperationException("用户已存在");
```

### 2. 异常消息规范

```csharp
// ✅ 包含上下文信息
throw new KeyNotFoundException($"用户 {userId} 不存在");

// ✅ 使用常量定义错误消息
throw new ArgumentException(UserErrorMessages.UsernameRequired);

// ✅ 提供解决建议
throw new InvalidOperationException("用户已存在，请使用其他用户名");
```

## 📝 日志记录规范

### 1. 结构化日志

```csharp
// ✅ 使用结构化日志
_logger.LogInformation("用户 {UserId} 登录成功，IP: {IpAddress}", userId, ipAddress);

// ✅ 记录操作日志
_logger.LogInformation("创建用户: {Username}, 邮箱: {Email}", username, email);

// ✅ 记录错误日志
_logger.LogError(ex, "用户 {UserId} 登录失败", userId);
```

### 2. 日志级别使用

```csharp
// ✅ Trace - 详细的调试信息
_logger.LogTrace("开始处理用户请求: {RequestId}", requestId);

// ✅ Debug - 调试信息
_logger.LogDebug("查询用户: {UserId}", userId);

// ✅ Information - 一般信息
_logger.LogInformation("用户 {UserId} 登录成功", userId);

// ✅ Warning - 警告信息
_logger.LogWarning("用户 {UserId} 多次登录失败", userId);

// ✅ Error - 错误信息
_logger.LogError(ex, "处理用户请求失败: {RequestId}", requestId);

// ✅ Critical - 严重错误
_logger.LogCritical(ex, "系统关键错误");
```

## 🔐 安全规范

### 1. 输入验证

```csharp
// ✅ 使用数据注解验证
public class CreateUserRequest
{
    [Required(ErrorMessage = "用户名不能为空")]
    [StringLength(50, MinimumLength = 3, ErrorMessage = "用户名长度必须在3-50个字符之间")]
    [RegularExpression(@"^[a-zA-Z0-9_]+$", ErrorMessage = "用户名只能包含字母、数字和下划线")]
    public string Username { get; set; } = string.Empty;
}

// ✅ 使用 FluentValidation
public class CreateUserRequestValidator : AbstractValidator<CreateUserRequest>
{
    public CreateUserRequestValidator()
    {
        RuleFor(x => x.Username)
            .NotEmpty().WithMessage("用户名不能为空")
            .Length(3, 50).WithMessage("用户名长度必须在3-50个字符之间")
            .Matches(@"^[a-zA-Z0-9_]+$").WithMessage("用户名只能包含字母、数字和下划线");
    }
}
```

### 2. 权限检查

```csharp
// ✅ 使用 Authorize 特性
[Authorize(Roles = "admin")]
[HttpDelete("{id}")]
public async Task<IActionResult> DeleteUser(string id)
{
    // 实现删除逻辑
}

// ✅ 在服务层检查权限
public async Task<bool> DeleteUserAsync(string id)
{
    if (!IsAdmin())
        throw new UnauthorizedAccessException("需要管理员权限");
    
    // 实现删除逻辑
}
```

## 🎯 性能优化规范

### 1. 异步操作

```csharp
// ✅ 使用 async/await
public async Task<User> GetUserAsync(string id)
{
    return await _userFactory.GetByIdAsync(id);
}

// ✅ 并行执行独立操作
public async Task<UserProfile> GetUserProfileAsync(string userId)
{
    var userTask = _userFactory.GetByIdAsync(userId);
    var rolesTask = _roleFactory.FindAsync(roleFilter);
    
    await Task.WhenAll(userTask, rolesTask);
    
    return new UserProfile
    {
        User = await userTask,
        Roles = await rolesTask
    };
}
```

### 2. 查询优化

```csharp
// ✅ 使用分页查询
var users = await _userFactory.FindPagedAsync(filter, skip: 0, limit: 20);

// ✅ 只查询需要的字段
var projection = Builders<User>.Projection
    .Include(u => u.Id)
    .Include(u => u.Username)
    .Include(u => u.Email);

// ✅ 使用索引优化查询
var filter = _userFactory.CreateFilterBuilder()
    .Equal(u => u.IsActive, true)  // 确保有索引
    .Equal(u => u.CompanyId, companyId)  // 确保有复合索引
    .Build();
```

## 📋 代码审查清单

在提交代码前，检查：

- [ ] 所有服务都使用 `IDatabaseOperationFactory` 而不是 `IMongoCollection`
- [ ] 控制器继承 `BaseApiController` 并使用其方法
- [ ] 异常处理使用标准异常类型和结构化消息
- [ ] 日志记录使用结构化格式
- [ ] 输入验证使用数据注解或 FluentValidation
- [ ] 权限检查在控制器和服务层都有
- [ ] 异步操作正确使用 async/await
- [ ] 查询使用了适当的索引和分页
- [ ] 代码有适当的 XML 文档注释
- [ ] 遵循了命名规范和项目结构

## 📚 相关文档

- [BaseApiController 使用规范](mdc:.cursor/rules/api-controller-standards.mdc)
- [数据库操作工厂规范](mdc:.cursor/rules/database-operation-factory.mdc)
- [异常处理中间件](mdc:Platform.ApiService/Middleware/GlobalExceptionMiddleware.cs)
- [服务扩展方法](mdc:Platform.ServiceDefaults/Extensions/ServiceExtensions.cs)

## 🎯 记住

1. **统一架构** - 遵循项目既定的架构模式
2. **安全第一** - 始终验证输入和检查权限
3. **性能优化** - 使用异步操作和查询优化
4. **错误处理** - 使用统一的异常处理机制
5. **日志记录** - 记录关键操作和错误信息
6. **代码质量** - 保持代码简洁、可读和可维护

遵循这些规范，确保代码的一致性、安全性和可维护性！