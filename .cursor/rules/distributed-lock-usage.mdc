---
description: 分布式锁使用规范和最佳实践
---
# 分布式锁使用规范

## 🎯 何时使用分布式锁

在以下场景中**必须**使用分布式锁：

1. **数据库初始化**：确保多实例只有一个执行初始化
2. **索引创建**：避免并发创建相同索引
3. **定时任务**：确保定时任务只在一个实例上执行
4. **资源分配**：需要全局唯一性的操作

## ✅ 正确的使用方式

### 基本用法

```csharp
// ✅ 使用 ExecuteWithLockAsync 自动管理锁
await _lockService.ExecuteWithLockAsync("lock-name", async () =>
{
    // 受保护的代码
    // 只有获取到锁的实例会执行这里
    await DoSomethingAsync();
}, timeoutSeconds: 60);
```

### 锁命名规范

```csharp
// ✅ 使用描述性的锁名称
"database-initialization"    // 数据库初始化
"index-creation"             // 索引创建
"daily-report-generation"    // 每日报表生成
"resource-allocation-{id}"   // 资源分配（带ID）

// ❌ 避免使用模糊的名称
"lock1"
"temp"
"process"
```

### 超时设置

```csharp
// ✅ 根据操作时长设置合理的超时
await _lockService.ExecuteWithLockAsync("index-creation", async () =>
{
    await CreateIndexesAsync();
}, timeoutSeconds: 60);  // 索引创建可能需要较长时间

await _lockService.ExecuteWithLockAsync("simple-operation", async () =>
{
    await UpdateConfigAsync();
}, timeoutSeconds: 30);  // 简单操作使用默认30秒
```

## ⚠️ 关键实现细节

### 必须使用两阶段锁获取策略

```csharp
// ✅ 正确的锁获取逻辑
// 阶段1: 尝试插入新锁（原子操作）
try
{
    var newLock = new DistributedLock
    {
        LockName = lockName,
        InstanceId = _instanceId,
        AcquiredAt = now,
        ExpiresAt = expiresAt,
        Status = "locked"
    };
    
    await _locks.InsertOneAsync(newLock);
    return true;  // 获取锁成功
}
catch (MongoWriteException ex) when (ex.WriteError?.Category == ServerErrorCategory.DuplicateKey)
{
    // 锁已存在，尝试获取过期的锁
}

// 阶段2: 尝试获取已过期的锁（原子操作）
var filter = Builders<DistributedLock>.Filter.And(
    Builders<DistributedLock>.Filter.Eq(l => l.LockName, lockName),
    Builders<DistributedLock>.Filter.Lt(l => l.ExpiresAt, DateTime.UtcNow)
);

var update = Builders<DistributedLock>.Update
    .Set(l => l.InstanceId, _instanceId)
    .Set(l => l.AcquiredAt, DateTime.UtcNow)
    .Set(l => l.ExpiresAt, DateTime.UtcNow.AddSeconds(timeout));

var result = await _locks.FindOneAndUpdateAsync(filter, update, options);
return result != null && result.InstanceId == _instanceId;
```

### 必须创建唯一索引

```csharp
// ✅ 确保 LockName 有唯一索引
await _locks.Indexes.CreateOneAsync(
    new CreateIndexModel<DistributedLock>(
        Builders<DistributedLock>.IndexKeys.Ascending(l => l.LockName),
        new CreateIndexOptions { Unique = true, Name = "idx_lockName_unique" }
    )
);
```

### 必须创建 TTL 索引

```csharp
// ✅ 自动清理过期的锁
await _locks.Indexes.CreateOneAsync(
    new CreateIndexModel<DistributedLock>(
        Builders<DistributedLock>.IndexKeys.Ascending(l => l.ExpiresAt),
        new CreateIndexOptions 
        { 
            Name = "idx_expiresAt_ttl",
            ExpireAfter = TimeSpan.Zero  // 在 expiresAt 时间过期
        }
    )
);
```

## ❌ 常见错误

### 错误 1: 使用错误的 Filter 逻辑

```csharp
// ❌ 错误：逻辑矛盾的 filter
var filter = Builders<DistributedLock>.Filter.Or(
    Builders<DistributedLock>.Filter.Eq(l => l.LockName, lockName) 
        & Builders<DistributedLock>.Filter.Exists(l => l.Id, false),  // ❌ 这个条件永远不满足
    Builders<DistributedLock>.Filter.Lt(l => l.ExpiresAt, now)
);
```

### 错误 2: 依赖 Upsert 而不是原子插入

```csharp
// ❌ 错误：在错误的 filter 下使用 upsert
var options = new FindOneAndUpdateOptions<DistributedLock>
{
    IsUpsert = true,  // ❌ 可能导致并发问题
    ReturnDocument = ReturnDocument.After
};
```

### 错误 3: 不验证返回的实例ID

```csharp
// ❌ 错误：不验证实例ID
var result = await _locks.FindOneAndUpdateAsync(filter, update);
return result != null;  // ❌ 应该验证 result.InstanceId == _instanceId

// ✅ 正确：验证实例ID
var result = await _locks.FindOneAndUpdateAsync(filter, update);
return result != null && result.InstanceId == _instanceId;
```

### 错误 4: 忘记释放锁

```csharp
// ❌ 错误：手动管理锁但忘记释放
var acquired = await AcquireLockAsync("lock-name");
if (acquired)
{
    await DoSomethingAsync();
    // ❌ 忘记释放锁
}

// ✅ 正确：使用 ExecuteWithLockAsync 自动管理
await _lockService.ExecuteWithLockAsync("lock-name", async () =>
{
    await DoSomethingAsync();
});  // 自动释放锁
```

## 📊 性能考虑

### 锁粒度

```csharp
// ✅ 细粒度锁：针对特定资源
await _lockService.ExecuteWithLockAsync($"user-update-{userId}", async () =>
{
    await UpdateUserAsync(userId);
});

// ⚠️ 粗粒度锁：影响所有用户操作
await _lockService.ExecuteWithLockAsync("user-operations", async () =>
{
    await UpdateUserAsync(userId);  // 阻塞其他用户操作
});
```

### 超时时间

```csharp
// ✅ 根据操作复杂度设置超时
短操作：10-30秒
中等操作：30-60秒
长操作：60-120秒

// ❌ 避免过长的超时（容易造成死锁）
timeoutSeconds: 600  // 10分钟太长
```

## 🔍 故障排查

### 检查锁状态

```javascript
// MongoDB 查询当前锁
db.system_locks.find().pretty()

// 查找过期但未清理的锁
db.system_locks.find({ expiresAt: { $lt: new Date() } })

// 统计锁数量
db.system_locks.countDocuments()
```

### 手动清理锁

```javascript
// 清理所有过期的锁
db.system_locks.deleteMany({ expiresAt: { $lt: new Date() } })

// 清理特定的锁
db.system_locks.deleteOne({ lockName: "database-initialization" })
```

## 📚 相关文档

- [DistributedLockService 实现](mdc:Platform.ApiService/Services/DistributedLockService.cs)
- [分布式锁逻辑错误修复](mdc:docs/bugfixes/DISTRIBUTED-LOCK-LOGIC-FIX.md)
- [数据库初始化优化](mdc:docs/optimization/DATABASE-INITIALIZATION-OPTIMIZATION.md)

## 🎯 记住

1. **原子操作优先**：使用 InsertOne + FindOneAndUpdate，而不是复杂的 filter
2. **唯一索引保护**：LockName 必须有唯一索引
3. **TTL 自动清理**：使用 TTL 索引防止死锁
4. **验证实例ID**：确保返回的锁是当前实例获取的
5. **自动管理**：使用 ExecuteWithLockAsync 而不是手动管理
