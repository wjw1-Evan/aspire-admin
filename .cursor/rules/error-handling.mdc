---
globs: **/error*.ts,**/error*.tsx,**/utils/*error*.ts,**/services/**/*.ts,Platform.ApiService/Controllers/*.cs,Platform.ApiService/Services/*.cs
description: ç»Ÿä¸€é”™è¯¯å¤„ç†å’Œæ¶ˆæ¯ç®¡ç†è§„èŒƒ
---

# ç»Ÿä¸€é”™è¯¯å¤„ç†å’Œæ¶ˆæ¯ç®¡ç†è§„èŒƒ

## ğŸ¯ é”™è¯¯å¤„ç†æ¶æ„

### é”™è¯¯åˆ†ç±»

1. **ç½‘ç»œé”™è¯¯** - è¯·æ±‚è¶…æ—¶ã€è¿æ¥å¤±è´¥
2. **è®¤è¯é”™è¯¯** - Token è¿‡æœŸã€æƒé™ä¸è¶³
3. **ä¸šåŠ¡é”™è¯¯** - ä¸šåŠ¡é€»è¾‘é”™è¯¯
4. **ç³»ç»Ÿé”™è¯¯** - æœåŠ¡å™¨é”™è¯¯ã€æœªçŸ¥é”™è¯¯

## ğŸ”§ åç«¯é”™è¯¯æ¶ˆæ¯ç®¡ç†

### æ ¸å¿ƒåŸåˆ™
ä½¿ç”¨ `ErrorMessages` å¸¸é‡ç±»ç®¡ç†æ‰€æœ‰é”™è¯¯å’ŒæˆåŠŸæ¶ˆæ¯ï¼Œç¦æ­¢ç¡¬ç¼–ç å­—ç¬¦ä¸²ã€‚

### âœ… æ­£ç¡®çš„ä½¿ç”¨æ–¹å¼
```csharp
using Platform.ApiService.Constants;

// æˆåŠŸæ¶ˆæ¯
return Success(data, ErrorMessages.CreateSuccess);
return Success(ErrorMessages.UpdateSuccess);
return Success(ErrorMessages.DeleteSuccess);
return Success(ErrorMessages.OperationSuccess);

// æ ¼å¼åŒ–æ¶ˆæ¯
throw new KeyNotFoundException(
    string.Format(ErrorMessages.ResourceNotFound, "ç”¨æˆ·")
);

throw new ArgumentException(
    string.Format(ErrorMessages.ParameterRequired, "ç”¨æˆ·å")
);

throw new InvalidOperationException(
    string.Format(ErrorMessages.ResourceAlreadyExists, "è§’è‰²åç§°")
);

// ç›´æ¥ä½¿ç”¨å¸¸é‡
throw new UnauthorizedAccessException(ErrorMessages.Unauthorized);
throw new InvalidOperationException(ErrorMessages.CannotDeleteSelf);
throw new InvalidOperationException(ErrorMessages.CannotModifyOwnRole);
```

### âŒ ç¦æ­¢çš„åšæ³•
```csharp
// âŒ ä¸è¦ç¡¬ç¼–ç æˆåŠŸæ¶ˆæ¯
return Success(data, "åˆ›å»ºæˆåŠŸ");
return Success("æ“ä½œæˆåŠŸ");

// âŒ ä¸è¦ç¡¬ç¼–ç é”™è¯¯æ¶ˆæ¯
throw new KeyNotFoundException($"ç”¨æˆ· {id} ä¸å­˜åœ¨");
throw new ArgumentException("ç”¨æˆ·åä¸èƒ½ä¸ºç©º");
throw new InvalidOperationException("ä¸èƒ½åˆ é™¤è‡ªå·±");
```

## ğŸ—ï¸ å‰ç«¯é”™è¯¯å¤„ç†

### ç®¡ç†åå° (Ant Design Pro)

#### é”™è¯¯ç±»å‹å®šä¹‰

```typescript
// âœ… æ¨èï¼šé”™è¯¯ç±»å‹å®šä¹‰
export enum ErrorShowType {
  SILENT = 0,           // ä¸æ˜¾ç¤ºé”™è¯¯
  WARN_MESSAGE = 1,     // è­¦å‘Šæ¶ˆæ¯
  ERROR_MESSAGE = 2,    // é”™è¯¯æ¶ˆæ¯
  NOTIFICATION = 3,     // é€šçŸ¥æé†’
  REDIRECT = 9,         // é¡µé¢è·³è½¬
}

export interface ResponseStructure<T = any> {
  success: boolean;
  data?: T;
  errorCode?: string;
  errorMessage?: string;
  showType?: ErrorShowType;
  traceId?: string;
}

export interface ApiError extends Error {
  info?: ResponseStructure;
  response?: {
    status: number;
    statusText: string;
    data: any;
  };
}
```

#### ç»Ÿä¸€é”™è¯¯é…ç½®

```typescript
// âœ… æ¨èï¼šrequest-error-config.ts
import { message, notification } from 'antd';
import type { RequestConfig } from '@umijs/max';

export const errorConfig: RequestConfig = {
  errorConfig: {
    // é”™è¯¯æŠ›å‡º
    errorThrower: (res) => {
      const { success, data, errorCode, errorMessage, showType } = 
        res as unknown as ResponseStructure;
      
      if (!success) {
        const error: any = new Error(errorMessage);
        error.name = 'BizError';
        error.info = { errorCode, errorMessage, showType, data };
        throw error;
      }
    },
    
    // é”™è¯¯æ¥æ”¶åŠå¤„ç†
    errorHandler: (error: any, opts: any) => {
      // è·³è¿‡é”™è¯¯å¤„ç†
      if (opts?.skipErrorHandler) throw error;
      
      // ä¸šåŠ¡é”™è¯¯
      if (error.name === 'BizError') {
        const errorInfo: ResponseStructure | undefined = error.info;
        if (errorInfo) {
          const { errorMessage, errorCode } = errorInfo;
          
          switch (errorInfo.showType) {
            case ErrorShowType.SILENT:
              // ä¸æ˜¾ç¤ºé”™è¯¯
              break;
            case ErrorShowType.WARN_MESSAGE:
              message.warning(errorMessage);
              break;
            case ErrorShowType.ERROR_MESSAGE:
              message.error(errorMessage);
              break;
            case ErrorShowType.NOTIFICATION:
              notification.open({
                description: errorMessage,
                message: errorCode,
              });
              break;
            case ErrorShowType.REDIRECT:
              // é¡µé¢è·³è½¬é€»è¾‘
              break;
            default:
              message.error(errorMessage);
          }
        }
      } 
      // HTTP é”™è¯¯
      else if (error.response) {
        message.error(`Response status: ${error.response.status}`);
      } 
      // è¯·æ±‚é”™è¯¯
      else if (error.request) {
        message.error('None response! Please retry.');
      } 
      // å…¶ä»–é”™è¯¯
      else {
        message.error('Request error, please retry.');
      }
    },
  },
  
  responseInterceptors: [
    (response) => {
      // æ‹¦æˆªå“åº”æ•°æ®ï¼Œè¿›è¡Œä¸ªæ€§åŒ–å¤„ç†
      const { data } = response as unknown as ResponseStructure;
      
      if (data?.success === false) {
        // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ å…¨å±€é”™è¯¯å¤„ç†é€»è¾‘
        console.error('Request failed:', data.errorMessage);
      }
      
      return response;
    },
  ],
};
```

### ç§»åŠ¨ç«¯ (React Native + Expo)

#### é”™è¯¯ç±»å‹å®šä¹‰

```typescript
// âœ… æ¨èï¼štypes/unified-api.ts
export enum AuthErrorType {
  TOKEN_EXPIRED = 'TOKEN_EXPIRED',
  TOKEN_INVALID = 'TOKEN_INVALID',
  PERMISSION_DENIED = 'PERMISSION_DENIED',
  NOT_AUTHENTICATED = 'NOT_AUTHENTICATED',
}

export interface ApiError extends Error {
  code?: string;
  type?: AuthErrorType;
  statusCode?: number;
  canRetry?: boolean;
  response?: {
    status: number;
    statusText: string;
    data: any;
  };
}
```

#### é”™è¯¯å¤„ç†æœåŠ¡

```typescript
// âœ… æ¨èï¼šservices/errorHandler.ts
import { AuthErrorType } from '@/types/unified-api';

export function createAuthError(
  type: AuthErrorType,
  message: string,
  canRetry: boolean = false
): ApiError {
  const error = new Error(message) as ApiError;
  error.type = type;
  error.canRetry = canRetry;
  return error;
}

export function handleError(error: unknown): ApiError {
  // å·²ç»æ˜¯ ApiError
  if (error instanceof Error && 'type' in error) {
    return error as ApiError;
  }
  
  // HTTP é”™è¯¯
  if (error instanceof Error && 'response' in error) {
    const httpError = error as any;
    const status = httpError.response?.status;
    
    switch (status) {
      case 401:
        return createAuthError(
          AuthErrorType.TOKEN_EXPIRED,
          'ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•',
          false
        );
      case 403:
        return createAuthError(
          AuthErrorType.PERMISSION_DENIED,
          'æƒé™ä¸è¶³',
          false
        );
      default:
        const apiError = new Error(
          httpError.message || 'è¯·æ±‚å¤±è´¥'
        ) as ApiError;
        apiError.statusCode = status;
        apiError.response = httpError.response;
        apiError.canRetry = shouldRetryError(error);
        return apiError;
    }
  }
  
  // ç½‘ç»œé”™è¯¯
  if (error instanceof TypeError) {
    const networkError = new Error('ç½‘ç»œè¿æ¥å¤±è´¥') as ApiError;
    networkError.code = 'NETWORK_ERROR';
    networkError.canRetry = true;
    return networkError;
  }
  
  // è¶…æ—¶é”™è¯¯
  if (error instanceof Error && error.name === 'AbortError') {
    const timeoutError = new Error('è¯·æ±‚è¶…æ—¶') as ApiError;
    timeoutError.code = 'TIMEOUT';
    timeoutError.canRetry = true;
    return timeoutError;
  }
  
  // æœªçŸ¥é”™è¯¯
  const unknownError = new Error('æœªçŸ¥é”™è¯¯') as ApiError;
  unknownError.code = 'UNKNOWN_ERROR';
  return unknownError;
}

export function shouldRetryError(error: unknown): boolean {
  if (error instanceof Error && 'code' in error) {
    const apiError = error as ApiError;
    // ç½‘ç»œé”™è¯¯å’Œè¶…æ—¶é”™è¯¯å¯ä»¥é‡è¯•
    return apiError.code === 'NETWORK_ERROR' || apiError.code === 'TIMEOUT';
  }
  
  if (error instanceof Error && 'response' in error) {
    const httpError = error as any;
    const status = httpError.response?.status;
    // 5xx é”™è¯¯å¯ä»¥é‡è¯•
    return status >= 500 && status < 600;
  }
  
  return false;
}
```

#### API æœåŠ¡é”™è¯¯å¤„ç†

```typescript
// âœ… æ¨èï¼šservices/api.ts
export class ApiService {
  private async requestWithRetry<T>(
    endpoint: string,
    options: RequestInit = {},
    config: RequestConfig = {}
  ): Promise<T> {
    const { timeout, retries } = { ...DEFAULT_REQUEST_CONFIG, ...config };
    
    let lastError: any;
    
    for (let attempt = 0; attempt <= retries; attempt++) {
      try {
        return await this.request<T>(endpoint, options, timeout);
      } catch (error) {
        lastError = error;
        
        // è®¤è¯é”™è¯¯ä¸é‡è¯•
        const apiError = handleError(error);
        if (apiError.type === AuthErrorType.TOKEN_EXPIRED || 
            apiError.type === AuthErrorType.PERMISSION_DENIED) {
          throw apiError;
        }
        
        // å¦‚æœä¸æ˜¯æœ€åä¸€æ¬¡å°è¯•ä¸”å¯ä»¥é‡è¯•ï¼Œç­‰å¾…åé‡è¯•
        if (attempt < retries && shouldRetryError(error)) {
          const delay = calculateRetryDelay(attempt);
          await new Promise(resolve => setTimeout(resolve, delay));
        } else if (attempt >= retries) {
          break;
        }
      }
    }
    
    throw handleError(lastError);
  }
}
```

#### é‡è¯•ç­–ç•¥

```typescript
// âœ… æ¨èï¼šé‡è¯•é…ç½®
export const DEFAULT_REQUEST_CONFIG = {
  timeout: 30000,      // 30ç§’è¶…æ—¶
  retries: 2,          // é‡è¯•2æ¬¡
};

export function calculateRetryDelay(attempt: number): number {
  // æŒ‡æ•°é€€é¿ï¼šç¬¬1æ¬¡ 1ç§’ï¼Œç¬¬2æ¬¡ 2ç§’ï¼Œç¬¬3æ¬¡ 4ç§’
  return Math.min(1000 * Math.pow(2, attempt), 10000);
}

export function shouldRetryError(error: unknown): boolean {
  const apiError = handleError(error);
  
  // ç½‘ç»œé”™è¯¯å¯ä»¥é‡è¯•
  if (apiError.code === 'NETWORK_ERROR' || apiError.code === 'TIMEOUT') {
    return true;
  }
  
  // 5xx é”™è¯¯å¯ä»¥é‡è¯•
  if (apiError.statusCode && apiError.statusCode >= 500) {
    return true;
  }
  
  // è®¤è¯é”™è¯¯ä¸é‡è¯•
  if (apiError.type === AuthErrorType.TOKEN_EXPIRED || 
      apiError.type === AuthErrorType.PERMISSION_DENIED) {
    return false;
  }
  
  return false;
}
```

## ğŸ”§ åç«¯é”™è¯¯å¤„ç† (C#)

### ç»Ÿä¸€å“åº”æ ¼å¼

```csharp
// âœ… æ¨èï¼šç»Ÿä¸€å“åº”æ¨¡å‹
public class ApiResponse<T>
{
    public bool Success { get; set; }
    public T? Data { get; set; }
    public string? ErrorCode { get; set; }
    public string? ErrorMessage { get; set; }
    public int? ShowType { get; set; }
    public string? TraceId { get; set; }
}
```

### å…¨å±€å¼‚å¸¸å¤„ç†

```csharp
// âœ… æ¨èï¼šå…¨å±€å¼‚å¸¸å¤„ç†ä¸­é—´ä»¶
public class GlobalExceptionHandler : IExceptionHandler
{
    private readonly ILogger<GlobalExceptionHandler> _logger;

    public GlobalExceptionHandler(ILogger<GlobalExceptionHandler> logger)
    {
        _logger = logger;
    }

    public async ValueTask<bool> TryHandleAsync(
        HttpContext httpContext,
        Exception exception,
        CancellationToken cancellationToken)
    {
        var traceId = Activity.Current?.Id ?? httpContext.TraceIdentifier;
        
        _logger.LogError(exception, 
            "Error occurred. TraceId: {TraceId}, Path: {Path}", 
            traceId, 
            httpContext.Request.Path);

        var response = exception switch
        {
            UnauthorizedAccessException => CreateResponse(
                false, 
                "æœªæˆæƒè®¿é—®", 
                "UNAUTHORIZED", 
                StatusCodes.Status401Unauthorized,
                traceId),
                
            ArgumentException => CreateResponse(
                false, 
                exception.Message, 
                "BAD_REQUEST", 
                StatusCodes.Status400BadRequest,
                traceId),
                
            KeyNotFoundException => CreateResponse(
                false, 
                "èµ„æºä¸å­˜åœ¨", 
                "NOT_FOUND", 
                StatusCodes.Status404NotFound,
                traceId),
                
            _ => CreateResponse(
                false, 
                "æœåŠ¡å™¨å†…éƒ¨é”™è¯¯", 
                "INTERNAL_ERROR", 
                StatusCodes.Status500InternalServerError,
                traceId)
        };

        httpContext.Response.StatusCode = response.StatusCode;
        await httpContext.Response.WriteAsJsonAsync(response.Body, cancellationToken);

        return true;
    }

    private (int StatusCode, object Body) CreateResponse(
        bool success, 
        string message, 
        string errorCode, 
        int statusCode,
        string traceId)
    {
        return (statusCode, new
        {
            success,
            errorMessage = message,
            errorCode,
            showType = 2, // ERROR_MESSAGE
            traceId
        });
    }
}
```

### æ§åˆ¶å™¨é”™è¯¯å¤„ç†

```csharp
// âœ… æ¨èï¼šæ§åˆ¶å™¨ä¸­çš„é”™è¯¯å¤„ç†
[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    private readonly IUserService _userService;
    private readonly ILogger<UsersController> _logger;

    [HttpGet("{id}")]
    public async Task<ActionResult<ApiResponse<User>>> GetUser(string id)
    {
        try
        {
            var user = await _userService.GetUserByIdAsync(id);
            
            if (user == null)
            {
                return NotFound(new ApiResponse<User>
                {
                    Success = false,
                    ErrorCode = "USER_NOT_FOUND",
                    ErrorMessage = "ç”¨æˆ·ä¸å­˜åœ¨",
                    ShowType = 2
                });
            }

            return Ok(new ApiResponse<User>
            {
                Success = true,
                Data = user
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting user {UserId}", id);
            
            return StatusCode(500, new ApiResponse<User>
            {
                Success = false,
                ErrorCode = "INTERNAL_ERROR",
                ErrorMessage = "è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥",
                ShowType = 2
            });
        }
    }
}
```

## ğŸ“± ç»„ä»¶çº§é”™è¯¯å¤„ç†

### é”™è¯¯è¾¹ç•Œ

```typescript
// âœ… æ¨èï¼šReact é”™è¯¯è¾¹ç•Œ
class ErrorBoundary extends React.Component<
  { children: React.ReactNode },
  { hasError: boolean; error: Error | null }
> {
  constructor(props: any) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div style={{ padding: 20, textAlign: 'center' }}>
          <h1>å‡ºé”™äº†</h1>
          <p>{this.state.error?.message}</p>
          <button onClick={() => window.location.reload()}>
            åˆ·æ–°é¡µé¢
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

### ç§»åŠ¨ç«¯é”™è¯¯æ˜¾ç¤º

```typescript
// âœ… æ¨èï¼šç§»åŠ¨ç«¯é”™è¯¯ç»„ä»¶
import { Alert } from 'react-native';

export function showError(error: ApiError) {
  const message = error.message || 'æ“ä½œå¤±è´¥';
  const canRetry = error.canRetry || false;
  
  if (canRetry) {
    Alert.alert(
      'æ“ä½œå¤±è´¥',
      message,
      [
        { text: 'å–æ¶ˆ', style: 'cancel' },
        { text: 'é‡è¯•', onPress: () => handleRetry() },
      ]
    );
  } else {
    Alert.alert('é”™è¯¯', message, [{ text: 'ç¡®å®š' }]);
  }
}

export function AuthErrorHandler({ children }: { children: React.ReactNode }) {
  const { error, clearError } = useAuth();
  
  useEffect(() => {
    if (error) {
      showError(error);
      clearError();
    }
  }, [error, clearError]);
  
  return <>{children}</>;
}
```

## ğŸš« é¿å…çš„åšæ³•

- ä¸è¦å¿½ç•¥é”™è¯¯ï¼Œè‡³å°‘è¦è®°å½•æ—¥å¿—
- ä¸è¦å‘ç”¨æˆ·æš´éœ²æ•æ„Ÿçš„é”™è¯¯ä¿¡æ¯
- ä¸è¦åœ¨å¤šä¸ªåœ°æ–¹é‡å¤é”™è¯¯å¤„ç†é€»è¾‘
- ä¸è¦å¿˜è®°æ¸…ç†é”™è¯¯çŠ¶æ€
- ä¸è¦æ— é™é‡è¯•å¤±è´¥çš„è¯·æ±‚

## ğŸ”§ æœ€ä½³å®è·µ

1. **ç»Ÿä¸€é”™è¯¯æ ¼å¼** - å‰åç«¯ä½¿ç”¨ç»Ÿä¸€çš„é”™è¯¯å“åº”æ ¼å¼
2. **é”™è¯¯åˆ†ç±»** - æ˜ç¡®åŒºåˆ†ä¸åŒç±»å‹çš„é”™è¯¯
3. **ç”¨æˆ·å‹å¥½** - å‘ç”¨æˆ·æ˜¾ç¤ºå‹å¥½çš„é”™è¯¯ä¿¡æ¯
4. **æ—¥å¿—è®°å½•** - è®°å½•è¯¦ç»†çš„é”™è¯¯æ—¥å¿—ç”¨äºè°ƒè¯•
5. **æ™ºèƒ½é‡è¯•** - å¯¹å¯é‡è¯•çš„é”™è¯¯è‡ªåŠ¨é‡è¯•
6. **é”™è¯¯è¾¹ç•Œ** - ä½¿ç”¨é”™è¯¯è¾¹ç•Œé˜²æ­¢åº”ç”¨å´©æºƒ
7. **TraceId** - ä½¿ç”¨ TraceId è¿½è¸ªé”™è¯¯
8. **ç›‘æ§å‘Šè­¦** - å¯¹å…³é”®é”™è¯¯è®¾ç½®ç›‘æ§å‘Šè­¦
