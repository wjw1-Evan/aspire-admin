---
appliesTo:
  - "Platform.Admin/**"
---

# 前端规则（Platform.Admin 管理后台）

## 路由与菜单
- 业务菜单从后台动态加载，通过 `app.tsx` 的 `menuDataRender` 渲染；静态路由仅保留登录/注册与隐藏页（个人中心、修改密码）。
- 菜单文案存于 `src/locales/*/menu.ts`，各语言需保持 key 与后端菜单标识一致并同步更新。

## 服务与数据请求
- **统一请求方式**：所有 HTTP 调用必须通过 `src/services` 目录下的服务文件 + `@umijs/max` 的 `request`，禁止组件内直接 `fetch` 或创建新的 axios 实例。
- **响应类型**：服务返回类型统一为 `request<ApiResponse<T>>`，与后端 `ApiResponse<T>` 对齐（`success`、`data`、`errorCode`、`errorMessage`、`traceId`）。
- **错误处理**：全局错误拦截器已统一处理 `success=false` 的情况（显示 message、处理 401/403 等），业务代码主要关注成功场景的数据处理。
- **SSE 实时连接**：使用 `useSseConnection` Hook（位于 `src/hooks/useSseConnection.ts`）建立 SSE 连接，支持自动重连、事件监听（`ReceiveMessage`、`SessionUpdated`、`MessageDeleted`、`MessageChunk` 等）。连接通过 JWT token 认证，连接地址为 `/api/chat/sse?token={token}`。组件卸载时自动清理连接资源。

## 页面骨架与列表规范（强制）
- **标准页面布局**：参考 `src/pages/user-management/index.tsx` 和 `src/pages/password-book/index.tsx` 作为标准页面布局规范。
- **页面结构顺序**（从上到下）：
  1. **PageContainer**：统一使用 `title` 和 `extra` 属性
     - `title`：页面标题（使用国际化，带图标），格式：`<Space><Icon />{intl.formatMessage({ id: 'menu.xxx' })}</Space>`
     - `extra`：所有操作按钮集中放在右上角，使用 `Space wrap` 包裹，按钮顺序：刷新 → 次要操作 → 主要操作（新建/添加）
     - `style={{ paddingBlock: 12 }}`
     - 响应式支持：使用 `Grid.useBreakpoint()` 检测移动端，`isMobile = !screens.md`
  2. **统计卡片区域**（可选，有统计数据时显示）：
     - 使用 `Card` 包裹，`style={{ marginBottom: 16, borderRadius: 12 }}`
     - 内部使用 `Row` 和 `Col`，`gutter={[12, 12]}`
     - 使用 `StatCard` 组件展示统计数据
     - 响应式布局：`Col` 使用 `xs={24} sm={12} md={6}`（移动端单列，平板两列，桌面四列）
     - 条件渲染：只在有统计数据时显示，`{statistics && <Card>...</Card>}`
  3. **搜索表单**（可选，需要搜索功能时显示）：
     - 使用 `Card` 包裹，`style={{ marginBottom: 16 }}`
     - 使用 `Form` 组件，响应式布局：`layout={isMobile ? 'vertical' : 'inline'}`
     - 使用 `Form.useForm()` 创建表单实例，管理搜索状态
     - 搜索参数通过 `useState` 管理，在 `request` 函数中合并到查询参数
     - 搜索按钮：`Button type="primary" htmlType="submit"`，移动端使用 `style={{ width: '100%' }}`
     - 重置按钮：`Button onClick={handleReset}`，移动端使用 `style={{ width: '100%' }}`
     - 参考示例：`src/pages/password-book/index.tsx`、`src/pages/user-management/index.tsx`
  4. **数据表格**：
     - 使用 `DataTable`（基于 antd Table，不支持内置搜索表单）
     - 如果有独立搜索表单，设置 `search={false}`
     - **不使用 `toolbar.actions`**（所有操作按钮都在 PageContainer 的 extra 中）
     - 必须添加 `scroll={{ x: 'max-content' }}` 支持横向滚动
     - 表格不包裹在 Card 中，直接放在 PageContainer 内
- **操作按钮规范**：
  - **所有操作按钮必须放在 PageContainer 的 `extra` 中**（页面右上角）
  - 按钮顺序：批量操作按钮在前，刷新按钮在中间，主要操作按钮（如添加）在最后
  - 批量操作按钮需要根据选中行状态启用/禁用
  - 主操作按钮使用 `type="primary"`，刷新按钮使用 `ReloadOutlined` 图标
- **表格组件**：列表/管理页必须使用 `DataTable`（`@/components/DataTable`），禁止使用普通 `Table` 或 `ProTable`。
  - `DataTable` 基于 antd `Table`，不支持内置搜索表单，需要搜索功能时使用独立的搜索表单
  - `DataTable` 支持 `request`、`actionRef`、`search`（布尔值，实际不会渲染搜索表单）、`pagination` 等属性
- **DataTable request 函数**：
  - `request` 函数需返回 `{ data: T[], success: boolean, total: number }` 格式
  - 函数签名：`(params: RequestParams, sort?: Record<string, 'ascend' | 'descend'>) => Promise<RequestData<T>>`
  - 错误已被全局错误处理捕获并显示提示时，应返回 `{ data: [], total: 0, success: false }` 避免表格显示错误状态
  - 从后端 `ApiResponse<PagedResult<T>>` 中提取 `data.list` 和 `data.total` 返回给 DataTable
  - 搜索参数需在 `request` 函数中手动合并（通过 `useState` 管理搜索状态）

## 分页处理规范（强制）
- **统一分页参数**：所有分页相关 API 调用统一使用 `page` 和 `pageSize` 参数（参考 `src/pages/my-activity/index.tsx`）。
- **搜索参数管理**：
  - 使用 `searchParamsRef`（`useRef`）存储最新的搜索参数，确保 `request` 函数能立即访问到最新值
  - 同时使用 `searchParams`（`useState`）管理搜索参数状态（用于 UI 显示）
  - 代码示例：
    ```typescript
    const [searchParams, setSearchParams] = useState<any>({});
    const searchParamsRef = useRef<any>({});
    
    const handleSearch = useCallback(() => {
      const values = searchForm.getFieldsValue();
      // 处理日期范围等特殊字段
      if (values.dateRange && Array.isArray(values.dateRange) && values.dateRange.length === 2) {
        const [start, end] = values.dateRange;
        values.startDate = start ? dayjs(start).toISOString() : undefined;
        values.endDate = end ? dayjs(end).toISOString() : undefined;
        delete values.dateRange;
      }
      // 同时更新 state 和 ref
      searchParamsRef.current = values;
      setSearchParams(values);
      // 重置到第一页并重新加载数据
      if (actionRef.current?.reloadAndReset) {
        actionRef.current.reloadAndReset();
      } else if (actionRef.current?.reload) {
        actionRef.current.reload();
      }
    }, [searchForm]);
    
    const handleReset = useCallback(() => {
      searchForm.resetFields();
      // 同时更新 state 和 ref
      searchParamsRef.current = {};
      setSearchParams({});
      if (actionRef.current?.reloadAndReset) {
        actionRef.current.reloadAndReset();
      } else if (actionRef.current?.reload) {
        actionRef.current.reload();
      }
    }, [searchForm]);
    ```
- **request 函数规范**：
  - 使用 `useCallback` 定义 `request` 函数，依赖数组为空（`[]`），因为使用 `ref` 来获取最新的搜索参数
  - 在 `request` 函数中，从 `params` 中提取 `current` 和 `pageSize`，然后转换为 `page` 和 `pageSize` 传递给后端 API
  - 合并搜索参数时使用 `searchParamsRef.current` 确保获取最新值
  - 代码示例：
    ```typescript
    const fetchRecords = useCallback(async (params: any, sort?: Record<string, any>) => {
      const { current = 1, pageSize = 20 } = params;
      
      // 合并搜索参数，使用 ref 确保获取最新的搜索参数
      const mergedParams = { ...searchParamsRef.current, ...params };
      const { action, httpMethod, statusCode, ipAddress, startDate, endDate } = mergedParams;
      
      // 处理排序参数
      let sortBy = 'createdAt'; // 默认按创建时间排序
      let sortOrder: 'asc' | 'desc' = 'desc'; // 默认降序
      
      if (sort && Object.keys(sort).length > 0) {
        const sortKey = Object.keys(sort)[0];
        const sortValue = sort[sortKey];
        sortBy = sortKey === 'createdAt' ? 'createdAt' : sortKey;
        sortOrder = sortValue === 'ascend' ? 'asc' : 'desc';
      }
      
      try {
        const response = await getCurrentUserActivityLogs({
          page: current, // DataTable 传递的是 current，转换为 page
          pageSize,
          // ... 其他搜索参数
        });
        
        if (response.success && response.data) {
          const result = response.data as any;
          return {
            data: result.data || [],
            total: result.total || 0,
            success: true,
          };
        }
        
        return {
          data: [],
          total: 0,
          success: false,
        };
      } catch (error) {
        console.error('Failed to load records:', error);
        return {
          data: [],
          total: 0,
          success: false,
        };
      }
    }, []); // 空依赖数组，因为使用 ref 来获取最新的搜索参数
    ```
- **服务层 API 调用**：
  - 服务函数参数统一使用 `page` 和 `pageSize`（而不是 `current`）
  - 代码示例：
    ```typescript
    export async function getXiaokeConfigs(params?: {
      page?: number;
      pageSize?: number;
      name?: string;
      isEnabled?: boolean;
      sorter?: string;
    }) {
      return request<API.ApiResponse<XiaokeConfigListResponse>>('/api/xiaoke/config', {
        method: 'GET',
        params,
      });
    }
    ```
- **分页配置**：
  - `DataTable` 的 `pagination` 属性统一配置：
    ```typescript
    pagination={{
      pageSize: 20,
      pageSizeOptions: [10, 20, 50, 100],
      showSizeChanger: true,
      showQuickJumper: true,
    }}
    ```
- **参考实现**：`src/pages/my-activity/index.tsx` 为标准实现，所有分页列表页面应参考此实现。

- **操作列样式规范**（强制）：
  - 列配置：
    - `fixed: 'right'`：固定在最右侧
    - `width: 150`：标准宽度（如果操作按钮较多，可调整为 `200`）
    - `key: 'action'` 或 `'option'`
  - 按钮样式：
    - `type="link"`：统一使用链接样式
    - `size="small"`：统一使用小尺寸
    - `icon={<Icon />}`：所有按钮必须包含图标
    - 按钮文本：显示操作名称（如"编辑"、"删除"等）
  - 容器：使用 `Space size="small"` 包裹所有按钮
  - 禁止使用：
    - 禁止使用下拉菜单（`Dropdown`）隐藏操作
    - 禁止使用"更多"按钮
    - 所有操作按钮必须直接显示在操作列中
  - 查看功能规范（强制）：
    - **禁止在操作列中添加"查看"按钮**
    - 查看功能统一通过点击表格第一列（通常是名称/标题列）实现
    - 第一列应使用 `<a>` 标签包裹，添加 `onClick` 事件和 `style={{ cursor: 'pointer' }}` 样式
    - 如果第一列已有图标或其他元素，应在 `<a>` 标签内包裹所有内容
    - 代码示例：
      ```typescript
      // 简单文本列
      {
        title: intl.formatMessage({ id: 'pages.table.name' }),
        dataIndex: 'name',
        key: 'name',
        render: (text, record) => (
          <a
            onClick={() => {
              setViewingRecord(record);
              setDetailVisible(true);
            }}
            style={{ cursor: 'pointer' }}
          >
            {text}
          </a>
        ),
      }
      
      // 带图标的列
      {
        title: intl.formatMessage({ id: 'pages.table.username' }),
        dataIndex: 'username',
        key: 'username',
        render: (text, record) => (
          <Space>
            <UserOutlined />
            <a
              onClick={() => {
                setViewingUser(record);
                setDetailVisible(true);
              }}
              style={{ cursor: 'pointer' }}
            >
              {text}
            </a>
          </Space>
        ),
      }
      
      // 带标签的列
      {
        title: intl.formatMessage({ id: 'pages.table.action' }),
        dataIndex: 'action',
        key: 'action',
        render: (_, record) => (
          <a
            onClick={() => handleViewDetail(record)}
            style={{ cursor: 'pointer' }}
          >
            <Tag color={getActionTagColor(record.action)}>
              {getActionText(record.action)}
            </Tag>
          </a>
        ),
      }
      ```
  - 图标映射规范：
    - 编辑：`EditOutlined`
    - 删除/移除：`DeleteOutlined`
    - 执行：`PlayCircleOutlined`
    - 取消：`StopOutlined`
    - 处理：`CheckOutlined`
    - 批准：`CheckCircleOutlined`
    - 拒绝：`CloseCircleOutlined`
    - 权限：`KeyOutlined`
  - 删除操作：删除按钮必须使用 `Popconfirm` 或 `Modal.confirm` 进行确认，并添加 `danger` 属性
  - 代码示例：
    ```typescript
    {
      title: intl.formatMessage({ id: 'pages.table.action' }),
      key: 'action',
      fixed: 'right',
      width: 150,
      render: (_, record) => (
        <Space size="small">
          <Button
            type="link"
            size="small"
            icon={<EditOutlined />}
            onClick={() => handleEdit(record)}
          >
            {intl.formatMessage({ id: 'pages.table.edit' })}
          </Button>
          <Popconfirm
            title="确认删除"
            description="确定要删除吗？"
            onConfirm={() => handleDelete(record.id)}
            okText="确定"
            cancelText="取消"
          >
            <Button type="link" size="small" danger icon={<DeleteOutlined />}>
              {intl.formatMessage({ id: 'pages.table.delete' })}
            </Button>
          </Popconfirm>
        </Space>
      ),
    }
    ```
- **样式规范**：禁止自定义样式类，优先使用 Ant Design / ProComponents 现有属性。如需自定义样式，通过组件的 `style` 属性或 Ant Design 的 `theme` 配置实现。

## 移动端适配规范（强制）
- **响应式断点**：使用 Ant Design 的响应式断点系统
  - `xs`: < 576px（超小屏，手机竖屏）
  - `sm`: ≥ 576px（小屏，手机横屏）
  - `md`: ≥ 768px（中屏，平板）
  - `lg`: ≥ 992px（大屏，桌面）
  - `xl`: ≥ 1200px（超大屏）
  - `xxl`: ≥ 1600px（超超大屏）
- **移动端检测**：
  - 使用 `Grid.useBreakpoint()` Hook 检测屏幕尺寸
  - 标准判断：`const screens = useBreakpoint(); const isMobile = !screens.md;`（md 以下为移动端）
  - 代码示例：
    ```typescript
    import { Grid } from 'antd';
    const { useBreakpoint } = Grid;
    
    const screens = useBreakpoint();
    const isMobile = !screens.md; // md 以下为移动端
    ```
- **布局组件响应式**：
  - **Row/Col 布局**：统计卡片、表单等必须使用响应式 `Col` 配置
    - 统计卡片：`xs={24} sm={12} md={6}`（手机单列，平板两列，桌面四列）
    - 表单字段：`xs={24} sm={12}`（手机单列，平板及以上两列）
    - 代码示例：
      ```typescript
      <Row gutter={[12, 12]}>
        <Col xs={24} sm={12} md={6}>
          <StatCard title="总数" value={100} />
        </Col>
      </Row>
      ```
- **搜索表单响应式**：
  - 表单布局：`layout={isMobile ? 'vertical' : 'inline'}`
  - 输入框宽度：移动端使用 `width: '100%'`，桌面端使用固定宽度
  - 按钮宽度：移动端按钮使用 `style={{ width: '100%' }}`
  - 参考实现：`src/pages/password-book/index.tsx`
- **表格适配**：
  - 表格必须支持横向滚动，使用 `scroll={{ x: 'max-content' }}` 或 `scroll={{ x: true }}`
  - 操作列在移动端保持固定，但按钮可能需要调整显示方式
  - 表格列宽度使用相对单位或最小宽度，避免在小屏幕上过宽
  - 代码示例：
    ```typescript
    <DataTable
      columns={columns}
      scroll={{ x: 'max-content' }}
      // ...
    />
    ```
- **按钮和操作适配**：
  - PageContainer 的 `extra` 区域按钮在移动端应支持换行，使用 `Space wrap` 或 `flex-wrap`
  - 操作列按钮在移动端可考虑只显示图标，或使用下拉菜单（仅在移动端）
  - 按钮大小：移动端使用 `size="small"` 或 `size="middle"`，避免过大
  - 代码示例：
    ```typescript
    <PageContainer
      extra={
        <Space wrap>
          <Button size="small">操作1</Button>
          <Button size="small">操作2</Button>
        </Space>
      }
    />
    ```
- **搜索表单适配**：
  - 搜索表单在移动端应垂直布局，使用 `layout="vertical"` 或响应式切换
  - 搜索按钮在移动端应占满宽度，使用 `style={{ width: '100%' }}`
  - 代码示例：
    ```typescript
    <Form
      layout={isMobile ? 'vertical' : 'inline'}
      // ...
    >
      <Form.Item>
        <Button
          type="primary"
          htmlType="submit"
          style={isMobile ? { width: '100%' } : {}}
        >
          搜索
        </Button>
      </Form.Item>
    </Form>
    ```
- **Drawer/Modal 适配**：
  - Drawer 在移动端应占满屏幕，使用 `width={isMobile ? '100%' : 600}`
  - Modal 在移动端应占满屏幕，使用 `width={isMobile ? '100%' : 600}`
  - 代码示例：
    ```typescript
    <Drawer
      width={isMobile ? '100%' : 600}
      // ...
    />
    
    <Modal
      width={isMobile ? '100%' : 600}
      // ...
    />
    ```
  - 参考实现：`src/pages/password-book/index.tsx`
- **详情页面适配**：
  - Descriptions 在移动端应使用单列布局，使用 `column={isMobile ? 1 : 2}` 响应式切换
  - Card 内容在移动端应适当调整内边距
  - 详细规范见下方"详情页面规范"章节
- **字体和间距适配**：
  - 移动端字体大小应适当缩小，但保持可读性
  - 移动端间距应适当减小，使用相对单位（如 `8px`、`12px`）
  - 避免使用固定像素值，优先使用 Ant Design 的间距系统
- **触摸交互优化**：
  - 按钮、链接等可点击元素最小触摸目标为 `44px × 44px`
  - 操作列按钮间距应足够，避免误触
  - 使用 `Space size="small"` 或 `size="middle"` 控制间距
- **检测移动端**（统一规范）：
  - **统一使用** `Grid.useBreakpoint()` Hook 检测屏幕尺寸，禁止使用 `window.innerWidth` 判断
  - 标准判断：`const screens = useBreakpoint(); const isMobile = !screens.md;`（md 以下为移动端）
  - 代码示例：
    ```typescript
    import { Grid } from 'antd';
    const { useBreakpoint } = Grid;
    
    const screens = useBreakpoint();
    const isMobile = !screens.md; // md 以下为移动端
    ```
- **全局样式**：
  - 已在 `global.less` 中添加移动端表格适配样式
  - 移动端菜单打开时自动锁定滚动，防止背景滚动
  - 代码位置：`src/global.less` 和 `src/app.tsx`

## 统计卡片布局（Welcome/各管理页面）
- 统一使用 `src/components/StatCard`（`Platform.Admin/src/components/StatCard.tsx`）。
- 布局：卡片 padding `10px 12px`，图标 20px，数值字号 20px，标题字号 12px，图标在左、数值与标题右侧垂直排列且右对齐。
- 间距：`Row` 的 `gutter={[12, 12]}`，卡片外间距 `marginBottom: 16`，`Col` 响应式 `xs={24} sm={12} md={6}`。
- 统计卡片区域使用 `Card` 包裹，`style={{ marginBottom: 16, borderRadius: 12 }}`。

## 状态管理与类型
- 优先使用 hooks（`useRequest`、`useModel` 等），避免不必要的全局状态。
- 使用 `useState` 定义对象时需完整声明所有字段类型；可选字段写成 `T | undefined`，禁止省略字段导致后续访问类型错误。

## 权限呈现
- 前端不隐藏按钮/菜单，真实权限以后端菜单级校验决定；`access.ts` 仅作基础访问控制。

## 用户显示规范
- **统一显示规则**：所有用户相关字段（创建者、分配者、执行者等）统一显示格式为 `用户名 (昵称)`，如果用户昵称为空则只显示用户名。
- **后端保证**：后端 DTO 转换时已统一处理，返回格式为 `用户名 (昵称)` 或 `用户名`，前端直接使用 `*Name` 字段（如 `createdByName`、`assignedToName` 等）即可，无需额外处理。
- **用户选择框**：在用户选择组件（如 `Select`、`UserPicker` 等）中，选项显示格式应为 `用户名 (昵称)` 或 `用户名`（如果昵称为空），代码示例：
  ```typescript
  options={users.map(user => ({
    label: user.name ? `${user.username} (${user.name})` : user.username,
    value: user.id,
  }))}
  ```
- **类型定义**：`AppUser` 接口必须包含 `name?: string` 字段用于存储用户昵称。

## 日期时间显示规范
- **统一格式**：所有日期时间字段统一使用 `YYYY-MM-DD HH:mm:ss` 格式显示。
- **格式化函数**：在组件中定义统一的 `formatDateTime` 函数，使用 `dayjs` 进行格式化：
  ```typescript
  const formatDateTime = (dateTime: string | null | undefined): string => {
    if (!dateTime) return '-';
    try {
      const date = dayjs(dateTime);
      if (!date.isValid()) return dateTime;
      return date.format('YYYY-MM-DD HH:mm:ss');
    } catch (error) {
      console.error('日期格式化错误:', error, dateTime);
      return dateTime || '-';
    }
  };
  ```
- **日期字段处理**：对于仅日期字段（如开始日期、结束日期），如果包含时间部分则显示完整时间，否则只显示日期部分。
- **空值处理**：日期时间为空或无效时统一显示 `-`。

## 详情页面规范（强制）
- **组件使用**：详情页面统一使用 `Drawer` 组件，`placement="right"`，`width={isMobile ? '100%' : 600}`（可根据内容调整，参考 `src/pages/password-book/index.tsx`）。
- **加载状态**：使用 `Spin` 包裹内容，显示加载状态。
- **空状态**：使用 `Empty` 组件或自定义空状态显示未加载数据的情况。
- **内容结构**：
  - 使用 `Card` 组件分组显示不同类别的信息，每个 Card 有 `title` 属性
  - Card 样式：`style={{ marginBottom: 16 }}`
  - 使用 `Descriptions` 组件显示详细信息，响应式布局：`column={isMobile ? 1 : 2}`，`size="small"`（移动端检测见上方"移动端适配规范"章节）
  - 使用 `Tag` 组件显示状态、类型、分类等标签信息
  - 使用图标增强可读性：在 `Descriptions.Item` 的 `label` 中使用 `Space` 包裹图标和文本
  - 使用 `Divider` 分隔不同部分（可选）
- **日期时间格式**：统一使用 `dayjs` 格式化，格式为 `YYYY-MM-DD HH:mm:ss`（与上方"日期时间显示规范"一致）
- **图标使用**：为每个字段添加合适的图标，使用 `@ant-design/icons` 中的图标
- **响应式布局**：详情页面必须支持移动端，`Descriptions` 的 `column` 属性根据 `isMobile` 动态调整（移动端检测方法见上方"移动端适配规范"章节）
- **参考实现**：`src/pages/password-book/index.tsx`、`src/pages/user-management/components/UserDetail.tsx`、`src/pages/task-management/components/TaskDetail.tsx`
- **代码示例**：
  ```typescript
  <Drawer
    title="详情标题"
    placement="right"
    onClose={onClose}
    open={visible}
    width={isMobile ? '100%' : 600}
  >
    <Spin spinning={loading}>
      {data ? (
        <>
          {/* 基本信息 */}
          <Card title="基本信息" style={{ marginBottom: 16 }}>
            <Descriptions column={isMobile ? 1 : 2} size="small">
              <Descriptions.Item
                label={
                  <Space>
                    <IconOutlined />
                    名称
                  </Space>
                }
                span={2}
              >
                {data.name}
              </Descriptions.Item>
              <Descriptions.Item
                label={
                  <Space>
                    <StatusOutlined />
                    状态
                  </Space>
                }
              >
                <Tag color="green">{data.status}</Tag>
              </Descriptions.Item>
              <Descriptions.Item
                label={
                  <Space>
                    <CalendarOutlined />
                    创建时间
                  </Space>
                }
              >
                {dayjs(data.createdAt).format('YYYY-MM-DD HH:mm:ss')}
              </Descriptions.Item>
            </Descriptions>
          </Card>

          {/* 其他信息 */}
          <Card title="其他信息" style={{ marginBottom: 16 }}>
            <Descriptions column={isMobile ? 1 : 2} size="small">
              {/* ... */}
            </Descriptions>
          </Card>
        </>
      ) : (
        <div style={{ textAlign: 'center', padding: '40px', color: '#999' }}>
          未加载数据
        </div>
      )}
    </Spin>
  </Drawer>
  ```
- **特殊说明**：
  - 如果详情内容非常复杂（如包含多个 Tab、图表等），可以使用 `Tabs` 组件组织内容
  - 如果详情内容较少，可以使用单个 `Descriptions` 组件，但建议使用 `Card` 分组以提高可读性
- **JSON 数据显示规范**：
  - 所有 JSON 数据统一使用 `Paragraph` 组件（Ant Design Typography）显示
  - 样式规范：
    - `width: '100%'`：确保宽度占满容器
    - `maxHeight: 400`：最大高度 400px（可根据内容调整）
    - `overflow: 'auto'`：超出高度时显示滚动条
    - `fontFamily: 'JetBrains Mono, SFMono-Regular, Consolas, Menlo, monospace'`：使用等宽字体
    - `whiteSpace: 'pre-wrap'`：保留格式和换行
    - `marginBottom: 0`：底部边距为 0
  - 必须添加 `copyable` 属性，支持一键复制 JSON 内容
  - 使用 `JSON.stringify(parsed, null, 2)` 格式化 JSON，美化显示
  - 错误处理：JSON 解析失败时显示原始值和错误提示
  - 代码示例：
    ```typescript
    {dataType?.toLowerCase() === 'json' ? (
      (() => {
        try {
          const parsed = JSON.parse(value);
          const formattedJson = JSON.stringify(parsed, null, 2);
          return (
            <Paragraph
              copyable={{ text: value }}
              style={{
                width: '100%',
                maxHeight: 400,
                overflow: 'auto',
                fontFamily: 'JetBrains Mono, SFMono-Regular, Consolas, Menlo, monospace',
                whiteSpace: 'pre-wrap',
                marginBottom: 0,
              }}
            >
              {formattedJson}
            </Paragraph>
          );
        } catch (error) {
          return (
            <div style={{ wordBreak: 'break-all', color: '#ff4d4f' }}>
              {value}
              <div style={{ fontSize: '12px', color: '#999', marginTop: '4px' }}>
                (JSON 解析失败，显示原始值)
              </div>
            </div>
          );
        }
      })()
    ) : (
      <div style={{ wordBreak: 'break-all' }}>{value}</div>
    )}
    ```
