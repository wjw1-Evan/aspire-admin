---
globs: Platform.Admin/src/components/*.tsx,Platform.App/components/*.tsx
description: 前端组件设计模式规范
---

# 前端组件设计模式规范

## 🎯 概述

基于 React 组件设计原则，提供统一的组件设计模式和最佳实践。

## 🏗️ 组件架构模式

### 组件分层架构

```typescript
// ✅ 组件分层架构
// 1. 页面组件 (Pages) - 业务逻辑和状态管理
// 2. 容器组件 (Containers) - 数据获取和状态管理
// 3. 展示组件 (Presentational) - 纯展示逻辑
// 4. 基础组件 (Base) - 可复用的基础组件
// 5. 布局组件 (Layout) - 页面布局结构
```

### 组件设计原则

```typescript
// ✅ 单一职责原则
interface UserCardProps {
  user: User;
  onEdit: (user: User) => void;
  onDelete: (userId: string) => void;
}

// 只负责用户信息的展示和基本操作
export const UserCard: React.FC<UserCardProps> = ({ user, onEdit, onDelete }) => {
  return (
    <Card>
      <CardHeader>
        <Avatar src={user.avatar} />
        <Typography>{user.name}</Typography>
      </CardHeader>
      <CardActions>
        <Button onClick={() => onEdit(user)}>编辑</Button>
        <Button onClick={() => onDelete(user.id)}>删除</Button>
      </CardActions>
    </Card>
  );
};
```

## ✅ 推荐做法

### 1. 高阶组件 (HOC) 模式

```typescript
// ✅ 高阶组件模式
interface WithLoadingProps {
  loading: boolean;
}

export function withLoading<P extends object>(
  Component: React.ComponentType<P>
): React.ComponentType<P & WithLoadingProps> {
  return function WithLoadingComponent(props: P & WithLoadingProps) {
    const { loading, ...restProps } = props;
    
    if (loading) {
      return <LoadingSpinner />;
    }
    
    return <Component {...(restProps as P)} />;
  };
}

// 使用示例
const UserListWithLoading = withLoading(UserList);

// 在组件中使用
<UserListWithLoading users={users} loading={isLoading} />
```

### 2. 渲染属性 (Render Props) 模式

```typescript
// ✅ 渲染属性模式
interface DataFetcherProps<T> {
  url: string;
  children: (data: {
    data: T | null;
    loading: boolean;
    error: string | null;
    refetch: () => void;
  }) => React.ReactNode;
}

export function DataFetcher<T>({ url, children }: DataFetcherProps<T>) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchData = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const response = await fetch(url);
      const result = await response.json();
      setData(result);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [url]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return <>{children({ data, loading, error, refetch: fetchData })}</>;
}

// 使用示例
<DataFetcher<User[]> url="/api/users">
  {({ data, loading, error, refetch }) => (
    <div>
      {loading && <LoadingSpinner />}
      {error && <ErrorMessage message={error} />}
      {data && <UserList users={data} />}
      <Button onClick={refetch}>刷新</Button>
    </div>
  )}
</DataFetcher>
```

### 3. 自定义 Hooks 模式

```typescript
// ✅ 自定义 Hooks 模式
export const useUser = (userId: string) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchUser = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const userData = await userService.getUserById(userId);
      setUser(userData);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [userId]);

  const updateUser = useCallback(async (userData: Partial<User>) => {
    try {
      const updatedUser = await userService.updateUser(userId, userData);
      setUser(updatedUser);
    } catch (err) {
      setError(err.message);
    }
  }, [userId]);

  useEffect(() => {
    fetchUser();
  }, [fetchUser]);

  return { user, loading, error, updateUser, refetch: fetchUser };
};

// 使用示例
const UserProfile: React.FC<{ userId: string }> = ({ userId }) => {
  const { user, loading, error, updateUser } = useUser(userId);

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage message={error} />;
  if (!user) return <NotFound />;

  return <UserProfileForm user={user} onUpdate={updateUser} />;
};
```

### 4. 复合组件模式

```typescript
// ✅ 复合组件模式
interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  children: React.ReactNode;
}

interface ModalContextType {
  isOpen: boolean;
  onClose: () => void;
}

const ModalContext = createContext<ModalContextType | undefined>(undefined);

export const Modal: React.FC<ModalProps> & {
  Header: React.FC<{ children: React.ReactNode }>;
  Body: React.FC<{ children: React.ReactNode }>;
  Footer: React.FC<{ children: React.ReactNode }>;
} = ({ isOpen, onClose, children }) => {
  const contextValue = useMemo(() => ({ isOpen, onClose }), [isOpen, onClose]);

  if (!isOpen) return null;

  return (
    <ModalContext.Provider value={contextValue}>
      <div className="modal-overlay">
        <div className="modal-content">
          {children}
        </div>
      </div>
    </ModalContext.Provider>
  );
};

Modal.Header = ({ children }) => {
  const { onClose } = useContext(ModalContext)!;
  return (
    <div className="modal-header">
      {children}
      <button onClick={onClose}>×</button>
    </div>
  );
};

Modal.Body = ({ children }) => (
  <div className="modal-body">{children}</div>
);

Modal.Footer = ({ children }) => (
  <div className="modal-footer">{children}</div>
);

// 使用示例
<Modal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)}>
  <Modal.Header>
    <h2>编辑用户</h2>
  </Modal.Header>
  <Modal.Body>
    <UserForm user={user} onSubmit={handleSubmit} />
  </Modal.Body>
  <Modal.Footer>
    <Button onClick={() => setIsModalOpen(false)}>取消</Button>
    <Button type="submit" form="user-form">保存</Button>
  </Modal.Footer>
</Modal>
```

### 5. 提供者模式

```typescript
// ✅ 提供者模式
interface ThemeProviderProps {
  children: React.ReactNode;
  defaultTheme?: Theme;
}

export const ThemeProvider: React.FC<ThemeProviderProps> = ({
  children,
  defaultTheme = 'light'
}) => {
  const [theme, setTheme] = useState<Theme>(defaultTheme);

  const toggleTheme = useCallback(() => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  }, []);

  const value = useMemo(() => ({
    theme,
    toggleTheme,
    isDark: theme === 'dark',
    isLight: theme === 'light'
  }), [theme, toggleTheme]);

  return (
    <ThemeContext.Provider value={value}>
      <div className={`theme-${theme}`}>
        {children}
      </div>
    </ThemeContext.Provider>
  );
};

// 使用示例
<ThemeProvider defaultTheme="light">
  <App />
</ThemeProvider>
```

### 6. 观察者模式

```typescript
// ✅ 观察者模式
interface EventEmitter {
  on(event: string, callback: Function): void;
  off(event: string, callback: Function): void;
  emit(event: string, data?: any): void;
}

class EventBus implements EventEmitter {
  private events: Map<string, Function[]> = new Map();

  on(event: string, callback: Function): void {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event)!.push(callback);
  }

  off(event: string, callback: Function): void {
    const callbacks = this.events.get(event);
    if (callbacks) {
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    }
  }

  emit(event: string, data?: any): void {
    const callbacks = this.events.get(event);
    if (callbacks) {
      callbacks.forEach(callback => callback(data));
    }
  }
}

// 使用示例
const eventBus = new EventBus();

// 组件中监听事件
useEffect(() => {
  const handleUserUpdate = (user: User) => {
    setUser(user);
  };

  eventBus.on('user:updated', handleUserUpdate);
  return () => eventBus.off('user:updated', handleUserUpdate);
}, []);

// 触发事件
const updateUser = (user: User) => {
  eventBus.emit('user:updated', user);
};
```

## ❌ 避免的做法

### 1. 不要创建过大的组件

```typescript
// ❌ 错误：过大的组件
export const UserManagement: React.FC = () => {
  // 500+ 行代码
  // 包含用户列表、编辑表单、删除确认等所有逻辑
  return (
    <div>
      {/* 大量 JSX */}
    </div>
  );
};

// ✅ 正确：拆分为小组件
export const UserManagement: React.FC = () => {
  return (
    <div>
      <UserList />
      <UserForm />
      <UserDeleteConfirm />
    </div>
  );
};
```

### 2. 不要直接操作 DOM

```typescript
// ❌ 错误：直接操作 DOM
export const UserCard: React.FC<UserCardProps> = ({ user }) => {
  useEffect(() => {
    const element = document.getElementById(`user-${user.id}`);
    element?.addEventListener('click', handleClick);
    return () => element?.removeEventListener('click', handleClick);
  }, [user.id]);

  return <div id={`user-${user.id}`}>{user.name}</div>;
};

// ✅ 正确：使用 React 事件处理
export const UserCard: React.FC<UserCardProps> = ({ user, onClick }) => {
  return <div onClick={onClick}>{user.name}</div>;
};
```

### 3. 不要忽略性能优化

```typescript
// ❌ 错误：忽略性能优化
export const UserList: React.FC<{ users: User[] }> = ({ users }) => {
  return (
    <div>
      {users.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
};

// ✅ 正确：使用性能优化
export const UserList: React.FC<{ users: User[] }> = ({ users }) => {
  const UserCard = memo(({ user }: { user: User }) => (
    <div>{user.name}</div>
  ));

  return (
    <div>
      {users.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
};
```

### 4. 不要忽略错误边界

```typescript
// ❌ 错误：没有错误边界
export const App: React.FC = () => {
  return (
    <div>
      <UserManagement />
      <ProductManagement />
    </div>
  );
};

// ✅ 正确：添加错误边界
export const App: React.FC = () => {
  return (
    <ErrorBoundary>
      <div>
        <UserManagement />
        <ProductManagement />
      </div>
    </ErrorBoundary>
  );
};
```

## 🔧 最佳实践

### 1. 组件组合

```typescript
// ✅ 组件组合
interface FormFieldProps {
  label: string;
  error?: string;
  children: React.ReactNode;
}

export const FormField: React.FC<FormFieldProps> = ({ label, error, children }) => (
  <div className="form-field">
    <label className="form-label">{label}</label>
    {children}
    {error && <span className="form-error">{error}</span>}
  </div>
);

// 使用示例
<FormField label="用户名" error={errors.username}>
  <Input
    value={values.username}
    onChange={handleUsernameChange}
    placeholder="请输入用户名"
  />
</FormField>
```

### 2. 组件测试

```typescript
// ✅ 组件测试
describe('UserCard', () => {
  it('should render user information correctly', () => {
    const user = { id: '1', name: 'John Doe', email: 'john@example.com' };
    const { getByText } = render(<UserCard user={user} />);
    
    expect(getByText('John Doe')).toBeInTheDocument();
    expect(getByText('john@example.com')).toBeInTheDocument();
  });

  it('should call onEdit when edit button is clicked', () => {
    const user = { id: '1', name: 'John Doe', email: 'john@example.com' };
    const onEdit = jest.fn();
    const { getByText } = render(<UserCard user={user} onEdit={onEdit} />);
    
    fireEvent.click(getByText('编辑'));
    expect(onEdit).toHaveBeenCalledWith(user);
  });
});
```

### 3. 组件文档

```typescript
// ✅ 组件文档
/**
 * 用户卡片组件
 * 
 * @param user - 用户信息
 * @param onEdit - 编辑回调函数
 * @param onDelete - 删除回调函数
 * @param className - 自定义样式类名
 * 
 * @example
 * ```tsx
 * <UserCard
 *   user={user}
 *   onEdit={handleEdit}
 *   onDelete={handleDelete}
 * />
 * ```
 */
export const UserCard: React.FC<UserCardProps> = ({
  user,
  onEdit,
  onDelete,
  className
}) => {
  // 组件实现
};
```

## 📋 组件设计检查清单

设计组件时检查：

- [ ] 单一职责原则
- [ ] 适当的组件大小
- [ ] 清晰的 Props 接口
- [ ] 性能优化考虑
- [ ] 错误处理
- [ ] 可访问性支持
- [ ] 类型安全
- [ ] 单元测试覆盖
- [ ] 文档完整
- [ ] 可复用性

## 📚 相关资源

- [React 组件设计原则](https://react.dev/learn/thinking-in-react)
- [组件模式指南](https://reactpatterns.com/)
- [高阶组件](https://react.dev/reference/react/Component#caveats)
- [自定义 Hooks](https://react.dev/reference/react/useCallback)
- [组件库](mdc:Platform.Admin/src/components/)

## 🎯 核心原则

1. **单一职责** - 每个组件只负责一个功能
2. **可复用性** - 设计可复用的组件
3. **可测试性** - 便于单元测试
4. **性能优化** - 考虑渲染性能
5. **类型安全** - 使用 TypeScript 类型
6. **可访问性** - 支持无障碍访问
7. **文档完整** - 提供完整的文档
8. **错误处理** - 适当的错误处理