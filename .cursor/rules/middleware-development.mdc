---
globs: Platform.ApiService/Middleware/*.cs
description: ä¸­é—´ä»¶å¼€å‘è§„èŒƒå’Œæœ€ä½³å®è·µ
---

# ä¸­é—´ä»¶å¼€å‘è§„èŒƒ

## ğŸ¯ æ¦‚è¿°

åŸºäº .NET Core ä¸­é—´ä»¶ç®¡é“æ¨¡å¼ï¼Œæä¾›ç»Ÿä¸€çš„ä¸­é—´ä»¶å¼€å‘è§„èŒƒå’Œæœ€ä½³å®è·µã€‚

## ğŸ—ï¸ ä¸­é—´ä»¶æ¶æ„æ¨¡å¼

### æ ‡å‡†ä¸­é—´ä»¶ç»“æ„

```csharp
// âœ… æ ‡å‡†ä¸­é—´ä»¶å®ç°
public class CustomMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<CustomMiddleware> _logger;
    private readonly IConfiguration _configuration;

    public CustomMiddleware(
        RequestDelegate next,
        ILogger<CustomMiddleware> logger,
        IConfiguration configuration)
    {
        _next = next;
        _logger = logger;
        _configuration = configuration;
    }

    public async Task InvokeAsync(HttpContext context, IService service)
    {
        // 1. å‰ç½®å¤„ç†
        await PreProcessAsync(context);
        
        // 2. æ‰§è¡Œä¸‹ä¸€ä¸ªä¸­é—´ä»¶
        await _next(context);
        
        // 3. åç½®å¤„ç†
        await PostProcessAsync(context);
    }
}
```

### ä¸­é—´ä»¶æ³¨å†Œé¡ºåº

```csharp
// âœ… æ­£ç¡®çš„ä¸­é—´ä»¶æ³¨å†Œé¡ºåº
app.UseExceptionHandler();           // 1. å¼‚å¸¸å¤„ç†ï¼ˆæœ€å¤–å±‚ï¼‰
app.UseAuthentication();            // 2. è®¤è¯
app.UseAuthorization();             // 3. æˆæƒ
app.UseMiddleware<ActivityLogMiddleware>();  // 4. æ´»åŠ¨æ—¥å¿—
app.UseCors();                      // 5. CORS
app.UseMiddleware<ResponseFormattingMiddleware>();  // 6. å“åº”æ ¼å¼åŒ–
app.MapControllers();               // 7. æ§åˆ¶å™¨è·¯ç”±
```

## âœ… æ¨èåšæ³•

### 1. å¼‚å¸¸å¤„ç†ä¸­é—´ä»¶

```csharp
// âœ… å…¨å±€å¼‚å¸¸å¤„ç†ä¸­é—´ä»¶
public class GlobalExceptionMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<GlobalExceptionMiddleware> _logger;

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unhandled exception occurred");
            await HandleExceptionAsync(context, ex);
        }
    }

    private async Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        context.Response.ContentType = "application/json";
        
        var response = exception switch
        {
            KeyNotFoundException => new { success = false, error = "èµ„æºä¸å­˜åœ¨", errorCode = "NOT_FOUND" },
            UnauthorizedAccessException => new { success = false, error = "æœªæˆæƒè®¿é—®", errorCode = "UNAUTHORIZED" },
            ArgumentException => new { success = false, error = "å‚æ•°é”™è¯¯", errorCode = "INVALID_ARGUMENT" },
            _ => new { success = false, error = "æœåŠ¡å™¨å†…éƒ¨é”™è¯¯", errorCode = "INTERNAL_ERROR" }
        };

        context.Response.StatusCode = GetStatusCode(exception);
        await context.Response.WriteAsync(JsonSerializer.Serialize(response));
    }
}
```

### 2. æ´»åŠ¨æ—¥å¿—ä¸­é—´ä»¶

```csharp
// âœ… æ´»åŠ¨æ—¥å¿—ä¸­é—´ä»¶å®ç°
public class ActivityLogMiddleware
{
    private static readonly string[] ExcludedPaths = { "/health", "/api/openapi", "/scalar/" };

    public async Task InvokeAsync(HttpContext context, IUserActivityLogService logService)
    {
        // æ£€æŸ¥æ˜¯å¦å¯ç”¨æ—¥å¿—è®°å½•
        var enabled = _configuration.GetValue<bool>("ActivityLog:Enabled", true);
        if (!enabled || ShouldExclude(context.Request.Path))
        {
            await _next(context);
            return;
        }

        var stopwatch = Stopwatch.StartNew();
        await _next(context);
        stopwatch.Stop();

        // å¼‚æ­¥è®°å½•æ—¥å¿—ï¼ˆä¸é˜»å¡å“åº”ï¼‰
        _ = Task.Run(async () =>
        {
            try
            {
                await LogRequestAsync(context, logService, stopwatch.ElapsedMilliseconds);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to log activity for {Path}", context.Request.Path);
            }
        });
    }
}
```

### 3. å“åº”æ ¼å¼åŒ–ä¸­é—´ä»¶

```csharp
// âœ… ç»Ÿä¸€å“åº”æ ¼å¼åŒ–ä¸­é—´ä»¶
public class ResponseFormattingMiddleware
{
    public async Task InvokeAsync(HttpContext context)
    {
        var originalBodyStream = context.Response.Body;
        
        using var responseBody = new MemoryStream();
        context.Response.Body = responseBody;

        await _next(context);

        // æ ¼å¼åŒ–å“åº”
        if (ShouldFormatResponse(context))
        {
            await FormatResponseAsync(context);
        }

        await responseBody.CopyToAsync(originalBodyStream);
    }
}
```

### 4. æƒé™éªŒè¯ç‰¹æ€§

```csharp
// âœ… èœå•æƒé™éªŒè¯ç‰¹æ€§
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true)]
public class RequireMenuAttribute : Attribute, IAsyncAuthorizationFilter
{
    public string MenuName { get; }

    public async Task OnAuthorizationAsync(AuthorizationFilterContext context)
    {
        if (!context.HttpContext.User.Identity?.IsAuthenticated ?? true)
        {
            context.Result = new UnauthorizedObjectResult(new
            {
                success = false,
                error = "æœªæˆæƒè®¿é—®",
                errorCode = "UNAUTHORIZED"
            });
            return;
        }

        var menuAccessService = context.HttpContext.RequestServices
            .GetService<IMenuAccessService>();
        
        var hasAccess = await menuAccessService.HasMenuAccessAsync(userId, MenuName);
        if (!hasAccess)
        {
            context.Result = new ForbidResult();
        }
    }
}
```

## âŒ é¿å…çš„åšæ³•

### 1. ä¸è¦åœ¨ä¸­é—´ä»¶ä¸­é˜»å¡ä¸»çº¿ç¨‹

```csharp
// âŒ é”™è¯¯ï¼šåŒæ­¥ç­‰å¾…æ•°æ®åº“æ“ä½œ
public async Task InvokeAsync(HttpContext context, IUserActivityLogService logService)
{
    await _next(context);
    
    // âŒ é˜»å¡å“åº”
    await logService.LogAsync(context);
}

// âœ… æ­£ç¡®ï¼šå¼‚æ­¥è®°å½•æ—¥å¿—
public async Task InvokeAsync(HttpContext context, IUserActivityLogService logService)
{
    await _next(context);
    
    // âœ… å¼‚æ­¥è®°å½•ï¼Œä¸é˜»å¡å“åº”
    _ = Task.Run(async () => await logService.LogAsync(context));
}
```

### 2. ä¸è¦å¿½ç•¥å¼‚å¸¸å¤„ç†

```csharp
// âŒ é”™è¯¯ï¼šå¿½ç•¥å¼‚å¸¸
public async Task InvokeAsync(HttpContext context)
{
    await _next(context);  // âŒ æ²¡æœ‰å¼‚å¸¸å¤„ç†
}

// âœ… æ­£ç¡®ï¼šé€‚å½“çš„å¼‚å¸¸å¤„ç†
public async Task InvokeAsync(HttpContext context)
{
    try
    {
        await _next(context);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Middleware error");
        // æ ¹æ®ä¸­é—´ä»¶èŒè´£å†³å®šæ˜¯å¦é‡æ–°æŠ›å‡º
        throw;
    }
}
```

### 3. ä¸è¦ç¡¬ç¼–ç é…ç½®

```csharp
// âŒ é”™è¯¯ï¼šç¡¬ç¼–ç é…ç½®
private static readonly string[] ExcludedPaths = { "/health", "/api/openapi" };

// âœ… æ­£ç¡®ï¼šä»é…ç½®è¯»å–
private readonly string[] _excludedPaths;

public CustomMiddleware(IConfiguration configuration)
{
    _excludedPaths = configuration.GetSection("Middleware:ExcludedPaths")
        .Get<string[]>() ?? Array.Empty<string>();
}
```

## ğŸ”§ æœ€ä½³å®è·µ

### 1. ä¸­é—´ä»¶ç”Ÿå‘½å‘¨æœŸç®¡ç†

```csharp
// âœ… ä½¿ç”¨ Scoped æœåŠ¡
public async Task InvokeAsync(HttpContext context, IScopedService service)
{
    // ä¸­é—´ä»¶å¯ä»¥å®‰å…¨ä½¿ç”¨ Scoped æœåŠ¡
    await service.DoSomething();
    await _next(context);
}
```

### 2. æ€§èƒ½ä¼˜åŒ–

```csharp
// âœ… æ¡ä»¶æ‰§è¡Œä¸­é—´ä»¶
public async Task InvokeAsync(HttpContext context)
{
    if (!ShouldProcess(context))
    {
        await _next(context);
        return;
    }

    // æ‰§è¡Œä¸­é—´ä»¶é€»è¾‘
    await ProcessRequest(context);
    await _next(context);
}
```

### 3. æ—¥å¿—è®°å½•è§„èŒƒ

```csharp
// âœ… ç»“æ„åŒ–æ—¥å¿—è®°å½•
_logger.LogInformation(
    "Processing request {Method} {Path} for user {UserId}",
    context.Request.Method,
    context.Request.Path,
    userId);
```

### 4. é…ç½®ç®¡ç†

```csharp
// âœ… é…ç½®é€‰é¡¹æ¨¡å¼
public class MiddlewareOptions
{
    public bool Enabled { get; set; } = true;
    public string[] ExcludedPaths { get; set; } = Array.Empty<string>();
    public TimeSpan Timeout { get; set; } = TimeSpan.FromSeconds(30);
}

// æ³¨å†Œé…ç½®
builder.Services.Configure<MiddlewareOptions>(
    builder.Configuration.GetSection("Middleware"));
```

## ğŸ“‹ ä¸­é—´ä»¶å¼€å‘æ£€æŸ¥æ¸…å•

åˆ›å»ºæ–°ä¸­é—´ä»¶æ—¶æ£€æŸ¥ï¼š

- [ ] ç»§æ‰¿æ­£ç¡®çš„åŸºç±»æˆ–å®ç°æ­£ç¡®çš„æ¥å£
- [ ] ä½¿ç”¨ä¾èµ–æ³¨å…¥è·å–æœåŠ¡
- [ ] å®ç°é€‚å½“çš„å¼‚å¸¸å¤„ç†
- [ ] è€ƒè™‘æ€§èƒ½å½±å“ï¼ˆå¼‚æ­¥æ“ä½œï¼‰
- [ ] æ·»åŠ é…ç½®é€‰é¡¹æ”¯æŒ
- [ ] ç¼–å†™å•å…ƒæµ‹è¯•
- [ ] æ·»åŠ ç»“æ„åŒ–æ—¥å¿—è®°å½•
- [ ] è€ƒè™‘ä¸­é—´ä»¶æ‰§è¡Œé¡ºåº
- [ ] å¤„ç†è¾¹ç•Œæƒ…å†µï¼ˆå¦‚è·¯å¾„æ’é™¤ï¼‰
- [ ] ç¡®ä¿çº¿ç¨‹å®‰å…¨

## ğŸ§ª æµ‹è¯•ä¸­é—´ä»¶

```csharp
// âœ… ä¸­é—´ä»¶å•å…ƒæµ‹è¯•
[Test]
public async Task InvokeAsync_ShouldProcessRequest_WhenEnabled()
{
    // Arrange
    var context = new DefaultHttpContext();
    var next = new RequestDelegate(_ => Task.CompletedTask);
    var middleware = new CustomMiddleware(next, _logger, _configuration);

    // Act
    await middleware.InvokeAsync(context, _service);

    // Assert
    Assert.That(context.Response.StatusCode, Is.EqualTo(200));
}
```

## ğŸ“š ç›¸å…³èµ„æº

- [ASP.NET Core ä¸­é—´ä»¶æ–‡æ¡£](https://docs.microsoft.com/aspnet/core/fundamentals/middleware/)
- [è‡ªå®šä¹‰ä¸­é—´ä»¶æŒ‡å—](https://docs.microsoft.com/aspnet/core/fundamentals/middleware/write)
- [å¼‚å¸¸å¤„ç†ä¸­é—´ä»¶](mdc:Platform.ApiService/Middleware/GlobalExceptionMiddleware.cs)
- [æ´»åŠ¨æ—¥å¿—ä¸­é—´ä»¶](mdc:Platform.ApiService/Middleware/ActivityLogMiddleware.cs)
- [å“åº”æ ¼å¼åŒ–ä¸­é—´ä»¶](mdc:Platform.ApiService/Middleware/ResponseFormattingMiddleware.cs)

## ğŸ¯ æ ¸å¿ƒåŸåˆ™

1. **å•ä¸€èŒè´£** - æ¯ä¸ªä¸­é—´ä»¶åªè´Ÿè´£ä¸€ä¸ªåŠŸèƒ½
2. **å¼‚å¸¸å®‰å…¨** - é€‚å½“çš„å¼‚å¸¸å¤„ç†å’Œæ—¥å¿—è®°å½•
3. **æ€§èƒ½ä¼˜å…ˆ** - é¿å…é˜»å¡ä¸»çº¿ç¨‹
4. **é…ç½®é©±åŠ¨** - æ”¯æŒé…ç½®é€‰é¡¹å’Œå¼€å…³
5. **å¯æµ‹è¯•æ€§** - è®¾è®¡ä¾¿äºå•å…ƒæµ‹è¯•
6. **é¡ºåºé‡è¦** - è€ƒè™‘ä¸­é—´ä»¶æ‰§è¡Œé¡ºåº
7. **èµ„æºç®¡ç†** - æ­£ç¡®é‡Šæ”¾èµ„æº
8. **æ—¥å¿—è®°å½•** - ä½¿ç”¨ç»“æ„åŒ–æ—¥å¿—