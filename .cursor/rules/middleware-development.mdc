---
globs: Platform.ApiService/Middleware/*.cs
description: 中间件开发规范和最佳实践
---

# 中间件开发规范

## 🎯 概述

基于 .NET Core 中间件管道模式，提供统一的中间件开发规范和最佳实践。

## 🏗️ 中间件架构模式

### 标准中间件结构

```csharp
// ✅ 标准中间件实现
public class CustomMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<CustomMiddleware> _logger;
    private readonly IConfiguration _configuration;

    public CustomMiddleware(
        RequestDelegate next,
        ILogger<CustomMiddleware> logger,
        IConfiguration configuration)
    {
        _next = next;
        _logger = logger;
        _configuration = configuration;
    }

    public async Task InvokeAsync(HttpContext context, IService service)
    {
        // 1. 前置处理
        await PreProcessAsync(context);
        
        // 2. 执行下一个中间件
        await _next(context);
        
        // 3. 后置处理
        await PostProcessAsync(context);
    }
}
```

### 中间件注册顺序

```csharp
// ✅ 正确的中间件注册顺序
app.UseExceptionHandler();           // 1. 异常处理（最外层）
app.UseAuthentication();            // 2. 认证
app.UseAuthorization();             // 3. 授权
app.UseMiddleware<ActivityLogMiddleware>();  // 4. 活动日志
app.UseCors();                      // 5. CORS
app.UseMiddleware<ResponseFormattingMiddleware>();  // 6. 响应格式化
app.MapControllers();               // 7. 控制器路由
```

## ✅ 推荐做法

### 1. 异常处理中间件

```csharp
// ✅ 全局异常处理中间件
public class GlobalExceptionMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<GlobalExceptionMiddleware> _logger;

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unhandled exception occurred");
            await HandleExceptionAsync(context, ex);
        }
    }

    private async Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        context.Response.ContentType = "application/json";
        
        var response = exception switch
        {
            KeyNotFoundException => new { success = false, error = "资源不存在", errorCode = "NOT_FOUND" },
            UnauthorizedAccessException => new { success = false, error = "未授权访问", errorCode = "UNAUTHORIZED" },
            ArgumentException => new { success = false, error = "参数错误", errorCode = "INVALID_ARGUMENT" },
            _ => new { success = false, error = "服务器内部错误", errorCode = "INTERNAL_ERROR" }
        };

        context.Response.StatusCode = GetStatusCode(exception);
        await context.Response.WriteAsync(JsonSerializer.Serialize(response));
    }
}
```

### 2. 活动日志中间件

```csharp
// ✅ 活动日志中间件实现
public class ActivityLogMiddleware
{
    private static readonly string[] ExcludedPaths = { "/health", "/api/openapi", "/scalar/" };

    public async Task InvokeAsync(HttpContext context, IUserActivityLogService logService)
    {
        // 检查是否启用日志记录
        var enabled = _configuration.GetValue<bool>("ActivityLog:Enabled", true);
        if (!enabled || ShouldExclude(context.Request.Path))
        {
            await _next(context);
            return;
        }

        var stopwatch = Stopwatch.StartNew();
        await _next(context);
        stopwatch.Stop();

        // 异步记录日志（不阻塞响应）
        _ = Task.Run(async () =>
        {
            try
            {
                await LogRequestAsync(context, logService, stopwatch.ElapsedMilliseconds);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to log activity for {Path}", context.Request.Path);
            }
        });
    }
}
```

### 3. 响应格式化中间件

```csharp
// ✅ 统一响应格式化中间件
public class ResponseFormattingMiddleware
{
    public async Task InvokeAsync(HttpContext context)
    {
        var originalBodyStream = context.Response.Body;
        
        using var responseBody = new MemoryStream();
        context.Response.Body = responseBody;

        await _next(context);

        // 格式化响应
        if (ShouldFormatResponse(context))
        {
            await FormatResponseAsync(context);
        }

        await responseBody.CopyToAsync(originalBodyStream);
    }
}
```

### 4. 权限验证特性

```csharp
// ✅ 菜单权限验证特性
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true)]
public class RequireMenuAttribute : Attribute, IAsyncAuthorizationFilter
{
    public string MenuName { get; }

    public async Task OnAuthorizationAsync(AuthorizationFilterContext context)
    {
        if (!context.HttpContext.User.Identity?.IsAuthenticated ?? true)
        {
            context.Result = new UnauthorizedObjectResult(new
            {
                success = false,
                error = "未授权访问",
                errorCode = "UNAUTHORIZED"
            });
            return;
        }

        var menuAccessService = context.HttpContext.RequestServices
            .GetService<IMenuAccessService>();
        
        var hasAccess = await menuAccessService.HasMenuAccessAsync(userId, MenuName);
        if (!hasAccess)
        {
            context.Result = new ForbidResult();
        }
    }
}
```

## ❌ 避免的做法

### 1. 不要在中间件中阻塞主线程

```csharp
// ❌ 错误：同步等待数据库操作
public async Task InvokeAsync(HttpContext context, IUserActivityLogService logService)
{
    await _next(context);
    
    // ❌ 阻塞响应
    await logService.LogAsync(context);
}

// ✅ 正确：异步记录日志
public async Task InvokeAsync(HttpContext context, IUserActivityLogService logService)
{
    await _next(context);
    
    // ✅ 异步记录，不阻塞响应
    _ = Task.Run(async () => await logService.LogAsync(context));
}
```

### 2. 不要忽略异常处理

```csharp
// ❌ 错误：忽略异常
public async Task InvokeAsync(HttpContext context)
{
    await _next(context);  // ❌ 没有异常处理
}

// ✅ 正确：适当的异常处理
public async Task InvokeAsync(HttpContext context)
{
    try
    {
        await _next(context);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Middleware error");
        // 根据中间件职责决定是否重新抛出
        throw;
    }
}
```

### 3. 不要硬编码配置

```csharp
// ❌ 错误：硬编码配置
private static readonly string[] ExcludedPaths = { "/health", "/api/openapi" };

// ✅ 正确：从配置读取
private readonly string[] _excludedPaths;

public CustomMiddleware(IConfiguration configuration)
{
    _excludedPaths = configuration.GetSection("Middleware:ExcludedPaths")
        .Get<string[]>() ?? Array.Empty<string>();
}
```

## 🔧 最佳实践

### 1. 中间件生命周期管理

```csharp
// ✅ 使用 Scoped 服务
public async Task InvokeAsync(HttpContext context, IScopedService service)
{
    // 中间件可以安全使用 Scoped 服务
    await service.DoSomething();
    await _next(context);
}
```

### 2. 性能优化

```csharp
// ✅ 条件执行中间件
public async Task InvokeAsync(HttpContext context)
{
    if (!ShouldProcess(context))
    {
        await _next(context);
        return;
    }

    // 执行中间件逻辑
    await ProcessRequest(context);
    await _next(context);
}
```

### 3. 日志记录规范

```csharp
// ✅ 结构化日志记录
_logger.LogInformation(
    "Processing request {Method} {Path} for user {UserId}",
    context.Request.Method,
    context.Request.Path,
    userId);
```

### 4. 配置管理

```csharp
// ✅ 配置选项模式
public class MiddlewareOptions
{
    public bool Enabled { get; set; } = true;
    public string[] ExcludedPaths { get; set; } = Array.Empty<string>();
    public TimeSpan Timeout { get; set; } = TimeSpan.FromSeconds(30);
}

// 注册配置
builder.Services.Configure<MiddlewareOptions>(
    builder.Configuration.GetSection("Middleware"));
```

## 📋 中间件开发检查清单

创建新中间件时检查：

- [ ] 继承正确的基类或实现正确的接口
- [ ] 使用依赖注入获取服务
- [ ] 实现适当的异常处理
- [ ] 考虑性能影响（异步操作）
- [ ] 添加配置选项支持
- [ ] 编写单元测试
- [ ] 添加结构化日志记录
- [ ] 考虑中间件执行顺序
- [ ] 处理边界情况（如路径排除）
- [ ] 确保线程安全

## 🧪 测试中间件

```csharp
// ✅ 中间件单元测试
[Test]
public async Task InvokeAsync_ShouldProcessRequest_WhenEnabled()
{
    // Arrange
    var context = new DefaultHttpContext();
    var next = new RequestDelegate(_ => Task.CompletedTask);
    var middleware = new CustomMiddleware(next, _logger, _configuration);

    // Act
    await middleware.InvokeAsync(context, _service);

    // Assert
    Assert.That(context.Response.StatusCode, Is.EqualTo(200));
}
```

## 📚 相关资源

- [ASP.NET Core 中间件文档](https://docs.microsoft.com/aspnet/core/fundamentals/middleware/)
- [自定义中间件指南](https://docs.microsoft.com/aspnet/core/fundamentals/middleware/write)
- [异常处理中间件](mdc:Platform.ApiService/Middleware/GlobalExceptionMiddleware.cs)
- [活动日志中间件](mdc:Platform.ApiService/Middleware/ActivityLogMiddleware.cs)
- [响应格式化中间件](mdc:Platform.ApiService/Middleware/ResponseFormattingMiddleware.cs)

## 🎯 核心原则

1. **单一职责** - 每个中间件只负责一个功能
2. **异常安全** - 适当的异常处理和日志记录
3. **性能优先** - 避免阻塞主线程
4. **配置驱动** - 支持配置选项和开关
5. **可测试性** - 设计便于单元测试
6. **顺序重要** - 考虑中间件执行顺序
7. **资源管理** - 正确释放资源
8. **日志记录** - 使用结构化日志