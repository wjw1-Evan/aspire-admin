---
globs: Platform.ApiService/Middleware/*.cs,Platform.ServiceDefaults/Middleware/*.cs
description: 中间件开发规范和最佳实践
---
# 中间件开发规范

## 🎯 核心原则

### 中间件负责横切关注点，提供统一的请求处理、异常处理、日志记录和响应格式化

## ✅ 中间件实现规范

### 全局异常处理中间件

```csharp
// Platform.ApiService/Middleware/GlobalExceptionMiddleware.cs
public class GlobalExceptionMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<GlobalExceptionMiddleware> _logger;

    public GlobalExceptionMiddleware(RequestDelegate next, ILogger<GlobalExceptionMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            await HandleExceptionAsync(context, ex);
        }
    }

    private async Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        var traceId = Activity.Current?.Id ?? context.TraceIdentifier;
        
        _logger.LogError(exception, 
            "Unhandled exception occurred. TraceId: {TraceId}, Path: {Path}", 
            traceId, 
            context.Request.Path);

        var response = exception switch
        {
            ArgumentException => CreateErrorResponse("参数错误", "BAD_REQUEST", StatusCodes.Status400BadRequest, traceId),
            ArgumentNullException => CreateErrorResponse("参数不能为空", "BAD_REQUEST", StatusCodes.Status400BadRequest, traceId),
            KeyNotFoundException => CreateErrorResponse("资源不存在", "NOT_FOUND", StatusCodes.Status404NotFound, traceId),
            UnauthorizedAccessException => CreateErrorResponse("未授权访问", "UNAUTHORIZED", StatusCodes.Status401Unauthorized, traceId),
            InvalidOperationException => CreateErrorResponse("操作失败", "INVALID_OPERATION", StatusCodes.Status400BadRequest, traceId),
            TimeoutException => CreateErrorResponse("请求超时", "TIMEOUT", StatusCodes.Status408RequestTimeout, traceId),
            _ => CreateErrorResponse("服务器内部错误", "INTERNAL_ERROR", StatusCodes.Status500InternalServerError, traceId)
        };

        context.Response.StatusCode = response.StatusCode;
        context.Response.ContentType = "application/json";
        
        await context.Response.WriteAsync(JsonSerializer.Serialize(response.Body));
    }

    private (int StatusCode, object Body) CreateErrorResponse(
        string message, 
        string errorCode, 
        int statusCode,
        string traceId)
    {
        return (statusCode, new
        {
            success = false,
            errorMessage = message,
            errorCode,
            showType = 2, // ERROR_MESSAGE
            traceId,
            timestamp = DateTime.UtcNow
        });
    }
}
```

### 活动日志中间件

```csharp
// Platform.ApiService/Middleware/ActivityLogMiddleware.cs
public class ActivityLogMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ActivityLogMiddleware> _logger;

    public ActivityLogMiddleware(RequestDelegate next, ILogger<ActivityLogMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context, IUserActivityLogService logService)
    {
        var stopwatch = Stopwatch.StartNew();
        var requestId = context.TraceIdentifier;
        
        using (_logger.BeginScope(new Dictionary<string, object>
        {
            ["RequestId"] = requestId,
            ["Method"] = context.Request.Method,
            ["Path"] = context.Request.Path
        }))
        {
            _logger.LogDebug("Processing request {RequestId}", requestId);
            
            try
            {
                await _next(context);
                
                var elapsed = stopwatch.ElapsedMilliseconds;
                _logger.LogInformation("Request {RequestId} completed in {ElapsedMs}ms with status {StatusCode}",
                    requestId, elapsed, context.Response.StatusCode);
                
                // 异步记录活动日志
                _ = Task.Run(async () =>
                {
                    try
                    {
                        await logService.LogActivityAsync(new ActivityLogRequest
                        {
                            RequestId = requestId,
                            Method = context.Request.Method,
                            Path = context.Request.Path.Value ?? "",
                            StatusCode = context.Response.StatusCode,
                            ElapsedMs = elapsed,
                            UserId = GetUserId(context),
                            UserAgent = context.Request.Headers.UserAgent.ToString(),
                            ClientIp = GetClientIp(context)
                        });
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Failed to log activity for request {RequestId}", requestId);
                    }
                });
            }
            catch (Exception ex)
            {
                var elapsed = stopwatch.ElapsedMilliseconds;
                _logger.LogError(ex, "Request {RequestId} failed after {ElapsedMs}ms",
                    requestId, elapsed);
                throw;
            }
        }
    }

    private string? GetUserId(HttpContext context)
    {
        return context.User?.FindFirst("userId")?.Value;
    }

    private string GetClientIp(HttpContext context)
    {
        return context.Connection.RemoteIpAddress?.ToString() ?? "unknown";
    }
}
```

### 响应格式化中间件

```csharp
// Platform.ApiService/Middleware/ResponseFormattingMiddleware.cs
public class ResponseFormattingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ResponseFormattingMiddleware> _logger;

    public ResponseFormattingMiddleware(RequestDelegate next, ILogger<ResponseFormattingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var originalBodyStream = context.Response.Body;
        
        using var responseBody = new MemoryStream();
        context.Response.Body = responseBody;

        try
        {
            await _next(context);
            
            // 只处理成功的响应
            if (context.Response.StatusCode >= 200 && context.Response.StatusCode < 300)
            {
                await FormatSuccessResponse(context);
            }
        }
        finally
        {
            responseBody.Seek(0, SeekOrigin.Begin);
            await responseBody.CopyToAsync(originalBodyStream);
        }
    }

    private async Task FormatSuccessResponse(HttpContext context)
    {
        var responseBody = await ReadResponseBody(context.Response.Body);
        
        if (!string.IsNullOrEmpty(responseBody))
        {
            try
            {
                // 检查是否已经是标准格式
                var existingResponse = JsonSerializer.Deserialize<ApiResponse>(responseBody);
                if (existingResponse != null && existingResponse.Success.HasValue)
                {
                    return; // 已经是标准格式，不需要重新包装
                }
            }
            catch
            {
                // 不是 JSON 格式，继续包装
            }
        }

        // 包装为标准响应格式
        var formattedResponse = new ApiResponse<object>
        {
            Success = true,
            Data = string.IsNullOrEmpty(responseBody) ? null : JsonSerializer.Deserialize<object>(responseBody),
            Timestamp = DateTime.UtcNow
        };

        var jsonResponse = JsonSerializer.Serialize(formattedResponse);
        var bytes = Encoding.UTF8.GetBytes(jsonResponse);
        
        context.Response.ContentType = "application/json";
        context.Response.ContentLength = bytes.Length;
        
        await context.Response.Body.WriteAsync(bytes);
    }

    private async Task<string> ReadResponseBody(Stream body)
    {
        body.Seek(0, SeekOrigin.Begin);
        using var reader = new StreamReader(body, Encoding.UTF8, leaveOpen: true);
        return await reader.ReadToEndAsync();
    }
}
```

### 请求限流中间件

```csharp
// Platform.ApiService/Middleware/RateLimitingMiddleware.cs
public class RateLimitingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IMemoryCache _cache;
    private readonly ILogger<RateLimitingMiddleware> _logger;

    public RateLimitingMiddleware(RequestDelegate next, IMemoryCache cache, ILogger<RateLimitingMiddleware> logger)
    {
        _next = next;
        _cache = cache;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var clientIp = GetClientIp(context);
        var endpoint = $"{context.Request.Method}:{context.Request.Path}";
        var key = $"rate_limit:{clientIp}:{endpoint}";
        
        var requestCount = _cache.GetOrCreate(key, entry =>
        {
            entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(1);
            return 0;
        });

        if (requestCount >= 100) // 每分钟最多100个请求
        {
            _logger.LogWarning("Rate limit exceeded for IP {ClientIp} on endpoint {Endpoint}", 
                clientIp, endpoint);
            
            context.Response.StatusCode = StatusCodes.Status429TooManyRequests;
            context.Response.ContentType = "application/json";
            
            var response = new
            {
                success = false,
                errorMessage = "请求过于频繁，请稍后再试",
                errorCode = "RATE_LIMIT_EXCEEDED",
                showType = 2,
                timestamp = DateTime.UtcNow
            };
            
            await context.Response.WriteAsync(JsonSerializer.Serialize(response));
            return;
        }

        _cache.Set(key, requestCount + 1, TimeSpan.FromMinutes(1));
        
        await _next(context);
    }

    private string GetClientIp(HttpContext context)
    {
        return context.Connection.RemoteIpAddress?.ToString() ?? "unknown";
    }
}
```

## 🎯 中间件注册和配置

### 中间件管道配置

```csharp
// Platform.ApiService/Program.cs
public static void ConfigureMiddlewarePipeline(WebApplication app)
{
    // 1. 异常处理（最外层）
    app.UseMiddleware<GlobalExceptionMiddleware>();
    
    // 2. 请求限流
    app.UseMiddleware<RateLimitingMiddleware>();
    
    // 3. 认证和授权
    app.UseAuthentication();
    app.UseAuthorization();
    
    // 4. 活动日志记录
    app.UseMiddleware<ActivityLogMiddleware>();
    
    // 5. CORS
    app.UseCors();
    
    // 6. 响应格式化
    app.UseMiddleware<ResponseFormattingMiddleware>();
    
    // 7. 控制器
    app.MapControllers();
}
```

### 中间件依赖注入

```csharp
// Platform.ApiService/Program.cs
public static void ConfigureServices(IServiceCollection services)
{
    // 注册中间件依赖的服务
    services.AddScoped<IUserActivityLogService, UserActivityLogService>();
    services.AddMemoryCache();
    
    // 注册中间件
    services.AddScoped<GlobalExceptionMiddleware>();
    services.AddScoped<ActivityLogMiddleware>();
    services.AddScoped<ResponseFormattingMiddleware>();
    services.AddScoped<RateLimitingMiddleware>();
}
```

## 🎯 自定义中间件特性

### 中间件特性

```csharp
// Platform.ApiService/Attributes/SkipMiddlewareAttribute.cs
[AttributeUsage(AttributeTargets.Method | AttributeTargets.Class)]
public class SkipMiddlewareAttribute : Attribute
{
    public Type[] MiddlewareTypes { get; }

    public SkipMiddlewareAttribute(params Type[] middlewareTypes)
    {
        MiddlewareTypes = middlewareTypes;
    }
}

// 使用示例
[SkipMiddleware(typeof(ActivityLogMiddleware))]
public async Task<IActionResult> HealthCheck()
{
    return Success("OK");
}
```

### 中间件条件执行

```csharp
// Platform.ApiService/Middleware/ConditionalMiddleware.cs
public class ConditionalMiddleware
{
    private readonly RequestDelegate _next;
    private readonly Func<HttpContext, bool> _condition;

    public ConditionalMiddleware(RequestDelegate next, Func<HttpContext, bool> condition)
    {
        _next = next;
        _condition = condition;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        if (_condition(context))
        {
            await _next(context);
        }
        else
        {
            // 跳过中间件处理
            await _next(context);
        }
    }
}
```

## 🚫 禁止的做法

### 不要忽略异常处理

```csharp
// ❌ 错误 - 没有异常处理
public async Task InvokeAsync(HttpContext context)
{
    await _next(context); // 异常会直接抛出
}

// ✅ 正确 - 适当的异常处理
public async Task InvokeAsync(HttpContext context)
{
    try
    {
        await _next(context);
    }
    catch (Exception ex)
    {
        await HandleExceptionAsync(context, ex);
    }
}
```

### 不要阻塞请求管道

```csharp
// ❌ 错误 - 同步操作阻塞管道
public async Task InvokeAsync(HttpContext context)
{
    var result = _service.DoSomethingSync(); // 同步操作
    await _next(context);
}

// ✅ 正确 - 异步操作
public async Task InvokeAsync(HttpContext context)
{
    var result = await _service.DoSomethingAsync(); // 异步操作
    await _next(context);
}
```

### 不要忽略性能影响

```csharp
// ❌ 错误 - 每次请求都执行重操作
public async Task InvokeAsync(HttpContext context)
{
    var data = await _database.GetAllDataAsync(); // 每次都查询数据库
    await _next(context);
}

// ✅ 正确 - 使用缓存或条件执行
public async Task InvokeAsync(HttpContext context)
{
    if (ShouldExecute(context))
    {
        var data = await _cache.GetOrCreateAsync("key", async entry =>
        {
            entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(5);
            return await _database.GetAllDataAsync();
        });
    }
    await _next(context);
}
```

## 📋 中间件开发检查清单

创建或修改中间件时检查：

- [ ] 实现正确的中间件接口
- [ ] 添加适当的异常处理
- [ ] 使用异步操作避免阻塞
- [ ] 添加日志记录
- [ ] 考虑性能影响
- [ ] 添加单元测试
- [ ] 配置正确的执行顺序
- [ ] 处理边界情况
- [ ] 添加配置选项
- [ ] 文档化中间件功能

## 📚 相关文档

- [全局异常处理中间件](mdc:Platform.ApiService/Middleware/GlobalExceptionMiddleware.cs)
- [活动日志中间件](mdc:Platform.ApiService/Middleware/ActivityLogMiddleware.cs)
- [响应格式化中间件](mdc:Platform.ApiService/Middleware/ResponseFormattingMiddleware.cs)
- [ASP.NET Core 中间件文档](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/)
