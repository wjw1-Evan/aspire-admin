---
description: 多租户数据隔离开发规范和最佳实践
globs: *.cs,Platform.ApiService/**/*
---

# 多租户数据隔离开发规范

## 🎯 核心原则

**所有业务数据必须归属于特定企业（CompanyId），确保企业间数据完全隔离。**

## 📋 多租户实体类型

### 1. MultiTenantEntity（推荐）
```csharp
// ✅ 推荐：使用 MultiTenantEntity 基类
public class Menu : MultiTenantEntity, INamedEntity
{
    // CompanyId 由基类提供
    public string Name { get; set; }
    public string Title { get; set; }
    // ...
}

public class Permission : MultiTenantEntity
{
    // CompanyId 由基类提供
    public string ResourceName { get; set; }
    public string Action { get; set; }
    // ...
}
```

### 2. 手动添加 CompanyId
```csharp
// ✅ 可选：手动添加 CompanyId 字段
public class Role : ISoftDeletable, INamedEntity, ITimestamped
{
    [BsonElement("companyId")]
    public string CompanyId { get; set; } = string.Empty;  // ✅ 必须有
    
    public string Name { get; set; }
    public string Description { get; set; }
    // ...
}
```

## 🔧 Service 层实现

### BaseService 提供的企业上下文

```csharp
public class MyService : BaseService
{
    public MyService(
        IMongoDatabase database,
        IHttpContextAccessor httpContextAccessor,
        ILogger<MyService> logger)
        : base(database, httpContextAccessor, logger)
    {
    }
    
    // ✅ 使用基类方法获取当前企业ID
    public async Task<Menu> CreateMenuAsync(CreateMenuRequest request)
    {
        var companyId = GetCurrentCompanyId();  // 从 JWT token 获取
        
        var menu = new Menu
        {
            Name = request.Name,
            Title = request.Title,
            CompanyId = companyId,  // ✅ 设置当前企业ID
            // ...
        };
        
        await _repository.CreateAsync(menu);
        return menu;
    }
}
```

### 查询时过滤企业数据

```csharp
// ✅ 正确：查询时过滤企业数据
public async Task<List<Menu>> GetMenusAsync()
{
    var companyId = GetCurrentCompanyId();
    
    var filter = Builders<Menu>.Filter.And(
        Builders<Menu>.Filter.Eq(m => m.CompanyId, companyId),
        SoftDeleteExtensions.NotDeleted<Menu>()
    );
    
    return await _menus.Find(filter).ToListAsync();
}

// ❌ 错误：不过滤企业，会泄露其他企业数据
public async Task<List<Menu>> GetMenusAsync()
{
    return await _menus.Find(_ => true).ToListAsync();  // ❌ 危险！
}
```

### MultiTenantRepository 自动过滤

```csharp
// ✅ 推荐：使用 MultiTenantRepository
public class MenuService : BaseService
{
    private readonly MultiTenantRepository<Menu> _repository;
    
    public MenuService(
        IMongoDatabase database,
        IHttpContextAccessor httpContextAccessor,
        ILogger<MenuService> logger)
        : base(database, httpContextAccessor, logger)
    {
        _repository = new MultiTenantRepository<Menu>(
            database, 
            "menus", 
            httpContextAccessor
        );
    }
    
    // ✅ Repository 自动过滤企业数据
    public async Task<List<Menu>> GetMenusAsync()
    {
        return await _repository.GetAllAsync();  // 自动过滤 CompanyId
    }
}
```

## 🚫 常见错误

### ❌ 错误 1: 创建数据时不设置 CompanyId
```csharp
// ❌ 错误
var menu = new Menu
{
    Name = "dashboard",
    Title = "仪表板"
    // ❌ 缺少 CompanyId
};

// ✅ 正确
var menu = new Menu
{
    Name = "dashboard",
    Title = "仪表板",
    CompanyId = GetCurrentCompanyId()  // ✅ 设置企业ID
};
```

### ❌ 错误 2: 查询时不过滤企业
```csharp
// ❌ 错误：会返回所有企业的数据
var allMenus = await _menus.Find(_ => true).ToListAsync();

// ✅ 正确：只返回当前企业的数据
var companyMenus = await _menus.Find(m => 
    m.CompanyId == GetCurrentCompanyId() && 
    !m.IsDeleted
).ToListAsync();
```

### ❌ 错误 3: 跨企业数据访问
```csharp
// ❌ 错误：直接使用其他企业的数据ID
var menu = await _menus.Find(m => m.Id == menuId).FirstOrDefaultAsync();

// ✅ 正确：验证数据归属
var menu = await _menus.Find(m => 
    m.Id == menuId && 
    m.CompanyId == GetCurrentCompanyId()
).FirstOrDefaultAsync();
```

### ❌ 错误 4: 在系统启动时创建全局数据
```csharp
// ❌ 错误：Program.cs 中创建全局数据
var initialMenuData = new InitialMenuData(database);
await initialMenuData.InitializeAsync();  // 创建的数据没有 CompanyId

// ✅ 正确：在用户注册时创建企业专属数据
// 参考：AuthService.CreatePersonalCompanyAsync()
```

## ✅ 最佳实践

### 1. 使用 MultiTenantEntity 基类
```csharp
public class Notice : MultiTenantEntity
{
    // CompanyId 自动继承
    public string Title { get; set; }
    public string Content { get; set; }
}
```

### 2. 使用 MultiTenantRepository
```csharp
private readonly MultiTenantRepository<Notice> _repository;

public NoticeService(
    IMongoDatabase database,
    IHttpContextAccessor httpContextAccessor,
    ILogger<NoticeService> logger)
    : base(database, httpContextAccessor, logger)
{
    _repository = new MultiTenantRepository<Notice>(
        database, 
        "notices", 
        httpContextAccessor
    );
}

// ✅ 自动过滤企业数据
public async Task<List<Notice>> GetNoticesAsync()
{
    return await _repository.GetAllAsync();
}
```

### 3. 创建数据时自动设置 CompanyId
```csharp
public async Task<Notice> CreateNoticeAsync(CreateNoticeRequest request)
{
    var notice = new Notice
    {
        Title = request.Title,
        Content = request.Content,
        // CompanyId 由 Repository 自动设置（通过 HttpContext）
    };
    
    return await _repository.CreateAsync(notice);
}
```

### 4. 跨企业操作时明确指定
```csharp
// ✅ 超级管理员查看所有企业数据（明确权限检查）
public async Task<List<Menu>> GetAllCompanyMenusAsync()
{
    // 1. 验证超级管理员权限
    await RequirePermissionAsync("system", "admin");
    
    // 2. 明确说明是跨企业查询
    var filter = SoftDeleteExtensions.NotDeleted<Menu>();
    return await _menus.Find(filter).ToListAsync();
}
```

## 🔍 数据隔离验证

### 检查数据归属
```csharp
public async Task<bool> ValidateMenuOwnershipAsync(string menuId)
{
    var companyId = GetCurrentCompanyId();
    var menu = await _menus.Find(m => 
        m.Id == menuId && 
        m.CompanyId == companyId &&
        !m.IsDeleted
    ).FirstOrDefaultAsync();
    
    return menu != null;
}
```

### 数据库查询验证
```javascript
// 检查是否有孤儿数据
db.menus.find({ companyId: { $exists: false } })
db.menus.find({ companyId: "" })
db.menus.find({ companyId: null })

// 检查企业数据隔离
db.menus.find({ companyId: "企业A的ID" })  // 只返回企业A的菜单
db.menus.find({ companyId: "企业B的ID" })  // 只返回企业B的菜单
```

## 📋 代码审查清单

开发多租户功能时，确保：

- [ ] 实体继承 `MultiTenantEntity` 或手动添加 `CompanyId`
- [ ] Service 继承 `BaseService`
- [ ] 使用 `MultiTenantRepository` 或手动过滤 `CompanyId`
- [ ] 创建数据时设置 `CompanyId`
- [ ] 查询数据时过滤 `CompanyId`
- [ ] 更新/删除数据时验证 `CompanyId`
- [ ] 不在系统启动时创建全局数据
- [ ] 跨企业操作时明确权限检查

## 🎯 核心架构

```
用户请求 → JWT Token (含 CompanyId) → BaseService
    ↓
MultiTenantRepository
    ↓
自动过滤 CompanyId → 只返回当前企业数据
```

## 📚 参考实现

- [MultiTenantEntity 基类](mdc:Platform.ApiService/Models/BaseEntity.cs)
- [MultiTenantRepository](mdc:Platform.ApiService/Services/MultiTenantRepository.cs)
- [BaseService](mdc:Platform.ApiService/Services/BaseService.cs)
- [AuthService 注册流程](mdc:Platform.ApiService/Services/AuthService.cs)
- [多租户系统文档](mdc:docs/features/MULTI-TENANT-SYSTEM.md)

## 🎯 核心原则重申

1. **企业隔离** - 所有数据都有 CompanyId
2. **自动过滤** - 使用 MultiTenantRepository 自动过滤
3. **安全验证** - 跨企业操作时验证权限
4. **无全局数据** - 禁止创建没有 CompanyId 的数据
5. **用户注册创建** - 数据在用户注册时自动创建

遵循这些规范，确保多租户系统的数据安全和隔离！
