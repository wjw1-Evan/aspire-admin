---
description: 多租户实体完整设计规范 - 实体设计、字段使用和查询模式
globs: **/*.cs
---

# 多租户实体完整设计规范

## 🎯 核心原则

**区分单一企业关联实体（CompanyId + IMultiTenant）和多企业关联实体（CurrentCompanyId + UserCompany）**

## 📊 实体类型对比表

| 实体类型 | 关联关系 | 使用字段 | 是否实现 IMultiTenant | 过滤方式 |
|---------|---------|---------|---------------------|---------|
| **Role** | 单一企业 | `CompanyId` | ✅ 是 | 自动过滤 |
| **Notice** | 单一企业 | `CompanyId` | ✅ 是 | 自动过滤 |
| **Tag** | 单一企业 | `CompanyId` | ✅ 是 | 自动过滤 |
| **UserActivityLog** | 单一企业 | `CompanyId` | ✅ 是 | 自动过滤 |
| **AppUser** | 多企业 | `CurrentCompanyId` + `PersonalCompanyId` | ❌ 否 | 手动过滤 |
| **UserCompany** | 关联表 | `CompanyId` (关联字段) | ✅ 是 | 自动过滤 |
| **Company** | 独立实体 | 无 | ❌ 否 | 无需过滤 |
| **Menu** | 全局资源 | 无 | ❌ 否 | 无需过滤 |

## ✅ 单一企业关联实体（使用 CompanyId）

### 何时实现 IMultiTenant

以下实体类型**必须**实现 `IMultiTenant` 接口或继承 `MultiTenantEntity`：

```csharp
// ✅ 正确：角色属于单一企业
public class Role : BaseEntity, IEntity, ISoftDeletable, INamedEntity, ITimestamped, IMultiTenant
{
    [BsonElement("companyId")]
    public string CompanyId { get; set; } = string.Empty;  // ✅ 非空，默认空字符串
    
    [BsonElement("name")]
    public string Name { get; set; } = string.Empty;
    
    // ... 其他字段
}

// ✅ 正确：通知属于单一企业
public class Notice : MultiTenantEntity
{
    // CompanyId 由 MultiTenantEntity 提供（非空）
    
    [BsonElement("title")]
    public string Title { get; set; } = string.Empty;
    
    [BsonElement("content")]
    public string Content { get; set; } = string.Empty;
}

// ✅ 正确：标签属于单一企业
public class Tag : MultiTenantEntity
{
    // CompanyId 由 MultiTenantEntity 提供
    
    [BsonElement("name")]
    public string Name { get; set; } = string.Empty;
    
    [BsonElement("color")]
    public string Color { get; set; } = string.Empty;
}
```

### IMultiTenant 接口定义

```csharp
// Platform.ServiceDefaults/Models/BaseEntity.cs

/// <summary>
/// 多租户接口 - 提供企业隔离
/// </summary>
public interface IMultiTenant
{
    /// <summary>
    /// 企业ID（必须非空）
    /// </summary>
    string CompanyId { get; set; }
}

/// <summary>
/// 多租户实体基类 - 包含企业隔离
/// </summary>
public abstract class MultiTenantEntity : BaseEntity, IMultiTenant
{
    [BsonElement("companyId")]
    public string CompanyId { get; set; } = string.Empty;  // ✅ 非空，默认空字符串
}
```

### 工作原理

当实体实现 `IMultiTenant` 接口时，`DatabaseOperationFactory` 会自动为所有查询添加 `CompanyId` 过滤：

```csharp
// Platform.ServiceDefaults/Services/DatabaseOperationFactory.cs

/// <summary>
/// 应用多租户过滤
/// ⚠️ 修复：使用 MongoDB 字段名（从 BsonElement 特性获取）而非 C# 属性名
/// </summary>
private FilterDefinition<T> ApplyTenantFilter(FilterDefinition<T> filter)
{
    // 检查实体是否实现多租户接口
    if (typeof(IMultiTenant).IsAssignableFrom(typeof(T)))
    {
        // ✅ 从数据库读取当前用户的 CurrentCompanyId（不使用 JWT token）
        var companyId = ResolveCurrentCompanyId();
        if (!string.IsNullOrEmpty(companyId))
        {
            var companyIdProperty = typeof(T).GetProperty("CompanyId");
            if (companyIdProperty != null)
            {
                // ✅ 获取 MongoDB 字段名：优先使用 BsonElement 特性，否则使用 camelCase
                var bsonElementAttr = companyIdProperty.GetCustomAttribute<Bson.Serialization.Attributes.BsonElementAttribute>();
                var fieldName = bsonElementAttr?.ElementName ?? "companyId";  // 统一使用小写 camelCase
                
                // ✅ 使用 MongoDB 字段名构建过滤器
                var companyFilter = Builders<T>.Filter.Eq(fieldName, companyId);
                return Builders<T>.Filter.And(filter, companyFilter);
            }
        }
    }
    return filter;
}

/// <summary>
/// 统一解析当前企业ID：统一从数据库 users 集合读取当前用户的 CurrentCompanyId
/// </summary>
private string? ResolveCurrentCompanyId()
{
    try
    {
        // 从数据库读取当前用户的 CurrentCompanyId
        var userId = _tenantContext.GetCurrentUserId();
        if (string.IsNullOrEmpty(userId))
        {
            return null;
        }

        // users 集合（弱类型），仅读取需要的字段
        var users = _database.GetCollection<BsonDocument>("users");
        var projection = Builders<BsonDocument>.Projection.Include("currentCompanyId");
        var doc = users.Find(...).Project(projection).FirstOrDefault();
        var currentCompanyId = doc?.GetValue("currentCompanyId", BsonNull.Value);
        if (currentCompanyId != null && !currentCompanyId.IsBsonNull && currentCompanyId.IsString)
        {
            return currentCompanyId.AsString;
        }
    }
    catch (Exception ex)
    {
        _logger.LogWarning(ex, "ResolveCurrentCompanyId 回退读取失败");
    }

    return null;
}
```

**关键点：**
- ✅ 实现 `IMultiTenant` 的实体会自动应用企业过滤
- ✅ 数据工厂从数据库读取企业ID（不使用 JWT token）
- ✅ 使用正确的 MongoDB 字段名（从 `BsonElement` 特性获取）
- ✅ 查询时无需手动添加 `CompanyId` 过滤条件
- ✅ 创建时使用 `GetRequiredCompanyId()` 设置 `CompanyId`
- ✅ **禁止手动添加 CompanyId 过滤** - 所有实现了 `IMultiTenant` 的实体都应该依赖自动过滤

### 使用示例

```csharp
// ✅ 创建单一企业实体
var role = new Role
{
    Name = "管理员",
    CompanyId = _roleFactory.GetRequiredCompanyId()  // ✅ 必须设置
};
await _roleFactory.CreateAsync(role);

// ✅ 查询单一企业实体（自动过滤）
var roles = await _roleFactory.FindAsync();  // ✅ 自动只返回当前企业的角色

// ❌ 错误：不要手动添加 CompanyId 过滤
var companyId = await GetCurrentCompanyIdAsync();
var filter = _roleFactory.CreateFilterBuilder()
    .Equal(r => r.CompanyId, companyId)  // ❌ 不需要手动添加
    .Build();
var roles = await _roleFactory.FindAsync(filter);  // ❌ 错误做法

// ✅ 正确：依赖自动过滤
var filter = _roleFactory.CreateFilterBuilder()
    .Equal(r => r.IsActive, true)  // ✅ 只添加业务过滤
    .Build();
var roles = await _roleFactory.FindAsync(filter);  // ✅ 数据工厂会自动添加企业过滤
```

## ✅ 多企业关联实体（使用 CurrentCompanyId）

### 何时不实现 IMultiTenant

以下实体类型**不应该**实现 `IMultiTenant` 接口或继承 `MultiTenantEntity`：

```csharp
// ✅ 正确：AppUser 与企业是多对多关系，不实现 IMultiTenant
public class AppUser : BaseEntity, IEntity, ISoftDeletable, ITimestamped
{
    // 注意：AppUser 不支持 IMultiTenant，因为它是多企业模型
    
    [BsonId]
    [BsonRepresentation(BsonType.ObjectId)]
    public string Id { get; set; } = string.Empty;
    
    [BsonElement("username")]
    public string Username { get; set; } = string.Empty;
    
    /// <summary>
    /// 当前选中的企业ID（v3.1新增）
    /// 用于数据隔离和菜单权限
    /// </summary>
    [BsonElement("currentCompanyId")]
    public string? CurrentCompanyId { get; set; }
    
    /// <summary>
    /// 个人企业ID（注册时自动创建，v3.1新增）
    /// </summary>
    [BsonElement("personalCompanyId")]
    public string? PersonalCompanyId { get; set; }
    
    // ❌ 没有 CompanyId 字段
    // 通过 UserCompany 中间表管理多对多关系
}

// ✅ 正确：企业实体本身不需要 CompanyId
public class Company : BaseEntity, IEntity, ISoftDeletable, ITimestamped
{
    // 企业实体本身，不需要 CompanyId
    [BsonElement("name")]
    public string Name { get; set; } = string.Empty;
    
    [BsonElement("code")]
    public string Code { get; set; } = string.Empty;
}

// ✅ 正确：Menu 是全局系统资源（所有企业共享）
public class Menu : BaseEntity, IEntity, ISoftDeletable, ITimestamped
{
    // Menu 没有 CompanyId，因为它是全局资源
    [BsonElement("name")]
    public string Name { get; set; } = string.Empty;
    
    [BsonElement("path")]
    public string Path { get; set; } = string.Empty;
}
```

### 使用示例

```csharp
// ✅ 创建 AppUser（使用 CurrentCompanyId）
var user = new AppUser
{
    Username = "test",
    Email = "test@example.com",
    CurrentCompanyId = companyId,      // ✅ 使用 CurrentCompanyId
    PersonalCompanyId = personalCompanyId
};
await _userFactory.CreateAsync(user);

// ✅ 查询 AppUser（手动添加 CurrentCompanyId 过滤）
var filter = _userFactory.CreateFilterBuilder()
    .Equal(u => u.CurrentCompanyId, currentCompanyId)  // ✅ 手动添加过滤条件
    .Build();
var users = await _userFactory.FindAsync(filter);

// ✅ 通过 UserCompany 关联表查询多企业关系
var userCompanyFilter = _userCompanyFactory.CreateFilterBuilder()
    .Equal(uc => uc.UserId, userId)
    .Equal(uc => uc.CompanyId, companyId)
    .Equal(uc => uc.Status, "active")
    .Build();
var userCompanies = await _userCompanyFactory.FindAsync(userCompanyFilter);
```

## 🚫 禁止的做法

### ❌ 错误 1: AppUser 实现 IMultiTenant

```csharp
// ❌ 错误：AppUser 与企业是多对多关系，不应该实现 IMultiTenant
public class AppUser : MultiTenantEntity
{
    // 这会导致自动过滤冲突
}

// ✅ 正确：使用 BaseEntity，手动通过 CurrentCompanyId 过滤
public class AppUser : BaseEntity
{
    public string? CurrentCompanyId { get; set; }
    public string? PersonalCompanyId { get; set; }
}
```

### ❌ 错误 2: AppUser 使用 CompanyId 查询

```csharp
// ❌ 错误：AppUser 没有 CompanyId 字段
var filter = _userFactory.CreateFilterBuilder()
    .Equal(u => u.CompanyId, companyId)  // ❌ 编译错误
    .Build();

// ✅ 正确：使用 CurrentCompanyId
var filter = _userFactory.CreateFilterBuilder()
    .Equal(u => u.CurrentCompanyId, companyId)  // ✅ 正确
    .Build();
```

### ❌ 错误 3: Role 使用 CurrentCompanyId

```csharp
// ❌ 错误：Role 没有 CurrentCompanyId 字段
var filter = _roleFactory.CreateFilterBuilder()
    .Equal(r => r.CurrentCompanyId, companyId)  // ❌ 编译错误
    .Build();

// ✅ 正确：Role 会自动通过 CompanyId 过滤（实现 IMultiTenant）
var roles = await _roleFactory.FindAsync();  // ✅ 自动过滤当前企业
```

### ❌ 错误 4: CompanyId 设为可空

```csharp
// ❌ 错误：CompanyId 不应该可空
public class Role : IMultiTenant
{
    public string? CompanyId { get; set; }  // ❌ 可空
}

// ✅ 正确：CompanyId 必须非空
public class Role : IMultiTenant
{
    public string CompanyId { get; set; } = string.Empty;  // ✅ 非空
}
```

### ❌ 错误 5: 创建时未设置 CompanyId

```csharp
// ❌ 错误：创建时没有设置 CompanyId
var role = new Role
{
    Name = "管理员",
    // ❌ 缺少 CompanyId
};

// ✅ 正确：创建时设置 CompanyId
var companyId = _roleFactory.GetRequiredCompanyId();
var role = new Role
{
    Name = "管理员",
    CompanyId = companyId  // ✅ 设置企业ID
};
```

## 📋 设计决策检查清单

创建新实体时，按照以下步骤检查：

- [ ] **实体是否属于单一企业？**
  - ✅ 是 → 实现 `IMultiTenant` 或继承 `MultiTenantEntity`
  - ❌ 否 → 不实现 `IMultiTenant`，使用手动过滤

- [ ] **实体是否支持多企业关联？**
  - ✅ 是（如 AppUser）→ 不实现 `IMultiTenant`，使用 `CurrentCompanyId` + `UserCompany`
  - ❌ 否 → 可以实现 `IMultiTenant`

- [ ] **CompanyId 字段是否必须非空？**
  - ✅ 是 → 使用 `string CompanyId { get; set; } = string.Empty;`
  - ❌ 否 → 考虑是否应该实现 `IMultiTenant`

- [ ] **创建时是否设置了正确的企业ID？**
  - ✅ 单一企业实体 → `CompanyId = GetRequiredCompanyId()`
  - ✅ 多企业实体 → `CurrentCompanyId = companyId`

- [ ] **查询时是否正确处理过滤？**
  - ✅ 单一企业实体 → 自动过滤（无需手动添加）
  - ✅ 多企业实体 → 手动添加 `CurrentCompanyId` 过滤

## 🔍 快速参考

```csharp
// ✅ Role（单一企业）
var role = new Role
{
    Name = "管理员",
    CompanyId = _roleFactory.GetRequiredCompanyId()  // ✅ 使用 CompanyId
};
// 查询时自动过滤，无需手动添加 CompanyId 条件

// ✅ AppUser（多企业）
var user = new AppUser
{
    Username = "test",
    CurrentCompanyId = companyId,      // ✅ 使用 CurrentCompanyId
    PersonalCompanyId = personalCompanyId
};
// 查询时需要手动添加 CurrentCompanyId 过滤条件
```

## 📚 相关文档和示例

- [BaseEntity.cs](mdc:Platform.ServiceDefaults/Models/BaseEntity.cs) - IMultiTenant 接口定义
- [RoleModels.cs](mdc:Platform.ApiService/Models/RoleModels.cs) - ✅ 单一企业示例：Role 实现 IMultiTenant
- [AuthModels.cs](mdc:Platform.ApiService/Models/AuthModels.cs) - ✅ 多企业示例：AppUser 不实现 IMultiTenant
- [UserService.cs](mdc:Platform.ApiService/Services/UserService.cs) - CurrentCompanyId 查询示例
- [DatabaseOperationFactory.cs](mdc:Platform.ServiceDefaults/Services/DatabaseOperationFactory.cs) - 自动过滤实现

## 🎯 核心原则总结

1. **单一企业关联** → 使用 `CompanyId` + 实现 `IMultiTenant` → 自动过滤
2. **多企业关联** → 使用 `CurrentCompanyId` + `UserCompany` → 手动过滤
3. **CompanyId 必须非空** → 使用 `string CompanyId { get; set; } = string.Empty;`
4. **创建时设置企业ID** → 确保新创建的实体都设置了正确的企业ID
5. **AppUser 永远不使用 CompanyId** → 只使用 `CurrentCompanyId` 和 `PersonalCompanyId`

遵循这些规范，确保多租户数据隔离的正确性和一致性！
