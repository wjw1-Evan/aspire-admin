---
description: æ€§èƒ½ä¼˜åŒ–å’Œç›‘æ§è§„èŒƒ
globs: *.cs,*.ts,*.tsx,*.js,*.jsx
---

# æ€§èƒ½ä¼˜åŒ–å’Œç›‘æ§è§„èŒƒ

## ğŸ¯ æ ¸å¿ƒåŸåˆ™

**æ€§èƒ½ä¼˜åŒ–åº”è¯¥ä»è®¾è®¡é˜¶æ®µå¼€å§‹ï¼Œé€šè¿‡ç›‘æ§å’Œæµ‹é‡æ¥æŒ‡å¯¼ä¼˜åŒ–å†³ç­–**

## ğŸš€ åç«¯æ€§èƒ½ä¼˜åŒ–

### æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
```csharp
// âœ… æ­£ç¡®ï¼šä½¿ç”¨ç´¢å¼•å’ŒæŠ•å½±
var users = await _users.Find(u => u.CompanyId == companyId)
    .Project(u => new { u.Id, u.Username, u.Email })
    .ToListAsync();

// âŒ é¿å…ï¼šæŸ¥è¯¢æ‰€æœ‰å­—æ®µ
var users = await _users.Find(u => u.CompanyId == companyId).ToListAsync();

// âœ… æ­£ç¡®ï¼šä½¿ç”¨èšåˆç®¡é“
var stats = await _users.Aggregate()
    .Match(u => u.CompanyId == companyId)
    .Group(u => u.RoleId, g => new { RoleId = g.Key, Count = g.Count() })
    .ToListAsync();
```

### ç¼“å­˜ç­–ç•¥
```csharp
// âœ… æ­£ç¡®ï¼šä½¿ç”¨å†…å­˜ç¼“å­˜
public async Task<User> GetUserAsync(string id)
{
    var cacheKey = $"user:{id}";
    if (_cache.TryGetValue(cacheKey, out User cachedUser))
        return cachedUser;

    var user = await _repository.GetByIdAsync(id);
    _cache.Set(cacheKey, user, TimeSpan.FromMinutes(5));
    return user;
}

// âœ… æ­£ç¡®ï¼šä½¿ç”¨åˆ†å¸ƒå¼ç¼“å­˜
public async Task<List<Menu>> GetUserMenusAsync(string userId)
{
    var cacheKey = $"user_menus:{userId}";
    var cachedMenus = await _distributedCache.GetStringAsync(cacheKey);
    
    if (cachedMenus != null)
        return JsonSerializer.Deserialize<List<Menu>>(cachedMenus);

    var menus = await _menuService.GetUserMenusAsync(userId);
    await _distributedCache.SetStringAsync(cacheKey, 
        JsonSerializer.Serialize(menus), 
        new DistributedCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(10)
        });
    
    return menus;
}
```

### å¼‚æ­¥ç¼–ç¨‹æœ€ä½³å®è·µ
```csharp
// âœ… æ­£ç¡®ï¼šä½¿ç”¨ ConfigureAwait(false)
public async Task<List<User>> GetUsersAsync()
{
    var users = await _repository.GetAllAsync().ConfigureAwait(false);
    return users.ToList();
}

// âœ… æ­£ç¡®ï¼šå¹¶è¡Œæ‰§è¡Œç‹¬ç«‹ä»»åŠ¡
public async Task<UserDashboard> GetUserDashboardAsync(string userId)
{
    var userTask = _userService.GetUserAsync(userId);
    var statsTask = _statsService.GetUserStatsAsync(userId);
    var activitiesTask = _activityService.GetRecentActivitiesAsync(userId);

    await Task.WhenAll(userTask, statsTask, activitiesTask);

    return new UserDashboard
    {
        User = await userTask,
        Stats = await statsTask,
        Activities = await activitiesTask
    };
}
```

## ğŸ¨ å‰ç«¯æ€§èƒ½ä¼˜åŒ–

### React ç»„ä»¶ä¼˜åŒ–
```tsx
// âœ… æ­£ç¡®ï¼šä½¿ç”¨ React.memo
const UserCard = React.memo(({ user }: { user: User }) => {
  return (
    <Card>
      <h3>{user.username}</h3>
      <p>{user.email}</p>
    </Card>
  );
});

// âœ… æ­£ç¡®ï¼šä½¿ç”¨ useMemo å’Œ useCallback
const UserList = ({ users, onUserSelect }: UserListProps) => {
  const filteredUsers = useMemo(() => 
    users.filter(user => user.isActive), [users]
  );

  const handleUserClick = useCallback((userId: string) => {
    onUserSelect(userId);
  }, [onUserSelect]);

  return (
    <div>
      {filteredUsers.map(user => (
        <UserCard 
          key={user.id} 
          user={user} 
          onClick={() => handleUserClick(user.id)}
        />
      ))}
    </div>
  );
};
```

### è™šæ‹Ÿæ»šåŠ¨å’Œåˆ†é¡µ
```tsx
// âœ… æ­£ç¡®ï¼šä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨å¤„ç†å¤§é‡æ•°æ®
import { FixedSizeList as List } from 'react-window';

const VirtualizedUserList = ({ users }: { users: User[] }) => {
  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => (
    <div style={style}>
      <UserCard user={users[index]} />
    </div>
  );

  return (
    <List
      height={600}
      itemCount={users.length}
      itemSize={80}
      width="100%"
    >
      {Row}
    </List>
  );
};

// âœ… æ­£ç¡®ï¼šä½¿ç”¨åˆ†é¡µåŠ è½½
const usePaginatedData = <T>(fetchFn: (page: number) => Promise<T[]>) => {
  const [data, setData] = useState<T[]>([]);
  const [loading, setLoading] = useState(false);
  const [page, setPage] = useState(1);

  const loadMore = useCallback(async () => {
    setLoading(true);
    try {
      const newData = await fetchFn(page);
      setData(prev => [...prev, ...newData]);
      setPage(prev => prev + 1);
    } finally {
      setLoading(false);
    }
  }, [fetchFn, page]);

  return { data, loading, loadMore };
};
```

### å›¾ç‰‡å’Œèµ„æºä¼˜åŒ–
```tsx
// âœ… æ­£ç¡®ï¼šä½¿ç”¨æ‡’åŠ è½½
const LazyImage = ({ src, alt }: { src: string; alt: string }) => {
  const [isLoaded, setIsLoaded] = useState(false);
  const [isInView, setIsInView] = useState(false);
  const imgRef = useRef<HTMLImageElement>(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsInView(true);
          observer.disconnect();
        }
      },
      { threshold: 0.1 }
    );

    if (imgRef.current) {
      observer.observe(imgRef.current);
    }

    return () => observer.disconnect();
  }, []);

  return (
    <div ref={imgRef} className="image-container">
      {isInView && (
        <img
          src={src}
          alt={alt}
          onLoad={() => setIsLoaded(true)}
          style={{ opacity: isLoaded ? 1 : 0 }}
        />
      )}
    </div>
  );
};
```

## ğŸ“Š æ€§èƒ½ç›‘æ§

### åç«¯ç›‘æ§
```csharp
// âœ… æ­£ç¡®ï¼šä½¿ç”¨æ€§èƒ½è®¡æ•°å™¨
public class PerformanceMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<PerformanceMiddleware> _logger;

    public async Task InvokeAsync(HttpContext context)
    {
        var stopwatch = Stopwatch.StartNew();
        
        try
        {
            await _next(context);
        }
        finally
        {
            stopwatch.Stop();
            var elapsed = stopwatch.ElapsedMilliseconds;
            
            if (elapsed > 1000) // è¶…è¿‡1ç§’çš„è¯·æ±‚
            {
                _logger.LogWarning("Slow request: {Method} {Path} took {ElapsedMs}ms",
                    context.Request.Method,
                    context.Request.Path,
                    elapsed);
            }
        }
    }
}

// âœ… æ­£ç¡®ï¼šæ•°æ®åº“æŸ¥è¯¢ç›‘æ§
public class DatabasePerformanceService
{
    public async Task<T> ExecuteWithMonitoring<T>(Func<Task<T>> operation, string operationName)
    {
        var stopwatch = Stopwatch.StartNew();
        try
        {
            var result = await operation();
            return result;
        }
        finally
        {
            stopwatch.Stop();
            _logger.LogInformation("Database operation {OperationName} took {ElapsedMs}ms",
                operationName, stopwatch.ElapsedMilliseconds);
        }
    }
}
```

### å‰ç«¯ç›‘æ§
```tsx
// âœ… æ­£ç¡®ï¼šæ€§èƒ½ç›‘æ§ Hook
const usePerformanceMonitor = () => {
  useEffect(() => {
    // ç›‘æ§é¡µé¢åŠ è½½æ—¶é—´
    const navigationStart = performance.timing.navigationStart;
    const loadComplete = performance.timing.loadEventEnd;
    const loadTime = loadComplete - navigationStart;

    if (loadTime > 3000) {
      console.warn(`Page load time: ${loadTime}ms (slow)`);
    }

    // ç›‘æ§èµ„æºåŠ è½½
    const resources = performance.getEntriesByType('resource');
    const slowResources = resources.filter(resource => resource.duration > 1000);
    
    if (slowResources.length > 0) {
      console.warn('Slow resources detected:', slowResources);
    }
  }, []);
};

// âœ… æ­£ç¡®ï¼šAPI è°ƒç”¨æ€§èƒ½ç›‘æ§
const useApiPerformanceMonitor = () => {
  const monitorApiCall = useCallback(async <T>(
    apiCall: () => Promise<T>,
    endpoint: string
  ): Promise<T> => {
    const startTime = performance.now();
    try {
      const result = await apiCall();
      const duration = performance.now() - startTime;
      
      if (duration > 1000) {
        console.warn(`Slow API call: ${endpoint} took ${duration.toFixed(2)}ms`);
      }
      
      return result;
    } catch (error) {
      const duration = performance.now() - startTime;
      console.error(`API call failed: ${endpoint} after ${duration.toFixed(2)}ms`, error);
      throw error;
    }
  }, []);

  return { monitorApiCall };
};
```

## ğŸ”§ æ€§èƒ½ä¼˜åŒ–å·¥å…·

### æ„å»ºä¼˜åŒ–
```json
// Platform.Admin/package.json
{
  "scripts": {
    "build": "umi build",
    "build:analyze": "ANALYZE=1 umi build",
    "build:prod": "cross-env NODE_ENV=production umi build"
  }
}

// webpack é…ç½®ä¼˜åŒ–
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
        common: {
          name: 'common',
          minChunks: 2,
          chunks: 'all',
          enforce: true,
        },
      },
    },
  },
};
```

### æ•°æ®åº“ç´¢å¼•ä¼˜åŒ–
```csharp
// âœ… æ­£ç¡®ï¼šåˆ›å»ºå¤åˆç´¢å¼•
public class CreateUserIndexes : IIndexCreationScript
{
    public async Task CreateIndexesAsync(IMongoDatabase database)
    {
        var users = database.GetCollection<User>("users");
        
        // å¤åˆç´¢å¼•ï¼šCompanyId + IsDeleted + CreatedAt
        await users.Indexes.CreateOneAsync(
            new CreateIndexModel<User>(
                Builders<User>.IndexKeys
                    .Ascending(u => u.CompanyId)
                    .Ascending(u => u.IsDeleted)
                    .Descending(u => u.CreatedAt),
                new CreateIndexOptions
                {
                    Name = "company_deleted_created",
                    Background = true
                }
            )
        );
        
        // æ–‡æœ¬æœç´¢ç´¢å¼•
        await users.Indexes.CreateOneAsync(
            new CreateIndexModel<User>(
                Builders<User>.IndexKeys.Text(u => u.Username).Text(u => u.Email),
                new CreateIndexOptions
                {
                    Name = "user_text_search",
                    Background = true
                }
            )
        );
    }
}
```

## ğŸ“ˆ æ€§èƒ½æŒ‡æ ‡å’Œé˜ˆå€¼

### åç«¯æ€§èƒ½æŒ‡æ ‡
- **API å“åº”æ—¶é—´**: < 200ms (P95)
- **æ•°æ®åº“æŸ¥è¯¢æ—¶é—´**: < 100ms (P95)
- **å†…å­˜ä½¿ç”¨**: < 80% å¯ç”¨å†…å­˜
- **CPU ä½¿ç”¨ç‡**: < 70% å¹³å‡è´Ÿè½½
- **å¹¶å‘è¿æ¥æ•°**: < 1000 æ´»è·ƒè¿æ¥

### å‰ç«¯æ€§èƒ½æŒ‡æ ‡
- **é¦–å±åŠ è½½æ—¶é—´**: < 2s
- **äº¤äº’å“åº”æ—¶é—´**: < 100ms
- **èµ„æºåŠ è½½æ—¶é—´**: < 1s
- **JavaScript åŒ…å¤§å°**: < 500KB (gzipped)
- **å›¾ç‰‡ä¼˜åŒ–**: WebP æ ¼å¼ï¼Œé€‚å½“å‹ç¼©

### ç§»åŠ¨ç«¯æ€§èƒ½æŒ‡æ ‡
- **åº”ç”¨å¯åŠ¨æ—¶é—´**: < 3s
- **é¡µé¢åˆ‡æ¢æ—¶é—´**: < 300ms
- **å†…å­˜ä½¿ç”¨**: < 100MB
- **ç”µæ± æ¶ˆè€—**: ä¼˜åŒ–åå°ä»»åŠ¡

## ğŸ¯ æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥æ¸…å•

### å¼€å‘é˜¶æ®µ
- [ ] ä½¿ç”¨æ€§èƒ½åˆ†æå·¥å…·è¯†åˆ«ç“¶é¢ˆ
- [ ] å®ç°é€‚å½“çš„ç¼“å­˜ç­–ç•¥
- [ ] ä¼˜åŒ–æ•°æ®åº“æŸ¥è¯¢å’Œç´¢å¼•
- [ ] ä½¿ç”¨å¼‚æ­¥ç¼–ç¨‹æ¨¡å¼
- [ ] å®ç°ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½

### æµ‹è¯•é˜¶æ®µ
- [ ] è¿›è¡Œè´Ÿè½½æµ‹è¯•
- [ ] ç›‘æ§å†…å­˜æ³„æ¼
- [ ] æµ‹è¯•å¹¶å‘æ€§èƒ½
- [ ] éªŒè¯ç¼“å­˜æœ‰æ•ˆæ€§
- [ ] æ£€æŸ¥èµ„æºåŠ è½½ä¼˜åŒ–

### éƒ¨ç½²é˜¶æ®µ
- [ ] é…ç½® CDN åŠ é€Ÿ
- [ ] å¯ç”¨ Gzip å‹ç¼©
- [ ] è®¾ç½®é€‚å½“çš„ç¼“å­˜å¤´
- [ ] ç›‘æ§ç”Ÿäº§ç¯å¢ƒæ€§èƒ½
- [ ] è®¾ç½®æ€§èƒ½å‘Šè­¦

## ğŸ“š ç›¸å…³èµ„æº

- [.NET æ€§èƒ½æœ€ä½³å®è·µ](https://docs.microsoft.com/en-us/dotnet/fundamentals/performance/)
- [React æ€§èƒ½ä¼˜åŒ–æŒ‡å—](https://react.dev/learn/render-and-commit)
- [MongoDB æ€§èƒ½ä¼˜åŒ–](https://docs.mongodb.com/manual/core/performance-optimization/)
- [Web æ€§èƒ½ä¼˜åŒ–](https://web.dev/performance/)

## ğŸ¯ è®°ä½

**æ€§èƒ½ä¼˜åŒ–æ˜¯ä¸€ä¸ªæŒç»­çš„è¿‡ç¨‹**

- æµ‹é‡ â†’ åˆ†æ â†’ ä¼˜åŒ– â†’ éªŒè¯
- ä»ç”¨æˆ·ä½“éªŒè§’åº¦æ€è€ƒæ€§èƒ½
- ä½¿ç”¨å·¥å…·å’Œæ•°æ®æŒ‡å¯¼ä¼˜åŒ–å†³ç­–
- å»ºç«‹æ€§èƒ½ç›‘æ§å’Œå‘Šè­¦æœºåˆ¶