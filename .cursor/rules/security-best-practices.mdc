---
description: å®‰å…¨æœ€ä½³å®è·µå’Œæ¼æ´é˜²æŠ¤è§„èŒƒ
globs: *.cs,*.ts,*.tsx,*.js,*.jsx
---

# å®‰å…¨æœ€ä½³å®è·µå’Œæ¼æ´é˜²æŠ¤è§„èŒƒ

## ğŸ¯ æ ¸å¿ƒåŸåˆ™

**å®‰å…¨ä¸æ˜¯åŠŸèƒ½ï¼Œè€Œæ˜¯åŸºç¡€è¦æ±‚ã€‚æ‰€æœ‰ä»£ç éƒ½å¿…é¡»è€ƒè™‘å®‰å…¨æ€§**

## ğŸ” è®¤è¯å’Œæˆæƒå®‰å…¨

### JWT Token å®‰å…¨
```csharp
// âœ… æ­£ç¡®ï¼šå®‰å…¨çš„ JWT é…ç½®
public class JwtSettings
{
    public string SecretKey { get; set; } = string.Empty;
    public string Issuer { get; set; } = string.Empty;
    public string Audience { get; set; } = string.Empty;
    public int ExpirationMinutes { get; set; } = 60;
    public int RefreshTokenExpirationDays { get; set; } = 7;
}

// âœ… æ­£ç¡®ï¼šToken éªŒè¯
public class JwtAuthenticationHandler : AuthenticationHandler<JwtBearerOptions>
{
    protected override async Task<AuthenticateResult> HandleAuthenticateAsync()
    {
        var token = ExtractTokenFromHeader();
        if (string.IsNullOrEmpty(token))
            return AuthenticateResult.Fail("Token not provided");

        try
        {
            var principal = ValidateToken(token);
            var ticket = new AuthenticationTicket(principal, Scheme.Name);
            return AuthenticateResult.Success(ticket);
        }
        catch (SecurityTokenExpiredException)
        {
            return AuthenticateResult.Fail("Token expired");
        }
        catch (SecurityTokenInvalidSignatureException)
        {
            return AuthenticateResult.Fail("Invalid token signature");
        }
    }
}
```

### å¯†ç å®‰å…¨
```csharp
// âœ… æ­£ç¡®ï¼šå®‰å…¨çš„å¯†ç å“ˆå¸Œ
public class PasswordService
{
    private const int SaltSize = 32;
    private const int HashSize = 32;
    private const int Iterations = 100000;

    public string HashPassword(string password)
    {
        using var rng = RandomNumberGenerator.Create();
        var salt = new byte[SaltSize];
        rng.GetBytes(salt);

        using var pbkdf2 = new Rfc2898DeriveBytes(password, salt, Iterations, HashAlgorithmName.SHA256);
        var hash = pbkdf2.GetBytes(HashSize);

        var hashBytes = new byte[SaltSize + HashSize];
        Array.Copy(salt, 0, hashBytes, 0, SaltSize);
        Array.Copy(hash, 0, hashBytes, SaltSize, HashSize);

        return Convert.ToBase64String(hashBytes);
    }

    public bool VerifyPassword(string password, string hashedPassword)
    {
        var hashBytes = Convert.FromBase64String(hashedPassword);
        var salt = new byte[SaltSize];
        Array.Copy(hashBytes, 0, salt, 0, SaltSize);

        using var pbkdf2 = new Rfc2898DeriveBytes(password, salt, Iterations, HashAlgorithmName.SHA256);
        var hash = pbkdf2.GetBytes(HashSize);

        for (int i = 0; i < HashSize; i++)
        {
            if (hashBytes[i + SaltSize] != hash[i])
                return false;
        }
        return true;
    }
}
```

### æƒé™éªŒè¯
```csharp
// âœ… æ­£ç¡®ï¼šç»†ç²’åº¦æƒé™æ£€æŸ¥
[AttributeUsage(AttributeTargets.Method | AttributeTargets.Class)]
public class RequirePermissionAttribute : Attribute, IAuthorizationRequirement
{
    public string Resource { get; }
    public string Action { get; }

    public RequirePermissionAttribute(string resource, string action)
    {
        Resource = resource;
        Action = action;
    }
}

public class PermissionAuthorizationHandler : AuthorizationHandler<RequirePermissionAttribute>
{
    protected override async Task HandleRequirementAsync(
        AuthorizationHandlerContext context,
        RequirePermissionAttribute requirement)
    {
        var user = context.User;
        var userId = user.FindFirst("userId")?.Value;
        
        if (string.IsNullOrEmpty(userId))
        {
            context.Fail();
            return;
        }

        var hasPermission = await CheckUserPermissionAsync(userId, requirement.Resource, requirement.Action);
        
        if (hasPermission)
        {
            context.Succeed(requirement);
        }
        else
        {
            context.Fail();
        }
    }
}
```

## ğŸ›¡ï¸ è¾“å…¥éªŒè¯å’Œé˜²æŠ¤

### SQL æ³¨å…¥é˜²æŠ¤
```csharp
// âœ… æ­£ç¡®ï¼šä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
public async Task<User> GetUserByEmailAsync(string email)
{
    var filter = Builders<User>.Filter.Eq(u => u.Email, email);
    return await _users.Find(filter).FirstOrDefaultAsync();
}

// âŒ ç¦æ­¢ï¼šå­—ç¬¦ä¸²æ‹¼æ¥æŸ¥è¯¢
public async Task<User> GetUserByEmailAsync(string email)
{
    var query = $"SELECT * FROM users WHERE email = '{email}'"; // å±é™©ï¼
    // ...
}
```

### XSS é˜²æŠ¤
```csharp
// âœ… æ­£ç¡®ï¼šè¾“å…¥æ¸…ç†
public class InputSanitizer
{
    private static readonly HtmlSanitizer _sanitizer = new();

    public string SanitizeHtml(string input)
    {
        if (string.IsNullOrEmpty(input))
            return string.Empty;

        return _sanitizer.Sanitize(input);
    }

    public string SanitizeText(string input)
    {
        if (string.IsNullOrEmpty(input))
            return string.Empty;

        return HttpUtility.HtmlEncode(input);
    }
}

// âœ… æ­£ç¡®ï¼šåœ¨æ§åˆ¶å™¨ä¸­ä½¿ç”¨
[HttpPost]
public async Task<IActionResult> CreateNotice([FromBody] CreateNoticeRequest request)
{
    var sanitizedContent = _inputSanitizer.SanitizeHtml(request.Content);
    var sanitizedTitle = _inputSanitizer.SanitizeText(request.Title);
    
    var notice = new Notice
    {
        Title = sanitizedTitle,
        Content = sanitizedContent,
        CompanyId = GetRequiredCompanyId()
    };
    
    await _notices.InsertOneAsync(notice);
    return Success(notice);
}
```

### CSRF é˜²æŠ¤
```csharp
// âœ… æ­£ç¡®ï¼šCSRF Token éªŒè¯
public class CsrfMiddleware
{
    private readonly RequestDelegate _next;

    public async Task InvokeAsync(HttpContext context)
    {
        if (IsStateChangingMethod(context.Request.Method))
        {
            var token = context.Request.Headers["X-CSRF-Token"].FirstOrDefault();
            if (!ValidateCsrfToken(token, context))
            {
                context.Response.StatusCode = 403;
                await context.Response.WriteAsync("CSRF token validation failed");
                return;
            }
        }

        await _next(context);
    }

    private bool IsStateChangingMethod(string method)
    {
        return method == "POST" || method == "PUT" || method == "DELETE" || method == "PATCH";
    }
}
```

## ğŸ”’ æ•°æ®å®‰å…¨

### æ•æ„Ÿæ•°æ®åŠ å¯†
```csharp
// âœ… æ­£ç¡®ï¼šæ•æ„Ÿæ•°æ®åŠ å¯†
public class EncryptionService
{
    private readonly byte[] _key;

    public EncryptionService(IConfiguration configuration)
    {
        var keyString = configuration["Encryption:Key"];
        _key = Convert.FromBase64String(keyString);
    }

    public string Encrypt(string plainText)
    {
        using var aes = Aes.Create();
        aes.Key = _key;
        aes.GenerateIV();

        using var encryptor = aes.CreateEncryptor();
        using var msEncrypt = new MemoryStream();
        using var csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write);
        using var swEncrypt = new StreamWriter(csEncrypt);

        swEncrypt.Write(plainText);
        swEncrypt.Close();

        var encrypted = msEncrypt.ToArray();
        var result = new byte[aes.IV.Length + encrypted.Length];
        Array.Copy(aes.IV, 0, result, 0, aes.IV.Length);
        Array.Copy(encrypted, 0, result, aes.IV.Length, encrypted.Length);

        return Convert.ToBase64String(result);
    }

    public string Decrypt(string cipherText)
    {
        var fullCipher = Convert.FromBase64String(cipherText);
        var iv = new byte[16];
        var cipher = new byte[fullCipher.Length - 16];

        Array.Copy(fullCipher, 0, iv, 0, 16);
        Array.Copy(fullCipher, 16, cipher, 0, cipher.Length);

        using var aes = Aes.Create();
        aes.Key = _key;
        aes.IV = iv;

        using var decryptor = aes.CreateDecryptor();
        using var msDecrypt = new MemoryStream(cipher);
        using var csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read);
        using var srDecrypt = new StreamReader(csDecrypt);

        return srDecrypt.ReadToEnd();
    }
}
```

### å¤šç§Ÿæˆ·æ•°æ®éš”ç¦»
```csharp
// âœ… æ­£ç¡®ï¼šå¼ºåˆ¶ç§Ÿæˆ·éš”ç¦»
public class TenantSecurityService
{
    public void ValidateTenantAccess(string userId, string companyId)
    {
        var userCompany = GetUserCompany(userId);
        if (userCompany != companyId)
        {
            throw new UnauthorizedAccessException("Access denied: User does not belong to this company");
        }
    }

    public async Task<T> FilterByTenant<T>(IQueryable<T> query, string userId) where T : MultiTenantEntity
    {
        var userCompany = await GetUserCompanyAsync(userId);
        return query.Where(x => x.CompanyId == userCompany);
    }
}
```

## ğŸŒ å‰ç«¯å®‰å…¨

### XSS é˜²æŠ¤
```tsx
// âœ… æ­£ç¡®ï¼šä½¿ç”¨ dangerouslySetInnerHTML æ—¶æ¸…ç†
import DOMPurify from 'dompurify';

const SafeHtmlContent = ({ content }: { content: string }) => {
  const sanitizedContent = DOMPurify.sanitize(content);
  
  return (
    <div 
      dangerouslySetInnerHTML={{ __html: sanitizedContent }}
    />
  );
};

// âœ… æ­£ç¡®ï¼šè¾“å…¥éªŒè¯
const validateInput = (input: string): boolean => {
  // æ£€æŸ¥æ˜¯å¦åŒ…å«æ¶æ„è„šæœ¬
  const scriptPattern = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi;
  return !scriptPattern.test(input);
};

// âœ… æ­£ç¡®ï¼šä½¿ç”¨ CSP
const ContentSecurityPolicy = () => {
  useEffect(() => {
    const meta = document.createElement('meta');
    meta.httpEquiv = 'Content-Security-Policy';
    meta.content = "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'";
    document.head.appendChild(meta);
  }, []);

  return null;
};
```

### æ•æ„Ÿä¿¡æ¯å¤„ç†
```tsx
// âœ… æ­£ç¡®ï¼šä¸åœ¨å®¢æˆ·ç«¯å­˜å‚¨æ•æ„Ÿä¿¡æ¯
const useSecureStorage = () => {
  const storeSecureData = useCallback((key: string, data: any) => {
    // åªå­˜å‚¨éæ•æ„Ÿä¿¡æ¯
    const allowedKeys = ['theme', 'language', 'preferences'];
    if (allowedKeys.includes(key)) {
      localStorage.setItem(key, JSON.stringify(data));
    } else {
      console.warn(`Attempted to store sensitive data: ${key}`);
    }
  }, []);

  return { storeSecureData };
};

// âœ… æ­£ç¡®ï¼šAPI å¯†é’¥ç®¡ç†
const useApiKey = () => {
  const [apiKey, setApiKey] = useState<string | null>(null);

  useEffect(() => {
    // ä»ç¯å¢ƒå˜é‡è·å– API å¯†é’¥
    const key = process.env.REACT_APP_API_KEY;
    if (key) {
      setApiKey(key);
    }
  }, []);

  return apiKey;
};
```

## ğŸ” å®‰å…¨ç›‘æ§å’Œæ—¥å¿—

### å®‰å…¨äº‹ä»¶æ—¥å¿—
```csharp
// âœ… æ­£ç¡®ï¼šå®‰å…¨äº‹ä»¶è®°å½•
public class SecurityLogger
{
    private readonly ILogger<SecurityLogger> _logger;

    public void LogLoginAttempt(string username, string ipAddress, bool success)
    {
        _logger.LogInformation("Login attempt: Username={Username}, IP={IP}, Success={Success}",
            username, ipAddress, success);
    }

    public void LogPermissionDenied(string userId, string resource, string action)
    {
        _logger.LogWarning("Permission denied: User={UserId}, Resource={Resource}, Action={Action}",
            userId, resource, action);
    }

    public void LogSuspiciousActivity(string userId, string activity, string details)
    {
        _logger.LogWarning("Suspicious activity: User={UserId}, Activity={Activity}, Details={Details}",
            userId, activity, details);
    }
}
```

### å¼‚å¸¸ç›‘æ§
```csharp
// âœ… æ­£ç¡®ï¼šå®‰å…¨å¼‚å¸¸å¤„ç†
public class SecurityExceptionMiddleware
{
    private readonly RequestDelegate _next;
    private readonly SecurityLogger _securityLogger;

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (UnauthorizedAccessException ex)
        {
            _securityLogger.LogPermissionDenied(
                context.User.FindFirst("userId")?.Value ?? "anonymous",
                context.Request.Path,
                context.Request.Method
            );
            
            context.Response.StatusCode = 403;
            await context.Response.WriteAsync("Access denied");
        }
        catch (SecurityTokenException ex)
        {
            _securityLogger.LogSuspiciousActivity(
                "anonymous",
                "Invalid token",
                ex.Message
            );
            
            context.Response.StatusCode = 401;
            await context.Response.WriteAsync("Invalid token");
        }
    }
}
```

## ğŸš¨ å®‰å…¨æ£€æŸ¥æ¸…å•

### å¼€å‘é˜¶æ®µ
- [ ] æ‰€æœ‰ç”¨æˆ·è¾“å…¥éƒ½ç»è¿‡éªŒè¯å’Œæ¸…ç†
- [ ] ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢é˜²æ­¢ SQL æ³¨å…¥
- [ ] å®ç°é€‚å½“çš„è®¤è¯å’Œæˆæƒ
- [ ] æ•æ„Ÿæ•°æ®åŠ å¯†å­˜å‚¨
- [ ] å®ç° CSRF é˜²æŠ¤
- [ ] é…ç½®å®‰å…¨å¤´ï¼ˆCSPã€HSTS ç­‰ï¼‰

### éƒ¨ç½²é˜¶æ®µ
- [ ] ä½¿ç”¨ HTTPS åŠ å¯†ä¼ è¾“
- [ ] é…ç½®é˜²ç«å¢™å’Œè®¿é—®æ§åˆ¶
- [ ] å®šæœŸæ›´æ–°ä¾èµ–åŒ…
- [ ] ç›‘æ§å®‰å…¨æ—¥å¿—
- [ ] å®æ–½å¤‡ä»½å’Œæ¢å¤ç­–ç•¥
- [ ] è¿›è¡Œå®‰å…¨æ‰«æå’Œæ¸—é€æµ‹è¯•

### è¿ç»´é˜¶æ®µ
- [ ] å®šæœŸå®‰å…¨å®¡è®¡
- [ ] ç›‘æ§å¼‚å¸¸è®¿é—®æ¨¡å¼
- [ ] åŠæ—¶å“åº”å®‰å…¨äº‹ä»¶
- [ ] æ›´æ–°å®‰å…¨ç­–ç•¥
- [ ] åŸ¹è®­å¼€å‘å›¢é˜Ÿå®‰å…¨æ„è¯†

## ğŸ“š ç›¸å…³èµ„æº

- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [.NET å®‰å…¨æœ€ä½³å®è·µ](https://docs.microsoft.com/en-us/aspnet/core/security/)
- [React å®‰å…¨æŒ‡å—](https://react.dev/learn/security)
- [MongoDB å®‰å…¨æŒ‡å—](https://docs.mongodb.com/manual/security/)

## ğŸ¯ è®°ä½

**å®‰å…¨æ˜¯ä¸€ä¸ªæŒç»­çš„è¿‡ç¨‹ï¼Œä¸æ˜¯ä¸€æ¬¡æ€§çš„ä»»åŠ¡**

- ä»è®¾è®¡é˜¶æ®µå°±è€ƒè™‘å®‰å…¨æ€§
- ä½¿ç”¨å®‰å…¨å·¥å…·å’Œåº“
- å®šæœŸè¿›è¡Œå®‰å…¨å®¡è®¡
- ä¿æŒå®‰å…¨æ„è¯†åŸ¹è®­
- åŠæ—¶å“åº”å®‰å…¨å¨èƒ