---
globs: Platform.ApiService/Services/*.cs,Platform.ServiceDefaults/Services/*.cs
description: 安全最佳实践和漏洞防护规范
---
# 安全最佳实践和漏洞防护规范

## 🎯 核心原则

### 通过安全编程实践和漏洞防护确保系统安全，保护用户数据和系统资源

## ✅ 输入验证和过滤

### 参数验证

```csharp
// ✅ 正确 - 完整的参数验证
public class UserService : IUserService
{
    private readonly IDatabaseOperationFactory<User> _userFactory;
    private readonly IFieldValidationService _validationService;

    public UserService(
        IDatabaseOperationFactory<User> userFactory,
        IFieldValidationService validationService)
    {
        _userFactory = userFactory;
        _validationService = validationService;
    }

    public async Task<User> CreateUserAsync(CreateUserRequest request)
    {
        // 1. 参数验证
        if (request == null)
            throw new ArgumentNullException(nameof(request));

        // 2. 业务验证
        await ValidateCreateUserRequestAsync(request);
        
        // 3. 创建用户实体
        var user = new User
        {
            Username = request.Username.Trim(), // 去除空格
            Email = request.Email.Trim().ToLowerInvariant(), // 标准化邮箱
            CompanyId = _userFactory.GetRequiredCompanyId(),
            CreatedBy = _userFactory.GetCurrentUserId(),
            CreatedAt = DateTime.UtcNow
        };
        
        return await _userFactory.CreateAsync(user);
    }

    private async Task ValidateCreateUserRequestAsync(CreateUserRequest request)
    {
        // 1. 用户名验证
        if (string.IsNullOrWhiteSpace(request.Username))
            throw new ArgumentException("用户名不能为空", nameof(request.Username));

        if (request.Username.Length < 3 || request.Username.Length > 50)
            throw new ArgumentException("用户名长度必须在3-50个字符之间", nameof(request.Username));

        if (!IsValidUsername(request.Username))
            throw new ArgumentException("用户名只能包含字母、数字和下划线", nameof(request.Username));

        // 2. 邮箱验证
        if (string.IsNullOrWhiteSpace(request.Email))
            throw new ArgumentException("邮箱不能为空", nameof(request.Email));

        if (!IsValidEmail(request.Email))
            throw new ArgumentException("邮箱格式不正确", nameof(request.Email));

        // 3. 密码验证
        if (string.IsNullOrWhiteSpace(request.Password))
            throw new ArgumentException("密码不能为空", nameof(request.Password));

        if (!IsStrongPassword(request.Password))
            throw new ArgumentException("密码必须包含字母、数字和特殊字符，长度至少8位", nameof(request.Password));

        // 4. 使用验证服务
        await _validationService.ValidateUserAsync(request);
    }

    private bool IsValidUsername(string username)
    {
        // 只允许字母、数字和下划线
        return username.All(c => char.IsLetterOrDigit(c) || c == '_');
    }

    private bool IsValidEmail(string email)
    {
        try
        {
            var addr = new System.Net.Mail.MailAddress(email);
            return addr.Address == email;
        }
        catch
        {
            return false;
        }
    }

    private bool IsStrongPassword(string password)
    {
        if (string.IsNullOrEmpty(password) || password.Length < 8)
            return false;

        var hasLetter = password.Any(char.IsLetter);
        var hasDigit = password.Any(char.IsDigit);
        var hasSpecialChar = password.Any(c => !char.IsLetterOrDigit(c));

        return hasLetter && hasDigit && hasSpecialChar;
    }
}

// ❌ 错误 - 没有输入验证
public class UserService : IUserService
{
    public async Task<User> CreateUserAsync(CreateUserRequest request)
    {
        // 没有验证直接使用输入
        var user = new User
        {
            Username = request.Username,
            Email = request.Email,
            CompanyId = _userFactory.GetRequiredCompanyId(),
            CreatedBy = _userFactory.GetCurrentUserId(),
            CreatedAt = DateTime.UtcNow
        };
        
        return await _userFactory.CreateAsync(user);
    }
}
```

### SQL注入防护

```csharp
// ✅ 正确 - 使用参数化查询
public class UserService : IUserService
{
    public async Task<List<User>> SearchUsersAsync(string keyword)
    {
        // 使用参数化查询防止SQL注入
        var filter = _userFactory.CreateFilterBuilder()
            .Regex(u => u.Username, keyword)
            .Or()
            .Regex(u => u.Email, keyword)
            .Build();

        return await _userFactory.FindAsync(filter);
    }

    public async Task<User?> GetUserByIdAsync(string id)
    {
        // 验证ID格式
        if (string.IsNullOrEmpty(id) || !IsValidObjectId(id))
            throw new ArgumentException("无效的用户ID", nameof(id));

        return await _userFactory.GetByIdAsync(id);
    }

    private bool IsValidObjectId(string id)
    {
        return ObjectId.TryParse(id, out _);
    }
}

// ❌ 错误 - 容易受到SQL注入攻击
public class UserService : IUserService
{
    public async Task<List<User>> SearchUsersAsync(string keyword)
    {
        // 直接拼接字符串（危险）
        var filter = $"{{ \"username\": {{ \"$regex\": \"{keyword}\" }} }}";
        return await _userFactory.FindAsync(filter);
    }
}
```

## 🎯 身份认证和授权

### JWT Token 安全

```csharp
// ✅ 正确 - JWT Token 安全
public class JwtService : IJwtService
{
    private readonly IConfiguration _configuration;
    private readonly ILogger<JwtService> _logger;

    public JwtService(IConfiguration configuration, ILogger<JwtService> logger)
    {
        _configuration = configuration;
        _logger = logger;
    }

    public string GenerateToken(User user)
    {
        var jwtSettings = _configuration.GetSection("JwtSettings").Get<JwtSettings>();
        var key = Encoding.ASCII.GetBytes(jwtSettings.SecretKey);

        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new[]
            {
                new Claim("userId", user.Id),
                new Claim("username", user.Username),
                new Claim("email", user.Email),
                new Claim("companyId", user.CompanyId),
                new Claim("isAdmin", user.IsAdmin.ToString()),
                new Claim("access", user.IsAdmin ? "admin" : "user")
            }),
            Expires = DateTime.UtcNow.AddMinutes(jwtSettings.ExpirationMinutes),
            Issuer = jwtSettings.Issuer,
            Audience = jwtSettings.Audience,
            SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature)
        };

        var tokenHandler = new JwtSecurityTokenHandler();
        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }

    public string GenerateRefreshToken()
    {
        var randomNumber = new byte[32];
        using var rng = RandomNumberGenerator.Create();
        rng.GetBytes(randomNumber);
        return Convert.ToBase64String(randomNumber);
    }

    public ClaimsPrincipal? ValidateToken(string token)
    {
        try
        {
            var jwtSettings = _configuration.GetSection("JwtSettings").Get<JwtSettings>();
            var key = Encoding.ASCII.GetBytes(jwtSettings.SecretKey);

            var tokenHandler = new JwtSecurityTokenHandler();
            var validationParameters = new TokenValidationParameters
            {
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = new SymmetricSecurityKey(key),
                ValidateIssuer = true,
                ValidIssuer = jwtSettings.Issuer,
                ValidateAudience = true,
                ValidAudience = jwtSettings.Audience,
                ValidateLifetime = true,
                ClockSkew = TimeSpan.Zero
            };

            var principal = tokenHandler.ValidateToken(token, validationParameters, out SecurityToken validatedToken);
            return principal;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "JWT Token 验证失败: {Token}", token);
            return null;
        }
    }
}

// ❌ 错误 - JWT Token 不安全
public class JwtService : IJwtService
{
    public string GenerateToken(User user)
    {
        // 使用弱密钥
        var key = Encoding.ASCII.GetBytes("weakkey");
        
        // 没有设置过期时间
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new[]
            {
                new Claim("userId", user.Id)
            }),
            SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature)
        };

        var tokenHandler = new JwtSecurityTokenHandler();
        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }
}
```

### 权限控制

```csharp
// ✅ 正确 - 权限控制
public class UserService : IUserService
{
    private readonly IDatabaseOperationFactory<User> _userFactory;
    private readonly ITenantContext _tenantContext;

    public UserService(
        IDatabaseOperationFactory<User> userFactory,
        ITenantContext tenantContext)
    {
        _userFactory = userFactory;
        _tenantContext = tenantContext;
    }

    public async Task<User> CreateUserAsync(CreateUserRequest request)
    {
        // 1. 检查用户权限
        var currentUserId = _tenantContext.GetRequiredUserId();
        var currentUser = await _userFactory.GetByIdAsync(currentUserId);
        if (currentUser == null || !currentUser.IsActive)
        {
            throw new UnauthorizedAccessException("用户未认证或已停用");
        }

        // 2. 检查企业权限
        var companyId = _tenantContext.GetRequiredCompanyId();
        if (string.IsNullOrEmpty(companyId))
        {
            throw new UnauthorizedAccessException("未找到企业信息");
        }

        // 3. 检查管理员权限
        if (!currentUser.IsAdmin)
        {
            throw new UnauthorizedAccessException("需要管理员权限");
        }

        // 4. 业务逻辑处理
        await ValidateCreateUserRequestAsync(request);
        
        var user = new User
        {
            Username = request.Username.Trim(),
            Email = request.Email.Trim().ToLowerInvariant(),
            CompanyId = companyId,
            CreatedBy = currentUserId,
            CreatedAt = DateTime.UtcNow
        };
        
        return await _userFactory.CreateAsync(user);
    }

    public async Task<bool> DeleteUserAsync(string id)
    {
        // 1. 检查用户权限
        var currentUserId = _tenantContext.GetRequiredUserId();
        var currentUser = await _userFactory.GetByIdAsync(currentUserId);
        if (currentUser == null || !currentUser.IsActive)
        {
            throw new UnauthorizedAccessException("用户未认证或已停用");
        }

        // 2. 检查目标用户
        var targetUser = await _userFactory.GetByIdAsync(id);
        if (targetUser == null)
        {
            throw new KeyNotFoundException($"用户 {id} 不存在");
        }

        // 3. 检查删除权限
        if (!currentUser.IsAdmin && currentUserId != id)
        {
            throw new UnauthorizedAccessException("只能删除自己的账户或需要管理员权限");
        }

        // 4. 检查业务规则
        if (targetUser.IsAdmin)
        {
            throw new InvalidOperationException("无法删除企业管理员");
        }

        // 5. 执行删除
        return await _userFactory.SoftDeleteAsync(id, new OperationContext
        {
            UserId = currentUserId,
            Username = currentUser.Username,
            CompanyId = currentUser.CompanyId,
            OperationType = OperationType.Delete,
            Description = "删除用户"
        });
    }
}

// ❌ 错误 - 没有权限控制
public class UserService : IUserService
{
    public async Task<User> CreateUserAsync(CreateUserRequest request)
    {
        // 没有权限检查
        var user = new User
        {
            Username = request.Username,
            Email = request.Email,
            CompanyId = _userFactory.GetRequiredCompanyId(),
            CreatedBy = _userFactory.GetCurrentUserId(),
            CreatedAt = DateTime.UtcNow
        };
        
        return await _userFactory.CreateAsync(user);
    }
}
```

## 🎯 数据加密和安全

### 密码安全

```csharp
// ✅ 正确 - 密码安全
public class PasswordHasher : IPasswordHasher
{
    private readonly ILogger<PasswordHasher> _logger;

    public PasswordHasher(ILogger<PasswordHasher> logger)
    {
        _logger = logger;
    }

    public string HashPassword(string password)
    {
        if (string.IsNullOrEmpty(password))
            throw new ArgumentException("密码不能为空", nameof(password));

        // 使用 BCrypt 进行密码哈希
        return BCrypt.Net.BCrypt.HashPassword(password, BCrypt.Net.BCrypt.GenerateSalt(12));
    }

    public bool VerifyPassword(string password, string hashedPassword)
    {
        if (string.IsNullOrEmpty(password) || string.IsNullOrEmpty(hashedPassword))
            return false;

        try
        {
            return BCrypt.Net.BCrypt.Verify(password, hashedPassword);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "密码验证失败");
            return false;
        }
    }

    public bool IsPasswordStrong(string password)
    {
        if (string.IsNullOrEmpty(password) || password.Length < 8)
            return false;

        var hasLetter = password.Any(char.IsLetter);
        var hasDigit = password.Any(char.IsDigit);
        var hasSpecialChar = password.Any(c => !char.IsLetterOrDigit(c));

        return hasLetter && hasDigit && hasSpecialChar;
    }
}

// ❌ 错误 - 密码不安全
public class PasswordHasher : IPasswordHasher
{
    public string HashPassword(string password)
    {
        // 使用弱哈希算法
        using var sha256 = SHA256.Create();
        var hashedBytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(password));
        return Convert.ToBase64String(hashedBytes);
    }

    public bool VerifyPassword(string password, string hashedPassword)
    {
        var hashed = HashPassword(password);
        return hashed == hashedPassword;
    }
}
```

### 敏感数据加密

```csharp
// ✅ 正确 - 敏感数据加密
public class EncryptionService : IEncryptionService
{
    private readonly IConfiguration _configuration;
    private readonly ILogger<EncryptionService> _logger;

    public EncryptionService(IConfiguration configuration, ILogger<EncryptionService> logger)
    {
        _configuration = configuration;
        _logger = logger;
    }

    public string Encrypt(string plainText)
    {
        if (string.IsNullOrEmpty(plainText))
            return string.Empty;

        try
        {
            var key = _configuration["Encryption:Key"];
            var iv = _configuration["Encryption:IV"];

            using var aes = Aes.Create();
            aes.Key = Convert.FromBase64String(key);
            aes.IV = Convert.FromBase64String(iv);
            aes.Mode = CipherMode.CBC;
            aes.Padding = PaddingMode.PKCS7;

            using var encryptor = aes.CreateEncryptor();
            using var msEncrypt = new MemoryStream();
            using var csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write);
            using var swEncrypt = new StreamWriter(csEncrypt);

            swEncrypt.Write(plainText);
            swEncrypt.Close();

            return Convert.ToBase64String(msEncrypt.ToArray());
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "数据加密失败");
            throw new InvalidOperationException("数据加密失败", ex);
        }
    }

    public string Decrypt(string cipherText)
    {
        if (string.IsNullOrEmpty(cipherText))
            return string.Empty;

        try
        {
            var key = _configuration["Encryption:Key"];
            var iv = _configuration["Encryption:IV"];

            using var aes = Aes.Create();
            aes.Key = Convert.FromBase64String(key);
            aes.IV = Convert.FromBase64String(iv);
            aes.Mode = CipherMode.CBC;
            aes.Padding = PaddingMode.PKCS7;

            using var decryptor = aes.CreateDecryptor();
            using var msDecrypt = new MemoryStream(Convert.FromBase64String(cipherText));
            using var csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read);
            using var srDecrypt = new StreamReader(csDecrypt);

            return srDecrypt.ReadToEnd();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "数据解密失败");
            throw new InvalidOperationException("数据解密失败", ex);
        }
    }
}

// ❌ 错误 - 敏感数据未加密
public class UserService : IUserService
{
    public async Task<User> CreateUserAsync(CreateUserRequest request)
    {
        var user = new User
        {
            Username = request.Username,
            Email = request.Email,
            // 密码未加密
            Password = request.Password,
            // 手机号未加密
            PhoneNumber = request.PhoneNumber
        };

        return await _userFactory.CreateAsync(user);
    }
}
```

## 🎯 安全日志和监控

### 安全事件记录

```csharp
// ✅ 正确 - 安全事件记录
public class UserService : IUserService
{
    private readonly IDatabaseOperationFactory<User> _userFactory;
    private readonly IAuditService _auditService;
    private readonly ILogger<UserService> _logger;

    public UserService(
        IDatabaseOperationFactory<User> userFactory,
        IAuditService auditService,
        ILogger<UserService> logger)
    {
        _userFactory = userFactory;
        _auditService = auditService;
        _logger = logger;
    }

    public async Task<User> CreateUserAsync(CreateUserRequest request)
    {
        var user = new User
        {
            Username = request.Username,
            Email = request.Email,
            CompanyId = _userFactory.GetRequiredCompanyId(),
            CreatedBy = _userFactory.GetCurrentUserId(),
            CreatedAt = DateTime.UtcNow
        };

        var createdUser = await _userFactory.CreateAsync(user);

        // 记录安全事件
        await _auditService.RecordSecurityEventAsync(new SecurityEvent
        {
            EventType = "UserCreated",
            UserId = _userFactory.GetCurrentUserId(),
            Username = _userFactory.GetCurrentUsername(),
            CompanyId = _userFactory.GetCurrentCompanyId(),
            Description = "创建用户",
            Data = new { Username = request.Username, Email = request.Email },
            Timestamp = DateTime.UtcNow
        });

        _logger.LogInformation("用户创建成功: {UserId}, 操作者: {OperatorId}", 
            createdUser.Id, _userFactory.GetCurrentUserId());

        return createdUser;
    }

    public async Task<bool> DeleteUserAsync(string id)
    {
        var currentUserId = _userFactory.GetRequiredUserId();
        var currentUser = await _userFactory.GetByIdAsync(currentUserId);
        if (currentUser == null || !currentUser.IsActive)
        {
            // 记录安全事件
            await _auditService.RecordSecurityEventAsync(new SecurityEvent
            {
                EventType = "UnauthorizedAccess",
                UserId = currentUserId,
                Username = currentUser?.Username,
                CompanyId = currentUser?.CompanyId,
                Description = "未授权访问尝试",
                Data = new { TargetUserId = id },
                Timestamp = DateTime.UtcNow
            });

            throw new UnauthorizedAccessException("用户未认证或已停用");
        }

        var targetUser = await _userFactory.GetByIdAsync(id);
        if (targetUser == null)
        {
            throw new KeyNotFoundException($"用户 {id} 不存在");
        }

        if (!currentUser.IsAdmin && currentUserId != id)
        {
            // 记录安全事件
            await _auditService.RecordSecurityEventAsync(new SecurityEvent
            {
                EventType = "UnauthorizedAccess",
                UserId = currentUserId,
                Username = currentUser.Username,
                CompanyId = currentUser.CompanyId,
                Description = "未授权删除尝试",
                Data = new { TargetUserId = id },
                Timestamp = DateTime.UtcNow
            });

            throw new UnauthorizedAccessException("只能删除自己的账户或需要管理员权限");
        }

        var result = await _userFactory.SoftDeleteAsync(id, new OperationContext
        {
            UserId = currentUserId,
            Username = currentUser.Username,
            CompanyId = currentUser.CompanyId,
            OperationType = OperationType.Delete,
            Description = "删除用户"
        });

        if (result)
        {
            // 记录安全事件
            await _auditService.RecordSecurityEventAsync(new SecurityEvent
            {
                EventType = "UserDeleted",
                UserId = currentUserId,
                Username = currentUser.Username,
                CompanyId = currentUser.CompanyId,
                Description = "删除用户",
                Data = new { TargetUserId = id, TargetUsername = targetUser.Username },
                Timestamp = DateTime.UtcNow
            });

            _logger.LogInformation("用户删除成功: {TargetUserId}, 操作者: {OperatorId}", 
                id, currentUserId);
        }

        return result;
    }
}

// ❌ 错误 - 没有安全事件记录
public class UserService : IUserService
{
    public async Task<User> CreateUserAsync(CreateUserRequest request)
    {
        var user = new User
        {
            Username = request.Username,
            Email = request.Email
        };

        // 没有记录安全事件
        return await _userFactory.CreateAsync(user);
    }
}
```

## 🚫 禁止的做法

### 不要忽略输入验证

```csharp
// ❌ 错误 - 忽略输入验证
public class UserService : IUserService
{
    public async Task<User> CreateUserAsync(CreateUserRequest request)
    {
        // 没有验证直接使用输入
        var user = new User
        {
            Username = request.Username,
            Email = request.Email,
            Password = request.Password
        };

        return await _userFactory.CreateAsync(user);
    }
}

// ✅ 正确 - 完整的输入验证
public class UserService : IUserService
{
    public async Task<User> CreateUserAsync(CreateUserRequest request)
    {
        // 完整的输入验证
        await ValidateCreateUserRequestAsync(request);
        
        var user = new User
        {
            Username = request.Username.Trim(),
            Email = request.Email.Trim().ToLowerInvariant(),
            PasswordHash = _passwordHasher.HashPassword(request.Password)
        };

        return await _userFactory.CreateAsync(user);
    }
}
```

### 不要硬编码敏感信息

```csharp
// ❌ 错误 - 硬编码敏感信息
public class JwtService : IJwtService
{
    public string GenerateToken(User user)
    {
        // 硬编码密钥
        var key = Encoding.ASCII.GetBytes("hardcoded-secret-key");
        
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new[]
            {
                new Claim("userId", user.Id)
            }),
            Expires = DateTime.UtcNow.AddMinutes(60),
            SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature)
        };

        var tokenHandler = new JwtSecurityTokenHandler();
        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }
}

// ✅ 正确 - 使用配置管理敏感信息
public class JwtService : IJwtService
{
    private readonly IConfiguration _configuration;

    public JwtService(IConfiguration configuration)
    {
        _configuration = configuration;
    }

    public string GenerateToken(User user)
    {
        // 从配置获取密钥
        var jwtSettings = _configuration.GetSection("JwtSettings").Get<JwtSettings>();
        var key = Encoding.ASCII.GetBytes(jwtSettings.SecretKey);
        
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new[]
            {
                new Claim("userId", user.Id)
            }),
            Expires = DateTime.UtcNow.AddMinutes(jwtSettings.ExpirationMinutes),
            SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature)
        };

        var tokenHandler = new JwtSecurityTokenHandler();
        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }
}
```

### 不要忽略权限检查

```csharp
// ❌ 错误 - 忽略权限检查
public class UserService : IUserService
{
    public async Task<bool> DeleteUserAsync(string id)
    {
        // 没有权限检查，任何人都可以删除用户
        return await _userFactory.SoftDeleteAsync(id);
    }
}

// ✅ 正确 - 完整的权限检查
public class UserService : IUserService
{
    public async Task<bool> DeleteUserAsync(string id)
    {
        // 检查用户权限
        var currentUserId = _userFactory.GetRequiredUserId();
        var currentUser = await _userFactory.GetByIdAsync(currentUserId);
        if (currentUser == null || !currentUser.IsAdmin)
        {
            throw new UnauthorizedAccessException("需要管理员权限");
        }

        return await _userFactory.SoftDeleteAsync(id);
    }
}
```

## 📋 安全开发检查清单

创建或修改代码时检查：

- [ ] 输入验证完整
- [ ] 参数过滤正确
- [ ] SQL注入防护
- [ ] 身份认证安全
- [ ] 权限控制正确
- [ ] 密码安全存储
- [ ] 敏感数据加密
- [ ] 安全事件记录
- [ ] 错误处理完善
- [ ] 安全测试通过

## 📚 相关文档

- [用户服务实现](mdc:Platform.ApiService/Services/UserService.cs)
- [角色服务实现](mdc:Platform.ApiService/Services/RoleService.cs)
- [企业服务实现](mdc:Platform.ApiService/Services/CompanyService.cs)
- [安全最佳实践](https://owasp.org/www-project-top-ten/)
