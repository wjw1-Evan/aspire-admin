---
globs: **/contexts/**/*.tsx,**/contexts/**/*.ts,**/hooks/use-*.ts,**/hooks/use-*.tsx
description: çŠ¶æ€ç®¡ç†è§„èŒƒå’Œæœ€ä½³å®è·µ
---

# çŠ¶æ€ç®¡ç†è§„èŒƒ

## ğŸ¯ çŠ¶æ€ç®¡ç†æ¶æ„

### æŠ€æœ¯é€‰å‹

é¡¹ç›®é‡‡ç”¨ React Context + Hooks çš„çŠ¶æ€ç®¡ç†æ–¹æ¡ˆï¼š

- **React Context** - å…¨å±€çŠ¶æ€å…±äº«
- **useReducer** - å¤æ‚çŠ¶æ€é€»è¾‘
- **useState** - ç®€å•ç»„ä»¶çŠ¶æ€
- **è‡ªå®šä¹‰ Hooks** - çŠ¶æ€é€»è¾‘å¤ç”¨

### ä¸ºä»€ä¹ˆä¸ä½¿ç”¨ Redux/Zustand?

- é¡¹ç›®è§„æ¨¡é€‚ä¸­ï¼ŒContext è¶³å¤Ÿ
- å‡å°‘å­¦ä¹ æˆæœ¬å’Œä¾èµ–
- æ›´ç¬¦åˆ React åŸç”Ÿæ€ç»´
- TypeScript ç±»å‹æ”¯æŒæ›´å¥½

## ğŸ“ Context è®¾è®¡æ¨¡å¼

### æ ‡å‡† Context ç»“æ„

```typescript
// âœ… æ¨èï¼šcontexts/AuthContext.tsx
import React, { createContext, useContext, useReducer, useCallback, useMemo } from 'react';
import type { CurrentUser } from '@/types/unified-api';

// 1. å®šä¹‰çŠ¶æ€æ¥å£
interface AuthState {
  isAuthenticated: boolean;
  user: CurrentUser | null;
  token: string | null;
  refreshToken: string | null;
  tokenExpiresAt: number | null;
  loading: boolean;
  error: string | null;
}

// 2. å®šä¹‰ Action ç±»å‹
type AuthAction =
  | { type: 'AUTH_START' }
  | { type: 'AUTH_SUCCESS'; payload: { user: CurrentUser; token: string; refreshToken: string } }
  | { type: 'AUTH_FAILURE'; payload: string }
  | { type: 'AUTH_LOGOUT' }
  | { type: 'AUTH_REFRESH_TOKEN'; payload: { token: string; refreshToken: string; expiresAt?: number } }
  | { type: 'AUTH_UPDATE_USER'; payload: CurrentUser };

// 3. åˆå§‹çŠ¶æ€
const initialState: AuthState = {
  isAuthenticated: false,
  user: null,
  token: null,
  refreshToken: null,
  tokenExpiresAt: null,
  loading: true,
  error: null,
};

// 4. Reducer å‡½æ•°
function authReducer(state: AuthState, action: AuthAction): AuthState {
  switch (action.type) {
    case 'AUTH_START':
      return { ...state, loading: true, error: null };
      
    case 'AUTH_SUCCESS':
      return {
        ...state,
        isAuthenticated: true,
        user: action.payload.user,
        token: action.payload.token,
        refreshToken: action.payload.refreshToken,
        loading: false,
        error: null,
      };
      
    case 'AUTH_FAILURE':
      return {
        ...state,
        isAuthenticated: false,
        user: null,
        token: null,
        refreshToken: null,
        loading: false,
        error: action.payload,
      };
      
    case 'AUTH_LOGOUT':
      return {
        ...initialState,
        loading: false,
      };
      
    case 'AUTH_REFRESH_TOKEN':
      return {
        ...state,
        token: action.payload.token,
        refreshToken: action.payload.refreshToken,
        tokenExpiresAt: action.payload.expiresAt || null,
      };
      
    case 'AUTH_UPDATE_USER':
      return {
        ...state,
        user: action.payload,
      };
      
    default:
      return state;
  }
}

// 5. Context æ¥å£
interface AuthContextValue extends AuthState {
  login: (credentials: LoginRequest) => Promise<void>;
  logout: () => Promise<void>;
  refreshAuth: () => Promise<void>;
  updateUser: (user: CurrentUser) => void;
}

// 6. åˆ›å»º Context
const AuthContext = createContext<AuthContextValue | undefined>(undefined);

// 7. Provider ç»„ä»¶
export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = useReducer(authReducer, initialState);

  // ç™»å½•
  const login = useCallback(async (credentials: LoginRequest) => {
    dispatch({ type: 'AUTH_START' });
    
    try {
      const response = await authService.login(credentials);
      
      if (response.success && response.data) {
        const { token, refreshToken } = response.data;
        
        // è·å–ç”¨æˆ·ä¿¡æ¯
        const userResponse = await authService.getCurrentUser();
        
        if (userResponse.success && userResponse.data) {
          dispatch({
            type: 'AUTH_SUCCESS',
            payload: {
              user: userResponse.data,
              token,
              refreshToken,
            },
          });
        }
      } else {
        dispatch({
          type: 'AUTH_FAILURE',
          payload: response.errorMessage || 'ç™»å½•å¤±è´¥',
        });
      }
    } catch (error) {
      dispatch({
        type: 'AUTH_FAILURE',
        payload: error instanceof Error ? error.message : 'ç™»å½•å¤±è´¥',
      });
    }
  }, []);

  // ç™»å‡º
  const logout = useCallback(async () => {
    try {
      await authService.logout();
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      dispatch({ type: 'AUTH_LOGOUT' });
    }
  }, []);

  // åˆ·æ–°è®¤è¯
  const refreshAuth = useCallback(async () => {
    try {
      if (state.refreshToken) {
        const refreshResult = await authService.refreshToken(state.refreshToken);
        
        if (refreshResult.success && refreshResult.data) {
          const { token, refreshToken, expiresAt } = refreshResult.data;
          const tokenExpiresAt = expiresAt ? new Date(expiresAt).getTime() : undefined;
          
          dispatch({
            type: 'AUTH_REFRESH_TOKEN',
            payload: { token, refreshToken, expiresAt: tokenExpiresAt },
          });
        } else {
          await logout();
        }
      }
    } catch (error) {
      console.error('Refresh auth failed:', error);
      await logout();
    }
  }, [state.refreshToken, logout]);

  // æ›´æ–°ç”¨æˆ·ä¿¡æ¯
  const updateUser = useCallback((user: CurrentUser) => {
    dispatch({ type: 'AUTH_UPDATE_USER', payload: user });
  }, []);

  // ä½¿ç”¨ useMemo ä¼˜åŒ–æ€§èƒ½
  const value = useMemo(
    () => ({
      ...state,
      login,
      logout,
      refreshAuth,
      updateUser,
    }),
    [state, login, logout, refreshAuth, updateUser]
  );

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

// 8. è‡ªå®šä¹‰ Hook
export function useAuth() {
  const context = useContext(AuthContext);
  
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  
  return context;
}
```

### ä¸»é¢˜ Context ç¤ºä¾‹

```typescript
// âœ… æ¨èï¼šcontexts/ThemeContext.tsx
import React, { createContext, useContext, useState, useEffect, useMemo } from 'react';
import { useColorScheme } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';

export type ThemeMode = 'light' | 'dark' | 'system';

interface ThemeContextValue {
  themeMode: ThemeMode;
  isDark: boolean;
  setThemeMode: (mode: ThemeMode) => void;
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextValue | undefined>(undefined);

const THEME_STORAGE_KEY = 'theme_mode';

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const systemColorScheme = useColorScheme();
  const [themeMode, setThemeModeState] = useState<ThemeMode>('system');

  // åŠ è½½ä¿å­˜çš„ä¸»é¢˜åå¥½
  useEffect(() => {
    const loadTheme = async () => {
      try {
        const savedTheme = await AsyncStorage.getItem(THEME_STORAGE_KEY);
        if (savedTheme && ['light', 'dark', 'system'].includes(savedTheme)) {
          setThemeModeState(savedTheme as ThemeMode);
        }
      } catch (error) {
        console.error('Failed to load theme:', error);
      }
    };
    
    loadTheme();
  }, []);

  // è®¡ç®—å®é™…çš„æš—è‰²æ¨¡å¼çŠ¶æ€
  const isDark = useMemo(() => {
    if (themeMode === 'system') {
      return systemColorScheme === 'dark';
    }
    return themeMode === 'dark';
  }, [themeMode, systemColorScheme]);

  // è®¾ç½®ä¸»é¢˜æ¨¡å¼
  const setThemeMode = useCallback(async (mode: ThemeMode) => {
    try {
      await AsyncStorage.setItem(THEME_STORAGE_KEY, mode);
      setThemeModeState(mode);
    } catch (error) {
      console.error('Failed to save theme:', error);
    }
  }, []);

  // åˆ‡æ¢ä¸»é¢˜
  const toggleTheme = useCallback(() => {
    const newMode = isDark ? 'light' : 'dark';
    setThemeMode(newMode);
  }, [isDark, setThemeMode]);

  const value = useMemo(
    () => ({ themeMode, isDark, setThemeMode, toggleTheme }),
    [themeMode, isDark, setThemeMode, toggleTheme]
  );

  return <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>;
}

export function useTheme() {
  const context = useContext(ThemeContext);
  
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  
  return context;
}
```

## ğŸ£ è‡ªå®šä¹‰ Hooks

### æ•°æ®è·å– Hook

```typescript
// âœ… æ¨èï¼šhooks/use-users.ts
import { useState, useEffect, useCallback } from 'react';
import { UserService } from '@/services/UserService';
import type { User } from '@/types/api';

export function useUsers() {
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchUsers = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const data = await UserService.getUsers();
      setUsers(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'è·å–ç”¨æˆ·åˆ—è¡¨å¤±è´¥');
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchUsers();
  }, [fetchUsers]);

  return { users, loading, error, refetch: fetchUsers };
}
```

### è¡¨å• Hook

```typescript
// âœ… æ¨èï¼šhooks/use-form.ts
import { useState, useCallback } from 'react';

export function useForm<T extends Record<string, any>>(
  initialValues: T,
  onSubmit: (values: T) => Promise<void>
) {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});
  const [submitting, setSubmitting] = useState(false);

  const handleChange = useCallback((name: keyof T, value: any) => {
    setValues((prev) => ({ ...prev, [name]: value }));
    // æ¸…é™¤å­—æ®µé”™è¯¯
    if (errors[name]) {
      setErrors((prev) => {
        const newErrors = { ...prev };
        delete newErrors[name];
        return newErrors;
      });
    }
  }, [errors]);

  const handleSubmit = useCallback(async () => {
    setSubmitting(true);
    setErrors({});

    try {
      await onSubmit(values);
    } catch (error) {
      if (error instanceof Error) {
        setErrors({ general: error.message } as any);
      }
    } finally {
      setSubmitting(false);
    }
  }, [values, onSubmit]);

  const reset = useCallback(() => {
    setValues(initialValues);
    setErrors({});
  }, [initialValues]);

  return {
    values,
    errors,
    submitting,
    handleChange,
    handleSubmit,
    reset,
  };
}
```

### æƒé™ Hook

```typescript
// âœ… æ¨èï¼šhooks/use-permissions.ts
import { useCallback } from 'react';
import { useAuth } from '@/contexts/AuthContext';

export interface PermissionCheck {
  access?: string;
  role?: string;
  roles?: string[];
}

export function usePermissions() {
  const { user, isAuthenticated } = useAuth();

  const checkPermission = useCallback(
    (check: PermissionCheck): boolean => {
      if (!isAuthenticated || !user) {
        return false;
      }

      const { access, role, roles } = check;

      // æ£€æŸ¥å•ä¸ªè§’è‰²
      if (role && user.access === role) {
        return true;
      }

      // æ£€æŸ¥å¤šä¸ªè§’è‰²
      if (roles && roles.includes(user.access)) {
        return true;
      }

      // æ£€æŸ¥æƒé™ï¼ˆåŸºäº access å­—æ®µï¼‰
      if (access && user.access === access) {
        return true;
      }

      return false;
    },
    [user, isAuthenticated]
  );

  const checkRole = useCallback(
    (role: string): boolean => {
      return checkPermission({ role });
    },
    [checkPermission]
  );

  const checkAllRoles = useCallback(
    (roles: string[]): boolean => {
      return roles.every((role) => checkRole(role));
    },
    [checkRole]
  );

  return {
    checkPermission,
    checkRole,
    checkAllRoles,
    user,
    isAuthenticated,
  };
}
```

## ğŸ”„ çŠ¶æ€æ›´æ–°æ¨¡å¼

### ä¸å¯å˜æ›´æ–°

```typescript
// âœ… æ¨èï¼šä¸å¯å˜çŠ¶æ€æ›´æ–°
// æ›´æ–°å¯¹è±¡
setUser((prev) => ({ ...prev, name: 'New Name' }));

// æ›´æ–°æ•°ç»„ - æ·»åŠ 
setItems((prev) => [...prev, newItem]);

// æ›´æ–°æ•°ç»„ - åˆ é™¤
setItems((prev) => prev.filter((item) => item.id !== id));

// æ›´æ–°æ•°ç»„ - ä¿®æ”¹
setItems((prev) =>
  prev.map((item) => (item.id === id ? { ...item, ...updates } : item))
);

// âŒ é¿å…ï¼šç›´æ¥ä¿®æ”¹çŠ¶æ€
user.name = 'New Name'; // é”™è¯¯
items.push(newItem); // é”™è¯¯
```

### æ‰¹é‡æ›´æ–°

```typescript
// âœ… æ¨èï¼šä½¿ç”¨ useReducer æ‰¹é‡æ›´æ–°
function dataReducer(state: DataState, action: DataAction): DataState {
  switch (action.type) {
    case 'FETCH_START':
      return { ...state, loading: true, error: null };
      
    case 'FETCH_SUCCESS':
      return {
        ...state,
        data: action.payload,
        loading: false,
        error: null,
        lastUpdated: Date.now(),
      };
      
    case 'FETCH_FAILURE':
      return { ...state, loading: false, error: action.payload };
      
    default:
      return state;
  }
}
```

## ğŸ“± æ€§èƒ½ä¼˜åŒ–

### useMemo å’Œ useCallback

```typescript
// âœ… æ¨èï¼šæ­£ç¡®ä½¿ç”¨ useMemo å’Œ useCallback
function UserList({ users }: { users: User[] }) {
  // ç¼“å­˜è®¡ç®—ç»“æœ
  const sortedUsers = useMemo(() => {
    return [...users].sort((a, b) => a.name.localeCompare(b.name));
  }, [users]);

  // ç¼“å­˜å›è°ƒå‡½æ•°
  const handleEdit = useCallback((user: User) => {
    console.log('Edit user:', user);
  }, []);

  return (
    <FlatList
      data={sortedUsers}
      renderItem={({ item }) => (
        <UserCard user={item} onEdit={handleEdit} />
      )}
      keyExtractor={(item) => item.id}
    />
  );
}
```

### Context æ€§èƒ½ä¼˜åŒ–

```typescript
// âœ… æ¨èï¼šæ‹†åˆ† Context é¿å…ä¸å¿…è¦çš„é‡æ¸²æŸ“
// å°†é¢‘ç¹å˜åŒ–çš„çŠ¶æ€å’Œä¸å¸¸å˜åŒ–çš„çŠ¶æ€åˆ†å¼€

// ç”¨æˆ·ä¿¡æ¯ Contextï¼ˆä¸å¸¸å˜åŒ–ï¼‰
const UserContext = createContext<User | null>(null);

// ä¸»é¢˜ Contextï¼ˆå¯èƒ½é¢‘ç¹å˜åŒ–ï¼‰
const ThemeContext = createContext<ThemeContextValue | undefined>(undefined);

// âŒ é¿å…ï¼šæ‰€æœ‰çŠ¶æ€éƒ½æ”¾åœ¨ä¸€ä¸ª Context ä¸­
// const AppContext = createContext<{ user, theme, ... }>(...)
```

## ğŸš« é¿å…çš„åšæ³•

- ä¸è¦åœ¨æ¸²æŸ“å‡½æ•°ä¸­åˆ›å»ºæ–°çš„ Context Provider
- ä¸è¦å¿˜è®°ä½¿ç”¨ useMemo ä¼˜åŒ– Context value
- ä¸è¦è¿‡åº¦ä½¿ç”¨ Contextï¼Œç®€å•çŠ¶æ€ç”¨ props
- ä¸è¦åœ¨ç»„ä»¶å¤–éƒ¨ç›´æ¥ä¿®æ”¹çŠ¶æ€
- ä¸è¦å¿˜è®°æ¸…ç†å‰¯ä½œç”¨ï¼ˆuseEffect çš„æ¸…ç†å‡½æ•°ï¼‰

## ğŸ”§ æœ€ä½³å®è·µ

1. **Context + Hooks** - ä½¿ç”¨ Context å’Œ Hooks ç®¡ç†å…¨å±€çŠ¶æ€
2. **åˆç†æ‹†åˆ†** - æŒ‰åŠŸèƒ½æ‹†åˆ†ä¸åŒçš„ Context
3. **ç±»å‹å®‰å…¨** - ä½¿ç”¨ TypeScript ç¡®ä¿ç±»å‹å®‰å…¨
4. **æ€§èƒ½ä¼˜åŒ–** - ä½¿ç”¨ useMemo å’Œ useCallback ä¼˜åŒ–æ€§èƒ½
5. **ä¸å¯å˜æ›´æ–°** - å§‹ç»ˆä»¥ä¸å¯å˜çš„æ–¹å¼æ›´æ–°çŠ¶æ€
6. **é”™è¯¯å¤„ç†** - åœ¨ Context ä¸­å¤„ç†é”™è¯¯çŠ¶æ€
7. **æŒä¹…åŒ–** - ä½¿ç”¨ AsyncStorage æŒä¹…åŒ–é‡è¦çŠ¶æ€
8. **åˆå§‹åŒ–** - åœ¨åº”ç”¨å¯åŠ¨æ—¶æ¢å¤æŒä¹…åŒ–çŠ¶æ€

## ğŸ“š ç›¸å…³èµ„æº

- [React Context æ–‡æ¡£](https://react.dev/reference/react/createContext)
- [React Hooks æ–‡æ¡£](https://react.dev/reference/react)
- [useReducer æ–‡æ¡£](https://react.dev/reference/react/useReducer)

