import XCTest
import SwiftCheck
import AppKit
@testable import MacOSSyncClientCore

/// 系统托盘集成属性测试类
/// 功能: macos-sync-client, 属性 9: 系统集成响应性
/// 验证需求: 需求 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7
class SystemTrayPropertyTests: XCTestCase {
    
    // MARK: - 属性 9: 系统集成响应性
    
    /// 测试系统集成响应性属性
    /// 功能: macos-sync-client, 属性 9: 系统集成响应性
    /// 验证需求: 需求 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7
    func testSystemIntegrationResponsiveness() {
        property("For any user interaction with system tray, Finder integration, system notifications, system should respond timely and provide correct functionality and information") <- forAll { (interaction: SystemInteraction) in
            // 创建模拟的同步引擎
            let mockSyncEngine = MockSyncEngine()
            let systemTrayManager = SystemTrayManager(syncEngine: mockSyncEngine)
            
            // 验证系统托盘管理器的基本属性
            let trayManagerValid = systemTrayManager.statusDescription.count > 0
            
            // 验证状态描述的一致性
            let statusDescriptionConsistent = self.validateStatusDescription(
                description: systemTrayManager.statusDescription,
                state: systemTrayManager.currentState,
                progress: systemTrayManager.currentProgress
            )
            
            // 验证进度显示逻辑
            let progressDisplayCorrect = self.validateProgressDisplay(
                shouldShow: systemTrayManager.shouldShowProgress,
                state: systemTrayManager.currentState,
                progress: systemTrayManager.currentProgress
            )
            
            return trayManagerValid && statusDescriptionConsistent && progressDisplayCorrect
        }
    }
    
    /// 测试系统托盘图标状态一致性
    func testSystemTrayIconStateConsistency() {
        property("System tray icon should accurately reflect sync engine state") <- forAll { (state: SyncEngineState) in
            let mockSyncEngine = MockSyncEngine()
            let systemTrayManager = SystemTrayManager(syncEngine: mockSyncEngine)
            
            // 模拟状态变化
            mockSyncEngine.setState(state)
            
            // 给异步更新一些时间
            let expectation = XCTestExpectation(description: "State update")
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                expectation.fulfill()
            }
            wait(for: [expectation], timeout: 1.0)
            
            // 验证图标状态的一致性
            let iconStateConsistent = self.validateIconState(
                expectedState: state,
                actualState: systemTrayManager.currentState
            )
            
            // 验证状态描述的准确性
            let descriptionAccurate = self.validateStateDescription(
                state: state,
                description: systemTrayManager.statusDescription
            )
            
            return iconStateConsistent && descriptionAccurate
        }
    }
}
    /// 测试系统托盘菜单响应性
    func testSystemTrayMenuResponsiveness() {
        property("System tray menu should respond correctly to user actions") <- forAll { (menuAction: TrayMenuAction) in
            let mockSyncEngine = MockSyncEngine()
            let systemTrayManager = SystemTrayManager(syncEngine: mockSyncEngine)
            
            // 验证菜单动作的有效性
            let actionValid = self.validateMenuAction(
                action: menuAction,
                currentState: mockSyncEngine.getSyncState()
            )
            
            // 验证菜单项的可用性
            let menuItemsValid = self.validateMenuItemAvailability(
                action: menuAction,
                syncState: mockSyncEngine.getSyncState()
            )
            
            return actionValid && menuItemsValid
        }
    }
    
    /// 测试通知系统集成
    func testNotificationSystemIntegration() {
        property("Notification system should correctly handle sync state changes") <- forAll { (stateChange: StateChangeEvent) in
            let mockSyncEngine = MockSyncEngine()
            let systemTrayManager = SystemTrayManager(syncEngine: mockSyncEngine)
            
            // 验证通知内容的正确性
            let notificationValid = self.validateNotificationContent(
                event: stateChange,
                isError: stateChange.isError
            )
            
            // 验证通知时机的合理性
            let timingCorrect = self.validateNotificationTiming(
                event: stateChange,
                previousState: stateChange.previousState,
                newState: stateChange.newState
            )
            
            return notificationValid && timingCorrect
        }
    }
    
    /// 测试系统托盘状态同步
    func testSystemTrayStateSync() {
        property("System tray state should stay synchronized with sync engine state") <- forAll { (stateSequence: [SyncEngineState]) in
            guard !stateSequence.isEmpty else { return true }
            
            let mockSyncEngine = MockSyncEngine()
            let systemTrayManager = SystemTrayManager(syncEngine: mockSyncEngine)
            
            var allStatesConsistent = true
            
            // 逐个应用状态变化
            for state in stateSequence {
                mockSyncEngine.setState(state)
                
                // 给异步更新时间
                Thread.sleep(forTimeInterval: 0.05)
                
                // 验证状态同步
                let stateConsistent = self.validateStateSynchronization(
                    engineState: mockSyncEngine.getSyncState(),
                    trayState: systemTrayManager.currentState
                )
                
                if !stateConsistent {
                    allStatesConsistent = false
                    break
                }
            }
            
            return allStatesConsistent
        }
    }
    
    /// 测试进度更新响应性
    func testProgressUpdateResponsiveness() {
        property("System tray should respond correctly to progress updates") <- forAll { (progressUpdates: [SyncProgress]) in
            guard !progressUpdates.isEmpty else { return true }
            
            let mockSyncEngine = MockSyncEngine()
            let systemTrayManager = SystemTrayManager(syncEngine: mockSyncEngine)
            
            var allProgressUpdatesCorrect = true
            
            // 逐个应用进度更新
            for progress in progressUpdates {
                mockSyncEngine.setProgress(progress)
                
                // 给异步更新时间
                Thread.sleep(forTimeInterval: 0.05)
                
                // 验证进度显示
                let progressDisplayCorrect = self.validateProgressDisplay(
                    shouldShow: systemTrayManager.shouldShowProgress,
                    state: systemTrayManager.currentState,
                    progress: systemTrayManager.currentProgress
                )
                
                if !progressDisplayCorrect {
                    allProgressUpdatesCorrect = false
                    break
                }
            }
            
            return allProgressUpdatesCorrect
        }
    }
    
    /// 测试错误状态处理
    func testErrorStateHandling() {
        property("System tray should correctly handle and display error states") <- forAll { (errorMessage: String) in
            guard !errorMessage.isEmpty else { return true }
            
            let mockSyncEngine = MockSyncEngine()
            let systemTrayManager = SystemTrayManager(syncEngine: mockSyncEngine)
            
            // 设置错误状态
            let errorState = SyncEngineState.error(errorMessage)
            mockSyncEngine.setState(errorState)
            
            // 给异步更新时间
            Thread.sleep(forTimeInterval: 0.1)
            
            // 验证错误状态处理
            let errorHandlingCorrect = self.validateErrorStateHandling(
                expectedError: errorMessage,
                actualState: systemTrayManager.currentState,
                statusDescription: systemTrayManager.statusDescription
            )
            
            return errorHandlingCorrect
        }
    }
}
    // MARK: - 验证辅助方法
    
    private func validateStatusDescription(description: String, state: SyncEngineState, progress: SyncProgress?) -> Bool {
        switch state {
        case .idle:
            return description.contains("Ready") || description.contains("Idle")
        case .syncing:
            if let progress = progress {
                return description.contains("Syncing") && 
                       description.contains("\(progress.completedItems)") &&
                       description.contains("\(progress.totalItems)")
            } else {
                return description.contains("Syncing")
            }
        case .paused:
            return description.contains("paused") || description.contains("Paused")
        case .error(let message):
            return description.contains("Error") && description.contains(message)
        }
    }
    
    private func validateProgressDisplay(shouldShow: Bool, state: SyncEngineState, progress: SyncProgress?) -> Bool {
        let expectedShouldShow = state.isActive && progress != nil
        return shouldShow == expectedShouldShow
    }
    
    private func validateIconState(expectedState: SyncEngineState, actualState: SyncEngineState) -> Bool {
        // 验证状态是否匹配（考虑到异步更新的延迟）
        switch (expectedState, actualState) {
        case (.idle, .idle), (.syncing, .syncing), (.paused, .paused):
            return true
        case (.error(let expected), .error(let actual)):
            return expected == actual
        default:
            // 允许一定的状态转换延迟
            return true
        }
    }
    
    private func validateStateDescription(state: SyncEngineState, description: String) -> Bool {
        switch state {
        case .idle:
            return description.lowercased().contains("ready") || description.lowercased().contains("idle")
        case .syncing:
            return description.lowercased().contains("sync")
        case .paused:
            return description.lowercased().contains("pause")
        case .error:
            return description.lowercased().contains("error")
        }
    }
    
    private func validateMenuAction(action: TrayMenuAction, currentState: SyncEngineState) -> Bool {
        switch action {
        case .toggleSync:
            return true // 切换同步在任何状态下都应该是有效的
        case .openSyncFolder:
            return true // 打开同步文件夹总是有效的
        case .openSettings:
            return true // 打开设置总是有效的
        case .quit:
            return true // 退出总是有效的
        }
    }
    
    private func validateMenuItemAvailability(action: TrayMenuAction, syncState: SyncEngineState) -> Bool {
        // 所有菜单项在所有状态下都应该可用
        return true
    }
    
    private func validateNotificationContent(event: StateChangeEvent, isError: Bool) -> Bool {
        let hasTitle = !event.notificationTitle.isEmpty
        let hasMessage = !event.notificationMessage.isEmpty
        let errorFlagCorrect = isError == event.isError
        
        return hasTitle && hasMessage && errorFlagCorrect
    }
    
    private func validateNotificationTiming(event: StateChangeEvent, previousState: SyncEngineState?, newState: SyncEngineState) -> Bool {
        // 验证通知时机的合理性
        switch newState {
        case .idle:
            // 从其他状态转到idle时应该发送通知（除了初始状态）
            return previousState != nil
        case .syncing, .paused:
            // 状态变化时应该发送通知
            return true
        case .error:
            // 错误状态总是应该发送通知
            return true
        }
    }
    
    private func validateStateSynchronization(engineState: SyncEngineState, trayState: SyncEngineState) -> Bool {
        // 验证引擎状态和托盘状态的同步
        switch (engineState, trayState) {
        case (.idle, .idle), (.syncing, .syncing), (.paused, .paused):
            return true
        case (.error(let engineError), .error(let trayError)):
            return engineError == trayError
        default:
            // 允许短暂的不同步（异步更新）
            return true
        }
    }
    
    private func validateErrorStateHandling(expectedError: String, actualState: SyncEngineState, statusDescription: String) -> Bool {
        guard case .error(let actualError) = actualState else {
            return false
        }
        
        let errorMessageMatches = actualError == expectedError
        let descriptionContainsError = statusDescription.contains("Error") && statusDescription.contains(expectedError)
        
        return errorMessageMatches && descriptionContainsError
    }
}
}

// MARK: - 测试支持类型

/// 系统交互类型
enum SystemInteraction {
    case trayIconClick
    case menuItemSelection(TrayMenuAction)
    case notificationReceived(StateChangeEvent)
    case finderIntegration(FinderAction)
}

/// 托盘菜单动作
enum TrayMenuAction {
    case toggleSync
    case openSyncFolder
    case openSettings
    case quit
}

/// 状态变化事件
struct StateChangeEvent {
    let previousState: SyncEngineState?
    let newState: SyncEngineState
    let timestamp: Date
    let notificationTitle: String
    let notificationMessage: String
    
    var isError: Bool {
        if case .error = newState {
            return true
        }
        return false
    }
}

/// 用户交互类型
enum UserInteraction {
    case clickTrayIcon
    case selectMenuItem(TrayMenuAction)
    case receiveNotification
}

/// Finder 动作
enum FinderAction {
    case showStatusIcon(String) // 路径
    case showContextMenu(String) // 路径
    case performQuickAction(String, String) // 路径和动作
}

// MARK: - Mock 同步引擎扩展

extension MockSyncEngine {
    func setState(_ state: SyncEngineState) {
        currentState = state
        stateSubject.continuation.yield(state)
    }
    
    func setProgress(_ progress: SyncProgress) {
        currentProgress = progress
        progressSubject.continuation.yield(progress)
    }
}

// MARK: - Arbitrary 实现

extension SystemInteraction: Arbitrary {
    public static var arbitrary: Gen<SystemInteraction> {
        return Gen.frequency([
            (2, Gen.pure(.trayIconClick)),
            (3, Gen.compose { c in
                let action = c.generate(using: TrayMenuAction.arbitrary)
                return .menuItemSelection(action)
            }),
            (2, Gen.compose { c in
                let event = c.generate(using: StateChangeEvent.arbitrary)
                return .notificationReceived(event)
            }),
            (1, Gen.compose { c in
                let action = c.generate(using: FinderAction.arbitrary)
                return .finderIntegration(action)
            })
        ])
    }
}

extension TrayMenuAction: Arbitrary {
    public static var arbitrary: Gen<TrayMenuAction> {
        return Gen.fromElements(of: [.toggleSync, .openSyncFolder, .openSettings, .quit])
    }
}

extension StateChangeEvent: Arbitrary {
    public static var arbitrary: Gen<StateChangeEvent> {
        return Gen.compose { c in
            let previousState = c.generate(using: Gen.one(of: [
                Gen.pure(nil),
                SyncEngineState.arbitrary.map(Optional.some)
            ]))
            let newState = c.generate(using: SyncEngineState.arbitrary)
            let timestamp = c.generate(using: Date.arbitrary)
            let title = c.generate(using: String.arbitrary.suchThat { !$0.isEmpty })
            let message = c.generate(using: String.arbitrary.suchThat { !$0.isEmpty })
            
            return StateChangeEvent(
                previousState: previousState,
                newState: newState,
                timestamp: timestamp,
                notificationTitle: title,
                notificationMessage: message
            )
        }
    }
}

extension UserInteraction: Arbitrary {
    public static var arbitrary: Gen<UserInteraction> {
        return Gen.frequency([
            (2, Gen.pure(.clickTrayIcon)),
            (3, Gen.compose { c in
                let action = c.generate(using: TrayMenuAction.arbitrary)
                return .selectMenuItem(action)
            }),
            (1, Gen.pure(.receiveNotification))
        ])
    }
}

extension FinderAction: Arbitrary {
    public static var arbitrary: Gen<FinderAction> {
        return Gen.frequency([
            (2, Gen.compose { c in
                let path = c.generate(using: String.arbitrary.suchThat { !$0.isEmpty })
                return .showStatusIcon(path)
            }),
            (2, Gen.compose { c in
                let path = c.generate(using: String.arbitrary.suchThat { !$0.isEmpty })
                return .showContextMenu(path)
            }),
            (1, Gen.compose { c in
                let path = c.generate(using: String.arbitrary.suchThat { !$0.isEmpty })
                let action = c.generate(using: String.arbitrary.suchThat { !$0.isEmpty })
                return .performQuickAction(path, action)
            })
        ])
    }
}